#!/bin/env python

#--------------------------------------------------------------------------------------------------#
# Name:   walletmgr                                                                                #
# Author: Randy Johnson                                                                            #
# Descr:  wrapper for mkstore, Oracle"s wallet management command.                                 #
# History:                                                                                         #
#                                                                                                  #
# Wish List:                                                                                       #
#  - Add functionality to create the wallet.                                                       #
#                                                                                                  #
# Date       Ver. Who              Change Description                                              #
# ---------- ---- ---------------- --------------------------------------------------------------- #
# 08/13/2019 0.10 Randy Johnson    Initial write.                                                  #
# 08/14/2019 0.20 Randy Johnson    Added if system() not in ('Windows', 'win32') ...               #
# 08/14/2019 0.30 Randy Johnson    Replaced str.encode(password) + "\n" with password += '\n'      #
#                                  Added cache logic.                                              #
# 08/15/2019 0.40 Randy Johnson    Added logic to encrypt/decrypt the cache: encode() decode()     #
#                                  encode_creds(), decode_creds()                                  #
#                                  Added better error handling for invalid output from mkstore.    #
#                                  Added better error handling for incorrect password.             #
# 08/15/2019 0.50 Randy Johnson    Removed all changes from 0.30 and 0.40. Modified to work with   #
#                                  -listCredential output only.                                    #
# 08/17/2019 0.60 Randy Johnson    Added -a -c -d -p -s -w options. Also moved reporting logic to  #
#                                  their own functions and added better error checking and         #
#                                  handling. Also added the silent mode which supresses prompts    #
#                                  (except the prompt for the wallet password). Improved -h usage. #
#                                  Added handling for ORACLE_WALLET environment variable that      #
#                                  sets the non-default location of the wallet. Order of           #
#                                  precidence for the wallet location is as follows:               #
#                                    1 - Toplevel override is the -w option.                       #
#                                    2 - $ORACLE_WALLET                                            #
#                                    3 - $ORACLE_HOME/network/admin/wallet                         #
#                                    4 - Default is location of this location of this program +    #
#                                        /wallet. For example: ~oracle/dba/bin/wallet              #
# 08/18/2019 0.70 Randy Johnson    Added reporting for credenmtial attributes and -n option.       #
#                                  Fixed bug when checking for "Oracle Secret Store Tool"          #
#                                  Added a code to check for existance of key in report_passwords. #
#                                  Now if credential id's provided on the command line don't exist #
#                                  we will just quietly ignore them. Should we throw a warning?    #
#--------------------------------------------------------------------------------------------------#
# --------------------------------------
# ---- Import Python Modules -----------
# --------------------------------------
from datetime     import datetime
from getpass      import getpass
from optparse     import OptionParser
from os           import access
from os           import environ
from os           import listdir
from os           import pathsep
from os           import W_OK
from os           import R_OK
from os           import X_OK
from os.path      import isdir
from os.path      import isfile
from os.path      import join as pathjoin
from os.path      import split as pathsplit
from re           import compile
from re           import search
from re           import IGNORECASE
from os.path      import basename
from signal       import signal
from shutil       import rmtree
from subprocess   import PIPE
from subprocess   import Popen
from subprocess   import STDOUT
from sys          import argv
from sys          import exit
from sys          import version_info
from platform     import system

# For handling termination in stdout pipe; ex: when you want to pipe
# the output to another program (like tail, less, ...
if system() not in ('Windows', 'win32'):
  from signal import SIGPIPE, SIG_DFL

# -------------------------------------------------
# ---- Function and Class Definitions ------------
# -------------------------------------------------

# ---------------------------------------------------------------------------
# Def : is_file_rw()
# Desc: Verifies that a file permissions are at least read write.
# Args: filepath -  Fully qualified filename.
# Retn: True     - file permissions are read and write by the current user.
#       False    - file is not read & write for the current user.
# ---------------------------------------------------------------------------
def is_file_rw(filepath):
  if access(filepath, R_OK) and access(filepath, W_OK):
    return True
  else:
    return False
# ---------------------------------------------------------------------------
# End is_file_rw()
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------
# Def : is_file_rwx()
# Desc: Verifies that a file permissions are at least read write.
# Args: filepath = Fully qualified filename.
# Retn: True   - file permissions are read and write by the current user.
#       False  - file is not read & write for the current user.
# ---------------------------------------------------------------------------
def is_file_rwx(filepath):
  if access(filepath, R_OK) and access(filepath, W_OK) and access(filepath, X_OK):
    return True
  else:
    return False
# ---------------------------------------------------------------------------
# End is_file_rw()
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------
# Def:  read_input()
# Desc: Prompts for input from the keyboard and returns values entered.
# Args: prompt - printed to the screen to prompt the user for input.
# Retn: value  - whatever is entered from the keyboard.
# ---------------------------------------------------------------------------
def read_input(prompt):
  prompt = "\n%s: " % prompt

  if(version_info[0] >= 3):
    value = input(prompt)
  else:
    value = raw_input(prompt)
  return value
# ---------------------------------------------------------------------------
# End is_file_rw()
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------
# Def:  get_pipe(cmdline)
# Desc: Deals with the Python v2 and v3 differences of subprocess as well as 
#       Windows (non-posdix) support
# Args: cmdline - The command to be passed into the subprocess
# Retn: proc  - the PIPE
# ---------------------------------------------------------------------------
def get_pipe(cmdline):
  if(version_info[0] >= 3):
    if system() in ('Windows', 'win32'):
      my_proc = Popen(cmdline, shell=True, stdin=PIPE, stdout=PIPE, stderr=PIPE, encoding='utf8')
    else:
      my_proc = Popen(cmdline, stdin=PIPE, stdout=PIPE, stderr=PIPE, encoding='utf8')
  else:
    if system() in ('Windows', 'win32'):
      my_proc = Popen(cmdline, shell=True, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    else:
      my_proc = Popen(cmdline, stdin=PIPE, stdout=PIPE, stderr=PIPE)
  
  return my_proc
# ---------------------------------------------------------------------------
# Def:  get_line()
# Desc: Deals with the Python v2 and v3 differences of subprocess
# Args: cmdline - The command to be passed into the subprocess
# Retn: proc  - the PIPE
# ---------------------------------------------------------------------------
def get_line(proc):
  if(version_info[0] >= 3):
    line = proc.stdout.readline().strip()
  else:
    line = proc.stdout.readline().decode('ascii').strip()
  return line
# ---------------------------------------------------------------------------
# End read_input()
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------
# Def:  wallet_list()
# Desc: run mkstore -wrl {wallet_dir} -list and return information from the
#       wallet
# Args: wallet    - wallet directory name
#       password  - wallet password
# Retn: creds     - dictionary of index, connect string, username
# ---------------------------------------------------------------------------
def wallet_list(wallet, password):
  output   = []
  creds    = {}
  rexpat   = r'^([a-z|A-Z]+.[a-z|A-Z]+.[a-z|A-Z]+.\D+)(\d+).*$'   # searching for 'oracle.security.client.{connect_string|username|password}nnn'
  cmdline  = ["mkstore", "-wrl", wallet, '-list']
  
  proc = get_pipe(cmdline)

  # Read all the initial output (including "Enter wallet password:")
  line = get_line(proc)
  if "Oracle Secret Store Tool" not in line:
    print("Error returned from mkstore: %s" % line)
    exit(1)
  else:
    # drain the rest of proc.stdout...
    while True:
      line = get_line(proc)
      if not line:
        break

  # Write the password to mkstore's stdin then read everything you get back...
  proc.stdin.write(password +'\n')
  proc.stdin.flush()
  while True:
#    line = proc.stdout.readline().strip()
    line = get_line(proc) 
    # Check for password problem -- oracle.security.crypto.core.CipherException: Invalid padding string (or incorrect password)
    if 'Exception' in line or 'PKI-' in line:
      print("Error returned from mkstore: %s" % line)
      exit(1)
    if not line:
      break
    else:
      # save the output...
      output.append(line)
  proc.stdin.close()
  proc.terminate()
  proc.wait()

  # Now we'll get the results of the query...
  for line in output[2:]:
    found = search(rexpat, line)
    if found:
      try:
        credstr  = ''.join(found.groups())
        credtype = found.groups()[0].split('.')[3]
        idx      = found.groups()[1]
      except:
        print("Unexpected results from -list: %s" % found.groups())
        exit(1)
      try:
        idx = int(idx.strip())
      except:
        print("Cannot convert string to int: %s" % key)
        print("  Full string: %s" % line)
        exit(1)
      if idx not in creds:
        creds[idx] = {}
      creds[idx][credtype] = credstr
  return creds
# ---------------------------------------------------------------------------
# End wallet_list()
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------
# Def:  wallet_list_credential()
# Desc: run mkstore -wrl {wallet_dir} -listCredentials and return a dictionary
#       of information returned from the wallet.
# Args: wallet    - wallet directory name
#       password  - wallet password
# Retn: creds     - dictionary of index, connect string, username
# ---------------------------------------------------------------------------
def wallet_list_credential(wallet, password):
  output   = []
  creds    = {}
  rexpat   = r'^(\d+): (\w+) (\w+).*$'  # {nnn}: test_system{nnn} system
  cmdline  = ["mkstore", "-wrl", wallet, '-listCredential']

  proc = get_pipe(cmdline)

  # Read all the initial output (including "Enter wallet password:")
  line = get_line(proc)
  if "Oracle Secret Store Tool" not in line:
    print("Error returned from mkstore: %s" % line)
    exit(1)
  else:
    # drain the rest of proc.stdout...
    while True:
      line = get_line(proc)
      if not line:
        break

  # Write the password to mkstore's stdin then read everything you get back...
  proc.stdin.write(password +'\n')
  proc.stdin.flush()
  while True:
    line = proc.stdout.readline().strip()
    # Check for password problem -- oracle.security.crypto.core.CipherException: Invalid padding string (or incorrect password)
    if 'Exception' in line or 'PKI-' in line:
      print("Error returned from mkstore: %s" % line)
      exit(1)
    if not line:
      break
    else:
      # save the output...
      output.append(line)
  proc.stdin.close()
  proc.terminate()
  proc.wait()

  # Now we'll get the results of the query...
  for line in output[2:]:
    found = search(rexpat, line)
    if found:
      try:
        idx,connstr,username = found.groups()[0:3]
      except:
        print("Unexpected results from -list: %s" % found.groups())
        exit(1)
      try:
        idx = int(idx.strip())
      except:
        print("Cannot convert string to int: %s" % key)
        print("  Full string: %s" % line)
        exit(1)
      if idx not in creds:
        creds[idx] = {}
      creds[idx]['Connect String'] = connstr
      creds[idx]['User Name']      = username

  return creds
# ---------------------------------------------------------------------------
# End wallet_list_credential()
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------
# Def:  cred_details()
# Desc: run mkstore -wrl {wallet_dir} -viewEntry {my_entry} and return
#       output...
# Args: wallet    - wallet directory name
#       password  - wallet password
#       Parm      - mkstore parameter to execute
# Retn: output    - everything mkstore prints to stdout|stderr after the
#                   password accepted.
# ---------------------------------------------------------------------------
def cred_details(wallet, password, entry):
  output  = []
  cmdline = ["mkstore", "-wrl", wallet, '-viewEntry', entry]

  try:
    proc = get_pipe(cmdline)
  except:
    print("Error calling mkstore: %s" % ' '.join(cmdline))
    exit(1)

  # Read all the initial output (including "Enter wallet password:")
  line = get_line(proc)
  if "Oracle Secret Store Tool" not in line:
    print("Error returned from mkstore: %s" % line)
    exit(1)
  else:
    # drain the rest of proc.stdout...
    while True:
      line = get_line(proc)
      if not line:
        break

  # Write the password to mkstore's stdin then read everything you get back after that.
  proc.stdin.write(password +'\n')
  proc.stdin.flush()
  while True:
    line = proc.stdout.readline().strip()
    if 'Exception' in line or 'PKI-' in line:
      print("Error returned from mkstore: %s" % line)
      exit(1)
    if not line:
      break
    else:
      # save the output...
      output.append(line)
  proc.stdin.close()
  proc.terminate()
  proc.wait()

  value = ''
  try:
    value = output[1].split('=')[1].strip()
  except:
    print("Cannot parse value returned by -viewEvent: %s" % output[1])
    exit(1)

  return value
# ---------------------------------------------------------------------------
# End cred_details()
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------
# Def:  change_password(wallet, password, connstr, username, chgpass)
# Desc: run mkstore -wrl {wallet_dir} -modifyCredential N102 scott 
#       chgpassword and return information from the wallet
# Args: wallet    - wallet directory name
#       password  - wallet password
#       Parm      - mkstore parameter to execute
# Retn: output    - everything mkstore prints to stdout|stderr after the
#                   password accepted.
# ---------------------------------------------------------------------------
def change_password(wallet, password, connstr, username, chgpass):
  output  = []
  cmdline = ["mkstore", "-wrl", wallet, '-modifyCredential', connstr, username, chgpass]
  proc = get_pipe(cmdline)

  # Read all the initial output (including "Enter wallet password:")
  line = get_line(proc)
  if "Oracle Secret Store Tool" not in line:
    print("Error returned from mkstore: %s" % line)
    exit(1)
  else:
    # drain the rest of proc.stdout...
    while True:
      line = get_line(proc)
      if not line:
        break

  # Write the password to mkstore's stdin then read everything you get back after that.
  proc.stdin.write(password +'\n')
  proc.stdin.flush()
  while True:
    line = get_line(proc)
    if 'Exception' in line or 'PKI-' in line:
      print("Error returned from mkstore: %s" % line)
      exit(1)
    if not line:
      break
    else:
      # save the output...
      output.append(line)
  proc.stdin.close()
  proc.terminate()
  proc.wait()

  return output
# ---------------------------------------------------------------------------
# End change_password()
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------
# Def:  add_credential(wallet, password, connstr, username, passwd)
# Desc: mkstore -wrl {wallet_dir} -createCredential N102 scott passwd
#       and returns information from the wallet
# Args: wallet    - wallet directory name
#       password  - wallet password
#       connstr   - Connect string of new credential
#       username  - User name for new credential
#       passwd    - Password for new credential
# Retn: output    - everything mkstore prints to stdout|stderr after the
#                   password accepted.
# ---------------------------------------------------------------------------
def add_credential(wallet, password, connstr, username, passwd):
  output  = []
  cmdline = ["mkstore", "-wrl", wallet, '-createCredential', connstr, username, passwd]

  proc = get_pipe(cmdline)

  # Read all the initial output (including "Enter wallet password:")
  line = get_line(proc)
  if "Oracle Secret Store Tool" not in line:
    print("Error returned from mkstore: %s" % line)
    exit(1)
  else:
    # drain the rest of proc.stdout...
    while True:
      line = get_line(proc)
      if not line:
        break

  # Write the password to mkstore's stdin then read everything you get back after that.
  proc.stdin.write(password +'\n')
  proc.stdin.flush()
  while True:
    line = get_line(proc)
    if 'Exception' in line or 'PKI-' in line:
      print("Error returned from mkstore: %s" % line)
      exit(1)
    if not line:
      break
    else:
      # save the output...
      output.append(line)
      print('Password added successfully')
      #TODO add call to list credential
  proc.stdin.close()
  proc.terminate()
  proc.wait()

  return output
# ---------------------------------------------------------------------------
# End add_credential()
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------
# Def:  delete_credentials(wallet, password, connstr, username, passwd)
# Desc: mkstore -wrl {wallet_dir} -createCredential N102 scott passwd
#       and returns information from the wallet
# Args: wallet    - wallet directory name
#       password  - wallet password
#       connstr   - Connect string of new credential
#       username  - User name for new credential
#       passwd    - Password for new credential
# Retn: output    - everything mkstore prints to stdout|stderr after the
#                   password accepted.
# ---------------------------------------------------------------------------
def delete_credentials(wallet, password, creds, delkeys):
  output  = []
  tns     = []

  for key in sorted(delkeys):
    if key in creds:
      tns.append(creds[key]['Connect String'])
    else:
      print("\nKey not found in wallet and will be ignored: %s" % key)

  for connstr in tns:
    output = []
    cmdline = ["mkstore", "-wrl", wallet, '-deleteCredential', connstr]
    proc = get_pipe(cmdline)

    # Read all the initial output (including "Enter wallet password:")
    line = get_line(proc)
    if "Oracle Secret Store Tool" not in line:
      print("Error returned from mkstore: %s" % line)
      exit(1)
    else:
      # drain the rest of proc.stdout...
      while True:
        line = get_line(proc)
        if not line:
          break

    # Write the password to mkstore's stdin then read everything you get back after that.
    proc.stdin.write(password +'\n')
    proc.stdin.flush()
    while True:
      line = get_line(proc)
      if 'Exception' in line or 'PKI-' in line:
        print("Error returned from mkstore: %s" % line)
        exit(1)
      if not line:
        break
      else:
        # save the output...
        output.append(line)
    proc.stdin.close()
    proc.terminate()
    proc.wait()

  return output
# ---------------------------------------------------------------------------
# End delete_credentials()
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------
# Def:  report_passwords()
# Desc: Generate a report containing credential id, connect string, user
#       name and password.
# Args: attrs - This is the long, fully qualified attributes containing
#               information stored for each credential. For example:
#                 oracle.security.client.connect_string1
#                 oracle.security.client.connect_string2
#                 ...
#                 oracle.security.client.password1
#                 oracle.security.client.password2
#                 ...
#                 oracle.security.client.username1
#                 oracle.security.client.username2
#                 ...
#       keylist  - list structure containing the credential ids to report.
# Retn: <none>
# ---------------------------------------------------------------------------
def report_passwords(attrs, keylist):
  #print("\nCredential Details...")
  print("\n%-4s %-20s %-20s %-30s" % ('ID', 'Connect String', 'User Name','Password'))
  print("%-4s %-20s %-20s %-30s" % ('----', '--------------------','--------------------','------------------------------'))

  for i,key in enumerate(passkeys):
    try:
      passkeys[i] = int(key)
    except:
      print("\nKeys must be an integer. Removing from list: %s" % key)
      passkeys.remove(key)

  for key in sorted(keylist):
    if key in attrs:
      value = cred_details(wallet, password, attrs[key]['password'])
      print("%-4s %-20s %-20s %-30s" % (key,creds[key]['Connect String'],creds[key]['User Name'],value))
# ---------------------------------------------------------------------------
# End report_passwords()
# ---------------------------------------------------------------------------


# ---------------------------------------------------------------------------
# Def:  get_keys_by_value(creds, value)
# Desc: Returns a list of keys based on value (search string)
# Args: creds - This is a dictionary structure keyed on the credential id
# 
# Retn: list
# ---------------------------------------------------------------------------
def get_keys_by_value(creds, valueToFind):
    listOfKeys = list()
    listOfItems = creds.items()
    for item in sorted(listOfItems):
      if "*" in valueToFind:
        if valueToFind.replace('*','') in item[1]["Connect String"]:
          listOfKeys.append(item[0])
      else:
        if item[1]["Connect String"] == valueToFind:
          listOfKeys.append(item[0]) 
    
    return  listOfKeys

# ---------------------------------------------------------------------------
# Def:  report_credentials()
# Desc: Generate a report containing credential id, connect string, and 
#       user name.
# Args: creds - This is a dictionary structure keye'd on the credential id
#               and containing the connect string and user name.
# Retn: <none>
# ---------------------------------------------------------------------------
def report_credentials(creds):
  print("\n%-4s %-20s %-30s" % ('ID', 'Connect String', 'User Name'))
  print("%-4s %-20s %-30s" % ('----', '--------------------','--------------------'))

  # search for param
  selvalues      = [] 
  keys = list()
  
  if args != []:
    selvalues = ','.join(args)
    selvalues = [ search_string.strip() for search_string in selvalues.split(',')]

  if selvalues == []:
    for key in sorted(creds):
      keys.append(key)
      print("%-4s %-20s %-20s" % (key, creds[key]['Connect String'], creds[key]['User Name']))
  
  else:
    for i, search_string in enumerate(selvalues):
      keys = get_keys_by_value(creds, search_string)
      for key in keys:
        print("%-4s %-20s %-20s" % (key, creds[key]['Connect String'], creds[key]['User Name']))
  
  return keys

# ---------------------------------------------------------------------------
# End report_credentials()
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------
# Def:  report_credendial_attrs()
# Desc: Generate a report containing the internal attributes for each 
#       credential. For example:
#         oracle.security.client.connect_string1
#         oracle.security.client.connect_string2
#         ...
#         oracle.security.client.password1
#         oracle.security.client.password2
#         ...
#         oracle.security.client.username1
#         oracle.security.client.username2
#         ...
# Args: creds - This is a dictionary structure keye'd on the credential id
#               and containing the long keys for each credential entry.
# Retn: <none>
# ---------------------------------------------------------------------------
def report_credendial_attrs(attrs):
  print("\nCredential Attributes...")
  for key in sorted(attrs):
    for key2 in sorted(attrs[key]):
      print("ID: %-4s Type: %-20s Complete String: %-20s" % (key, key2, attrs[key][key2]))
# ---------------------------------------------------------------------------
# End report_credendial_attrs()
# ---------------------------------------------------------------------------


# --------------------------------------
# ---- Main Program --------------------
# --------------------------------------
if (__name__ == "__main__"):
  cmd_name       = basename(argv[0]).split(".")[0]
  cmd_descr      = "Wallet Manager"
  versn          = "0.80"
  versn_date     = "Sun Aug 18 21:08:46 CDT 2019"
  dev_state      = "Development"
  banner         = cmd_descr + ": Release " + versn + " "  + dev_state + ". Last updated: " + versn_date
  now            = datetime.now()
  manifest       = ['cwallet.sso','ewallet.p12']
  creds          = {}
  delkeys        = []
  passkeys       = []
  keylist        = []
  home_dir       = pathsplit(pathsplit(argv[0])[0])[0] 
  
  usage  =  "%s [options]"  % cmd_name
  usage += "\n\n%s"         % cmd_descr
  usage += "\n------------------------------------------------------------------------------"
  usage += "\nWrapper for Oracle's mkstore comamnd."
  usage += "\n\nExamples:"
  usage += "\nAdd new credential..."
  usage += "\n%s -a mydb system welcome1" % cmd_name
  usage += "\n"
  usage += "\nChange passwords..."
  usage += "\n%s -c welcome99 1"          % cmd_name
  usage += "\n%s -c welcome99 1,2,5"      % cmd_name
  usage += "\n%s -c welcome99 1,2,5 -s"   % cmd_name
  usage += "\n"
  usage += "\nDelete credentials..."
  usage += "\n%s -d 1"                    % cmd_name
  usage += "\n%s -d 1,2,5"                % cmd_name
  usage += "\n%s -d 1,2,5 -s"             % cmd_name
  usage += "\n"
  usage += "\nList credential passwords..."
  usage += "\n%s -p 1"                    % cmd_name
  usage += "\n%s -p 1,2,5"                % cmd_name
  usage += "\n%s -p 1,2,5 -s"             % cmd_name
  usage += "\n"
  usage += "\nSpecify a wallet..."
  usage += "\n%s -w /u01/oracle/product/18c/dbhome_1/network/admin/wallet" % cmd_name

  arg_parser = OptionParser(usage)

  arg_parser.add_option("-l",  dest="listcred",   action="store_true", default=False,           help="list credential(s)")
  arg_parser.add_option("-a",  dest="addcred",    action="store_true", default=False,           help="add a new credential")
  arg_parser.add_option("-c",  dest="chgpass",                         default='',    type=str, help="change password for credentials listed by index")
  arg_parser.add_option("-d",  dest="delcred",   action="store_true",  default=False,           help="delete credentials (confirmation required)")
  arg_parser.add_option("-n",  dest="newwallet",                       default='',    type=str, help="create a new wallet")
  arg_parser.add_option("-p",  dest="listpass",   action="store_true", default=False,           help="report passwords")
  arg_parser.add_option("-s",  dest="silent",     action="store_true", default=False,           help="silent (no prompts, no confirmations)")
  arg_parser.add_option("-w",  dest="wallet",                          default='',    type=str, help="wallet (directory containing the credentials)")
  arg_parser.add_option("--v", dest="versn",      action="store_true", default=False,           help="print version info.")

  # Parse command line arguments
  options, args = arg_parser.parse_args()

  listcred  = options.listcred
  addcred   = options.addcred
  delcred   = options.delcred
  chgpass   = options.chgpass
  listpass  = options.listpass
  newwallet = options.newwallet
  silent    = options.silent
  versn     = options.versn
  wallet    = options.wallet

  if versn:
    print("\n%s" % banner)
    exit(0)

  # -a -c and -d options are mutually exclusive
  # ---------------------------------------------
  if addcred and (chgpass or delcred or newwallet):
    print("The -a option cannot be used with -c -d -n options.")
    exit(0)
  elif chgpass and (addcred or delcred or newwallet):
    print("The -c option cannot be used with -a -d -n options.")
    exit(0)
  elif delcred and (addcred or chgpass or newwallet):
    print("The -d option cannot be used with -a -c -n options.")
    exit(0)
  elif newwallet and (addcred or chgpass or delcred):
    print("The -c option cannot be used with -a -c -d options.")
    exit(0)
  elif newwallet and silent:
    print("The -n option cannot be used with -s option.")
    exit(0)

  # Get the wallet variable...
  # wallet = "/opt/oracle/product/18c/dbhome_1/network/admin/wallet"            # <------<<<< delete this line in final draft.
  if not wallet:
    if 'ORACLE_WALLET' in environ:
      wallet = environ['ORACLE_WALLET']
    elif 'ORACLE_HOME' in environ:
      wallet = pathjoin(environ['ORACLE_HOME'], 'network', 'admin', 'wallet')
    else:
      wallet = pathjoin(home_dir, 'wallet')
  
  # Get the wallet password from keyboard....
  #password = 'Mischief9911#'
  password = getpass("\nEnter wallet password: ")
  if password.strip() == '':
    print("\nWallet password required: %s" % password)
    exit(1)

  # Create a new wallet...
  if newwallet:
    print("\nTo create a new wallet, run the following command and enter your wallet password when prompted:")
    print("\n   mkstore -wrl %s -create" % wallet)
    exit()
            
  # Validate wallet...
  if isdir(wallet):
    perms = is_file_rwx(wallet)
    if not perms:
      print("\nDirectory permissions for wallet must be read+write+execute for current user.")
      exit(1)
    wallet_contents = listdir(wallet)
    for item in manifest:
      if item not in wallet_contents:
        print("\nRequired file missing from wallet: %s" % item)
        print("\n  Wallet  : %s" % wallet)
        print("\n  Required: %s" % manifest)
        exit(1)
    for item in manifest:
      perms = is_file_rw(pathjoin(wallet, item))
      if not perms: 
        print("\nPermissions for file must be read+write: %s" % pathjoin(wallet,item))
        exit(1)
  else:
    print("\nInvalid wallet: %s" % wallet)
    wallet = read_input("Enter wallet")
    if not isdir(wallet):
      print("\nInvalid wallet: %s" % wallet)
      exit(1)
  
  # Extract basic info that is used for most things.
  # --------------------------------------------------------
  creds = wallet_list_credential(wallet, password)
  attrs = wallet_list(wallet, password)

  # print a report of key, connect string, user name
  if listcred:
    report_credentials(creds)

  # Adda new credential...
  if addcred:
    response = 'N'
    if len(args) != 3:
      print("\nWhen adding a new credential, 3 parameters are required.")
      print("  1) connect string")
      print("  2) username")
      print("  3) password")
      print("\nFor example: %s -a my_database system welcome1" % cmd_name)
      exit(1)
    else:
      connstr,username,passwd = args
      if not silent:
        print("\nAdd new credential defined as follows:")
        print("\n   Connect String: %s" % connstr)
        print("       User Name: %s" % username)
        print("        Password: %s" % passwd)
        response = read_input("Continue? (y/N)")
      if silent or response.upper()[0] == 'Y':
        output = add_credential(wallet, password, connstr, username, passwd)
        exit()
      else:
        print("\nAdd credential cancelled.")
        exit()

  # Report full credentials including password for keys provided.
  if listpass:
    if args != []:
      keylist = ','.join(args)
      keylist = [ key.strip() for key in keylist.split(',')]
    for i,key in enumerate(keylist):
      try:
        keylist[i] = int(key)
      except:
        print("\nKeys must be an integer. Removing from list: %s" % key)
        keylist.remove(key)

  # Delete credential(s) specified by their numeric key.
  if delcred:
    if args != []:
      delkeys = ','.join(args)
      delkeys = [ key.strip() for key in delkeys.split(',')]
    for i,key in enumerate(delkeys):
      try:
        delkeys[i] = int(key)
      except:
        print("\nKeys must be an integer. Removing from list: %s" % key)
        delkeys.remove(key)

    if delkeys != []:
      if not silent:
        print("\nThe following credentials are flagged for deletion: %s" % sorted(delkeys))
        response = read_input("Continue? (y/N)")
      if silent or response.upper()[0] == 'Y':
        output = delete_credentials(wallet, password, creds, delkeys)
        exit()
      else:
        print("\nDelete credentials cancelled.")
        exit()
    else:
      if not silent:
        response = read_input("Enter the key(s) of the credentials to delete")
        if response is '':
          exit()
        else:
          if ' ' in response:
            response = response.replace(' ',',')
          delkeys = [ int(key.strip()) for key in response.split(',')]
        print("\nYou've selected %s for deletion: " % sorted(delkeys))
        response = read_input("Continue (y/N)")
      if silent or response.upper()[0] == 'Y':
        output = delete_credentials(wallet, password, creds, delkeys)
        exit()
      else:
        print("\nDelete credentials cancelled.")
        exit()

  # Change password for credential(s) specified by their numeric key.
  if chgpass != '':
    passkeys = [key.strip() for key in args[0].split(',')]
    for i,key in enumerate(passkeys):
      try:
        passkeys[i] = int(key)
      except:
        print("\nKeys must be an integer. Removing from list: %s" % key)
        passkeys.remove(key)

    print("\nChanging password for the following credentials: %s" % sorted(passkeys))
    if not silent:
      response = read_input("Continue (y/N)")
    if silent or response.upper()[0] == 'Y':
      for key in passkeys:
        if key not in creds:
          print("Skipping key not found in wallet: %s" % key)
        else:
          connstr  = creds[key]['Connect String']
          username = creds[key]['User Name']
          out = change_password(wallet, password, connstr, username, chgpass)

      # Report New Passwords...
      attrs = wallet_list(wallet, password)
      report_passwords(attrs, passkeys)

  if listpass:
    if keylist == []:
      keylist = sorted(creds)

    report_passwords(attrs, keylist)
  
  #report_credendial_attrs(attrs)
  
  exit(0)
