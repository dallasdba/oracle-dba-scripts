#!/usr/bin/env perl

##################################################################################################
# Name:        dixie                                                                             #
# Author:      Randy Johnson                                                                     #
# Description: Performs Recovery Manager tasks such as backup, crosscheck, delete expired, etc.  #
# ---------------------------------------------------------------------------------------------- #
#                                                                                                #
# Assumptions                                                                                    #
# --------------------                                                                           #
# Rman will be run from a node that is configured to run an instance of the target database. The #
# node RDBMS binaries installed and an entry for the Service Name must be configured in the      #
# oratab file. The service name -or- ORACLE_SID is used to connect using sqlplus and rman. It is #
# *not* the intention that this script to support running rman from a remote server that does    #
# not have an instance configured on it. However, assuming the target instance has an entry in   #
# the oratab file and that there *is* an ORACLE_HOME installed for the instance, this should be  #
# possible. But this is beyond the scope of this script and we cannot be certain that all        #
# appropriate checks are in place to validate the environment. If remote RMAN sessions turn out  #
# to be a requirement then, with a little more work we could support it.                         #
#                                                                                                #
# If using -servicename the the -user specified must be granted sysdba on each instance that     #
# that the servicename will connect to when allocating channels. If you don't then you will get  #
# a ORA-01017 error for the channels allocated on each instance where this is not done.          #
#                                                                                                #
# Hot Backups:                                                                                   #
#   - If the state of the database is STARTED (not mounted, not open) or UNKNOWN then the backup #
#     fails and the program exits.                                                               #
#   - If the state of the database is MOUNTED then online redologs will not be flushed.          #
#                                                                                                #
# Usage                                                                                          #
# --------------------                                                                           #
# Input Parms: [-type OPERATION_TYPE] ...                                                        #
#              [-help] Displays the Usage message. Many other options supported. See dixie -h    #
#              or Dixie User's Guide for more informaiton.                                       #
#                                                                                                #
#              Complete List of Command Line:                                                    #
#              -archcopies -archlogs -catalog -catuser -channels -checksyntax -comprlevel        #
#              -comproptim -configure   -controlfile -copy -cumulative -debug -deletedelay       #
#              -deletelogs -device -directory -distchannels -duration -filesperset -force        #
#              -format -generate -help -keepdays -keeplogs -level -maxopenfiles -maxpiecesize    #
#              -maxsetsize -nocat -nochecksum -noexclude -obsolete -parfile -plusarchlogs        #
#              -rate -sbtlib -script -sectionsize -servicename -show -skip -trace -type -user    #
#              -version                                                                          #
#                                                                                                #
# Return Code: > 0 indicates failure.                                                            #
#                                                                                                #
# Change History                                                                                 #
# ----------------                                                                               #
#                                                                                                #
# Date       Ver  Who              Change Description                                            #
# ---------- ---- ---------------- ------------------------------------------------------------- #
# Date       Ver  Who              Change Description                                            #
# ---------- ---- ---------------- --------------------------------------------------            #
# 03/15/2008 2.00 Randy Johnson    Version 2 first release. Covering Oracle 9i, 10g, 11g         #
#                                  v2 is more modular from a Rman version support perspective.   #
#                                  New features include -script, -deletedelay, -copy,            #
#                                  and -archcopies options + full option/version compatability   #
#                                  checking. Due to the modularized nature 2.0 promisses to be   #
#                                  a more programatically extensible design making support for   #
#                                  future versions of RMAN easier to implement.                  #
# 04/03/2008 2.01 Randy Johnson    Fixed bug in FRA backups by undefining $Copy option if set    #
#                                  Enhancement to -notify option to allow it to be turned off.   #
#                                  New -notify options are (success, fail, off)                  #
# 04/04/2008 2.02 Randy Johnson    Removed a duplicate print statement for ExternalScript in the #
#                                  banner.                                                       #
# 04/04/2008 2.03 Randy Johnson    Fixed a formatting problem with the -Channel Format in the    #
#                                  banner. Fixed version info 2.3 -> 2.03                        #
# 04/04/2008 2.04 Randy Johnson    Added additional trace statements.                            #
# 04/11/2008 2.05 Randy Johnson    Added additional trace statements for $RmanLog. Fixed RmanLog #
# 04/11/2008 2.06 Randy Johnson    Fixed formatting on 'Recovery File Dest...                    #
# 04/14/2008 2.07 Randy Johnson    Moved trace statements below open FILE,">$DixieLog";          #
# 04/15/2008 2.08 Randy Johnson    Fixed formatting on '-SBT Backup Directory...                 #
# 04/24/2008 2.09 Randy Johnson    Fixed handling for TNS_ADMIN due to comments like '*:' in     #
#                                  the oratab file. Cosmetic changes to Banner.                  #
# 04/24/2008 2.10 Randy Johnson    Add 'plus archivelog' backup functionality (-plusarchlogs)    #
#                                  Where using flash recovery area to stora archlogs you should  #
#                                  always use this option in conjunction with BACKUP             #
#                                  OPTIMIZATION' turned on. Else archivelogs will be backed up   #
#                                  over and over again until old archivelogs age out of FRA.     #
# 06/06/2008 2.11 Randy Johnson    Moved initialization of $BackupDevice up to avoid false error #
#                                  "Recovery Area Backups can only go to an SBT (tape) device."  #
# 06/20/2008 2.12 Randy Johnson    Fix for delete_obsolete() and delete_expired() functions      #
#                                  where FRA was being put in the maintenance channel format if  #
#                                  device was disk and format was set to "FRA"                   #
# 07/23/2008 2.13 Randy Johnson    Add support for backing up standby databases. Uses their      #
#                                  db_unique_name instead of the database name for script names, #
#                                  log file names, directory names, etc.                         #
# 10/12/2009 2.14 Randy Johnson    Fixed $Notify error (print statement). Improved error message #
#                                  when using -script option.                                    #
# 02/03/2010 2.15 Randy Johnson    Fixes to $Notify variable checking.                           #
# 09/18/2010 2.16 Randy Johnson    Added $Level to the banner.                                   #
#                                  Changed:  if ($Level ne 'full') {                             #
#                                       To:  if (($Level ne 'full') and ($Level ne 0)) {         #
# 09/18/2010 2.16 Randy Johnson    Added $Level to the banner.                                   #
# 01/04/2012 2.17 Randy Johnson    Removed handling for setting TNS_ADMIN= first home found in   #
#                                  the oratab file (when no TNS_ADMIN specified).                #
# 01/04/2012 2.18 Randy Johnson    Added GPL Copywrite and Licensing terms. No code change from  #
#                                  v2.17.                                                        #
# 09/10/2012 2.19 Randy Johnson    Added the 'delete $ENV{SQLPATH}' command to protect dixie     #
#                                  from customized login.sql scripts. If a login.sql scroipt     #
#                                  tries to run queries in a /nolog session sqlplus will throw   #
#                                  errors which may be harmless but dixie treats as critical.    #
# 09/10/2013 2.19a Randy Johnson   Added Dixie artwork to -v output.                             #
# 02/25/2013 2.20  Randy Johnson   Removed auto startup/shutdown logic. Too risky and too        #
#                                  complicated for RAC environments.                             #
# 06/11/2013 2.21  Randy Johnson   Added logic to strip whitespace before and after password     #
#                                  info read from password file during lookup. Also added        #
#                                  Section Size (SECTION_SIZE).                                  #
# 06/19/2013 2.22  Randy Johnson   Set feedback to off for db status and mode functions.         #
# 06/20/2013 2.23  Randy Johnson   Added -checksyntax option for validating scripts.             #
# 06/22/2013 2.24  Randy Johnson   Added RacCheck and CountInstances functions. Changed the way  #
#                                  I was determining if a database was RAC or not.               #
# 06/22/2013 2.25  Randy Johnson   Added the distributed channels with the -distchannels option. #
#                                  This allows backup channels to be distributed across RAC      #
#                                  instances.                                                    #
# 06/25/2013 2.26  Randy Johnson   Fixed a bug causing delete_obsolete to not work. The          #
#                                  fix involved setting $DeleteObsolete to true when             #
#                                  -type delete_obsolete specified. Added the device type to the #
#                                  log file and rman script file names. I now parse the config   #
#                                  file first when the parfile option is used (giving precedence #
#                                  to settings in the parfile.                                   #
# 06/26/2013 2.27 Randy Johnson    Legacy code for supporting 9i-10g environments removed.       #
#                                  Support for Windows OS removed. $DeleteLogs is forced true if #
#                                  $DeleteDelay option used.                                     #
# 06/30/2013 2.28 Randy Johnson    Added password decryption.                                    #
# 07/02/2013 2.29 Randy Johnson    Changed compression from true/false to basic,low,medium,high. #
# 07/07/2013 2.30 Randy Johnson    Did some cleanout of old unused functions, removed Notify     #
#                                  feature (including references to 'dist.list' file, made       #
#                                  config file optional, moved all polling for database          #
#                                  information (except GetInstState()) into a single call to the #
#                                  database -- GetDbInfo(). Added a WARNING message when backing #
#                                  up to SBT_LIBRARY=oracle.disksbt. Removed 'fra' from the list #
#                                  of list of format options. Now if format is null, fra is      #
#                                  implied. Changed compression options from boolean (on/off) to #
#                                  BASIC, LOW, MEDIUM, HIGH, and 'OPTIMIZED FOR LOAD'. Added Pid #
#                                  Check (see $PidFile) to handle orphaned or running oraback    #
#                                  sessions.                                                     #
# 07/08/2013 2.31 Randy Johnson    Added "unlink" RMAN Script for non-External scripts.          #
# 07/11/2013 2.32 Randy Johnson    Changed the $Level variable to $IncrLevel to more clearly     #
#                                  associate it with incremental backups.                        #
# 07/12/2013 2.33 Randy Johnson    Added RMAN Configure Commands $ConfigureRman variable.        #
# 07/12/2013 2.34 Randy Johnson    Added GetInstSvcCount() function to capture the number of     #
#                                  database instances advertising the $TargetService,            #
#                                  (service name). Needed to separate the $TargetSid and         #
#                                  $TargetService values. $TargetService was being set to        #
#                                  $TargetSid when no -servicename was provided.                 #
# 07/25/2013 2.35 Randy Johnson    Added tnsping and service name check using GetDbInfo()        #
# 07/27/2013 2.36 Randy Johnson    Small change to parfile logic. Now Parfile overrides config   #
#                                  file settings. The order of precedence is as follows:         #
#                                    1) Command-line --> 2) Parfile --> 3) Configfile            #
# 08/02/2013 2.37 Randy Johnson    Oops! Don't need to validate the Service name if none         #
#                                  specified. Simple "if ($ServiceConnStr ne '')" circumvents    #
#                                  this check.                                                   #
# 09/20/2013 2.38 Randy Johnson    Added some missing options to the archivelog backups. Fixed   #
#                                  a bug causing the TAG to be omitted from archivelog BU's.     #
# 10/12/2013 2.39 Randy Johnson    Put Notify() back in. Remove dist.list and add to dixie.conf  #
#                                  as distlist config setting and command line option as         #
#                                  -distlist.                                                    #
# 02/17/2014 2.40 Randy Johnson    Bug fix. Removed the uc() from the following line in the      #
#                                  GetInstSvcCount() function:                                   #
#                                   if ($Service eq uc($ServiceName))                            #
# 06/25/2014 2.41 Randy Johnson    Minor fix for $Redundancy. Undefine $Redundancy when not      #
#                                  specified (no default).                                       #
# 07/02/2014 2.42 Randy Johnson    Minor fix for cumulative incremental backups...               #
#                                    } elsif ($cfgHash{CUMULATIVE} eq 'true' ) {                 #
#                                   added -->    $Cumulative = 'true';                           #
# 08/31/2014 2.43 Randy Johnson    Added logic to catch unintentional backups against +ASM       #
#                                  See ProcessOptions: if (substr($ENV{ORACLE_SID}, 0,1) eq '+') #
# 11/20/2014 2.44 Randy Johnson    Bug fix in GetInstS()                                         #
#                                    Changed:  if ($DbState =~ m/ORA-01034.*/)                   #
#                                    To:       if ($SqlOut =~ m/ORA-01034.*/)                    #
# 12/09/2014 2.45 Randy Johnson    Changed command line and config file options for DbfList and  #
#                                  TbsList to datafiles and tablespaces respectively.            #
# 05/25/2015 2.46 Randy Johnson    Cosmetic fixes:                                               #
#                                  Only print "Database File List: ..." if $OperType='datafile'  #
#                                  Only print "Tablespaces List: ..." if $OperType='tablespace'  #
#                                  Only print $OpenMode in the backup script if $DbState='open'  #
#                                  Only print $PrimaryDbUniqueName" if != ''                     #
# 08/19/2015 2.47 Randy Johnson    Removed inappropriate error handling in Notify(). Removed:    #
#                                    ($rc, @ErrorStack) = ErrorCheck($MailOut)                   #
# 09/19/2015 2.48 Randy Johnson    Testing for 12c.                                              #
# 10/06/2015 2.49 Randy Johnson    Removed code block "if ($OperType ne 'fra')" from             #
#                                  ProcessOptions() function.                                    #
# 10/28/2015 2.50 Randy Johnson    Just removing ##! comments. (cleanup)                         #
# 10/28/2015 2.51 Randy Johnson    Fix to MaxDuration time format validation. HH:MM can now be   #
#                                  any hour 00...99999... Same for MM.                           #
# 02/09/2016 2.52 Randy Johnson    Removed superflous logic in the ProcessOptions subroutine.    #
#                                  For example:                                                  #
#                                    if($TargetService eq '') {                                  #
#                                       ...                                                      #
#                                    } else {                 < Removed the else statement.      #
#                                       $TargetServ = ''}     < Removed the else statement.      #
# 02/12/2016 2.53 Randy Johnson   Added "and $TargetService ne ''" where generating the          #
#                                 CONFIGURE DB_UNIQUE_NAME command (see -configure option).      #
#                                 Since the TargetService is used to configure the               #
#                                 db_unique_name, it makes sense to require it. If TargetService #
#                                 is not specifid (see -service option) then the CONFIGURE       #
#                                 statement is not generated.                                    #
# 02/16/2016 2.54 Randy Johnson   12c changed the way we determine active service names. Added   #
#                                 logic to the GetInstSvcCount() function to select count(*)     #
#                                 v$active_services and gv$active_services view for 12c.         #
# 09/20/2016 2.55 Randy Johnson   Removed "archive log current" from FRA backups. Allows for FRA #
#                                 to complete backup to tape when FRA is full.                   #
# 09/22/2016 2.56 Randy Johnson   When using the -Configure option, only configure retention if  #
#                                 the $Retention option is set (via command line option,         #
#                                 parfile, or dixie.conf.                                        #
# 09/24/2016 2.57 Randy Johnson   Modified the options printed at runtime for compression to be  #
#                                 more intuitive.                                                #
#                                 Removed "archive log current". Can cause failure if FRA is     #
#                                 full.                                                          #
# 10/28/2016 2.58 Randy Johnson   Added prefix of "Co" to command line option variables to       #
#                                 cleanly separate them from the runtime variables of the same   #
#                                 name. Reverted back to full overrides between dixie.conf,      #
#                                 parfile (if any), and command line options. Variables are      #
#                                 overridden in the following order: dixie.conf, parfile, and    #
#                                 command line option. This way dixie.conf is global defaults    #
#                                 parfile can override defaults, and then command line can       #
#                                 override both dixie.conf and parfile options.                  #
# 10/28/2016 2.59 Randy Johnson   Cosmetic changes to the banner. Corrected misspelling in the   #
#                                 header of the RMAN script.                                     #
# 11/08/2016 2.60 Randy Johnson   Cosmetic change. Fixed print formatting for "Format" in the    #
#                                 header of screen output.                                       #
# 03/13/2017 2.61 Randy Johnson   Moved some things around in the run blocks in order to execute #
#                                 "alter system archive log current" outside the run block.      #
#                                 Added KEEP UNTIL to the archivelog backups and FRA backups.    #
#                                 Added error checking to prevent the -plusarchlogs and          #
#                                 -archlogs options from being used together.                    #
# 03/14/2017 2.62 Randy Johnson   Shortened the TAG for database backups by abbreviating the     #
#                                 $OperType as DATABASE > DB, DATAFILE > DF, TABLESPACE > TS.    #
#                                 This is to prevent the TAG from overrunning its max length of  #
#                                 30 characters.                                                 #
# 03/15/2017 2.63 Randy Johnson   Changed the -keeplogs option to -keepnologs. This was done to  #
#                                 because as of 11g the LOGS option became unnecessary -- that   #
#                                 is $KeepLogs == True became the default. So in order to allow  #
#                                 LOGS to be turned off on the command line (NOLOGS) it is more  #
#                                 intuitive and consistent with all other boolean options to use #
#                                 the nologs option. That is -nologs == False is now the default #
#                                 (same as KEEP LOGS) and can be activated using the -keepnologs #
#                                 option (KEEP_NOLOGS = true).                                   #
# 05/31/2017 2.64 Randy Johnson   Correction: $Tag = 'AL_BS_ALL' for archivelog backups changed  #
#                                 to $Tag = 'AL_BS_AL'. Removed uc($TagLevel) from the backup    #
#                                 tag when the KeepDays option is used. See MOS Doc ID 1607250.1 #
#                                 Delete Archivelog Backed Up Does Not Delete Archivelogs Even   #
#                                 When They Are Already Backed Up To Tape.                       #
# 03/06/2018 2.65 Randy Johnson   Disable ConfigureRman option for -type register operations.    #
# 01/29/2019 2.66 Randy Johnson   Found == where should be eq in ProcessOptions()                #
#                                 if $ConfigureRman == 'true') and if ($OperType == 'register')  #
#                                 and eq where should be == in CheckFeatureCompatability         #
#                                 if $IncrLevel eq 0 ...                                         #
# 02/11/2019 2.67 Randy Johnson   Remove ORACLE_PATH from environment.                           #
# 09/24/2019 2.68 Randy Johnson   Fixed bug where $BackupFormat was being set to a default value #
#                                 and causing a warning message when $BackupDir was not set.     #
# 02/03/2021 2.69 Randy Johnson   Added logic to enforce TargetService when using -distchannels. #
#                                                                                                #
# Wish List                                                                                      #
# --------------------                                                                           #
# - When the password cannot be found in the password file, print the lookup info in the message #
# - Need to better document the parfile options in the Help:                                     #
#    ARCH_COPIES                                                                                 #
#    BACKUP_ARCHLOGS                                                                             #
#    BACKUP_CONTROLFILE                                                                          #
#    BACKUP_DEVICE                                                                               #
#    BACKUP_DIRECTORY                                                                            #
#    BACKUP_TYPE                                                                                 #
#    CATALOG                                                                                     #
#    CATALOG_USER                                                                                #
#    CHECK_SYNTAX                                                                                #
#    COMPRESSION_LEVEL                                                                           #
#    COMPRESSION_OPTIMIZATION                                                                    #
#    CONFIGURE_RMAN                                                                              #
#    COPY                                                                                        #
#    CUMULATIVE                                                                                  #
#    DBFLIST                                                                                     #
#    DEBUG                                                                                       #
#    DELETE_ARCHLOGS                                                                             #
#    DELETE_DELAY                                                                                #
#    DELETE_OBSOLETE                                                                             #
#    DISK_CHANNELS                                                                               #
#    DISK_FILES_PER_SET                                                                          #
#    DISK_FORMAT                                                                                 #
#    DISK_MAX_PIECE_SIZE                                                                         #
#    DISK_MAX_SET_SIZE                                                                           #
#    DISK_STREAMING_RATE                                                                         #
#    DISTLIST                                                                                    #
#    DISTRIBUTED_CHANNELS                                                                        #
#    DURATION                                                                                    #
#    FORCE                                                                                       #
#    GENERATE                                                                                    #
#    INCREMENTAL_LEVEL                                                                           #
#    KEEP_DAYS                                                                                   #
#    KEEP_NOLOGS                                                                                 #
#    MAX_OPEN_FILES                                                                              #
#    NO_CHECKSUM                                                                                 #
#    NO_EXCLUDE                                                                                  #
#    NOTIFY                                                                                      #
#    ORACLE_SID                                                                                  #
#    PLUS_ARCHLOGS                                                                               #
#    RETENTION                                                                                   #
#    SBT_CHANNELS                                                                                #
#    SBT_FILES_PER_SET                                                                           #
#    SBT_FORMAT                                                                                  #
#    SBT_LIBRARY                                                                                 #
#    SBT_MAX_PIECE_SIZE                                                                          #
#    SBT_MAX_SET_SIZE                                                                            #
#    SBT_PARMS                                                                                   #
#    SBT_STREAMING_RATE                                                                          #
#    SCRIPT                                                                                      #
#    SECTION_SIZE                                                                                #
#    SERVICE_NAME                                                                                #
#    SHOW                                                                                        #
#    SKIP                                                                                        #
#    TBSLIST                                                                                     #
#    TNS_ADMIN                                                                                   #
#    USER                                                                                        #
# - Add a function to check the v$pwfile_users file for the -user. Select * from gv$pwfile_users #
# - Add client info to all RMAN sessions. (SET COMMAND ID TO 'RMAN:VALIDATE_RESTORE')            #
# - BACKUP BACKUPSET (to disk/tape).                                                             #
#   Note that if backup optimization is enabled when you issue the command to back up a backup   #
#   the backup of that backup set.                                                               #
#     BACKUP COPIES 2 DEVICE TYPE sbt BACKUPSET ALL;                                             #
#     BACKUP BACKUPSET ALL                                                                       #
#     BACKUP BACKUPSET 12                                                                        #
#     BACKUP DEVICE TYPE sbt BACKUPSET ALL                                                       #
#     BACKUP BACKUPSET COMPLETED BEFORE 'SYSDATE-7' DELETE INPUT;                                #
# - Add support in the -configure   option for excluding a list of HCC tablespaces.              #
#    For example: CONFIGURE EXCLUDE FOR TABLESPACE tbs1, tbs2, tbs3, ..., tbsn                   #
# - BACKUP TABLESPACE ...                                                                        #
# - BACKUP DATAFILE ..                                                                           #
# - Add Backup to DESTINATION feature for FRA backups to disk.                                   #
# - Add DISKRATIO option. May not help for ASM unless Node afinity(distchan) option.             #
# - Check into adding a running log (tail -f rman.dixie....log                                   #
# - Need to review this code for external sripts: $BackupDir =~ s/\[DBNAME\]/DatabaseName/;      #
# - Ability to store backup scripts in the recovery catalog. (ability to execute backup scripts  #
#   stored in the recovery catalog).                                                             #
#                                                                                                #
# Unit Test Results                                                                              #
# -------------------                                                                            #
# - Print a warning when and invalid -level is used. For example: -level 2.                      #
#   Consider setting -level to 1 if invalid level is specified. See code below:                  #
#      if ($IncrLevel ne '0') and ($IncrLevel ne '1') and ($IncrLevel ne 'full')                 #
#         $IncrLevel = 'full'                                                                    #
#                                                                                                #
##################################################################################################

# --------------------------
# Import Modules/Functions
# --------------------------
use File::Basename;
use File::Path;
use Getopt::Long;
use Sys::Hostname;
use FindBin;
use MIME::Base64;
use lib "$FindBin::Bin";

# For development purposes only.
# ---------------------------------
#use diagnostics;
#use strict;
#use warnings;

# --------------------------
# Function Prototypes
# --------------------------
sub ArchBackup11g($);
sub DbBackup11g($);
sub CheckFeatureCompatibility();
sub CheckInstState();
sub CountInstances($);
sub Crosscheck();
sub DeleteExpired();
sub DeleteObsolete();
sub ErrorCheck($);
sub FraBackup11g();
sub GenerateScript($$$$);
sub GetBinVersion();
sub GetDbInfo($);
sub GetDbVersion($);
sub GetInstState($);
sub GetInstSvcCount($$);
sub GetPassword($$);
sub ImportRmanLog($);
sub IsNumber($);
sub ListExpired();
sub LoadOptions($);
sub LoadScript($$);
sub Notify($$$);
sub PrintError($);
sub PrintHelp();
sub PrintUsage($);
sub PrintWarning($);
sub ProcessOptions();
sub Register();
sub ReportNeedBackup();
sub ReportObsolete();
sub ReportSchema();
sub ReportUnrecoverable();
sub Resync();
sub RunRmanScript($);
sub RunSqlplus($$;$);
sub SetOracleEnv($);
sub ShowDate($);
sub TnsPing($);
sub TrimString($);
sub ValidateBackup();
sub ValidateRestore();
sub WriteNewFile($$);

# --------------------------
#  Main
# --------------------------
my $Version             = '2.69';
my $ReleaseDate         = 'Wed Feb  3 10:40:08 CST 2021';
my $Basename            = basename($0);
my $HostName            = hostname();
my $PassFile            = '.passwd';
my $Pid                 = $$;
my $MainRC              = 0;
my ($CmdName, $junk)    = split('\.', $Basename);
my $ErrChk              = 1;
my $DbName              = 'UNKNOWN';
my $DbUniqueName        = 'UNKNOWN';
my $DbOpenMode          = 'UNKNOWN';
my $PrimaryDbUniqueName = 'UNKNOWN';
my $DbRole              = 'UNKNOWN';
my $DbSwitchoverStatus  = 'UNKNOWN';
my $ClusterDatabase     = 'UNKNOWN';
my $InstCount           = 'UNKNOWN';
my $DbRecoveryDest      = 'UNKNOWN';
my $DbRecoveryDestSize  = 'UNKNOWN';
my $SysConnStr          = '/ as sysdba';
my $RunBlock            = '';
my $InstSvcCount        = 0;

# ------------------------------------------------------------------------
# Begin Main
# ------------------------------------------------------------------------

# Set Directory Locations:
# The default directory locations are nested under parent directory
# where this script is located. For example if dixie is installed
# in the /home/oracle/dba/bin directory, then the etc directory
# will be /Users/Randy/etc. This behavior may be overridden by
# setting the following environment variables to the desired location.
#------------------------------------------------------------------------
$ENV{DIXIE_HOME}    = File::Basename::dirname($FindBin::Bin) if (not defined $ENV{DIXIE_HOME});
$ENV{DIXIE_ETC}     = $ENV{DIXIE_HOME}  . '/etc'             if (not defined $ENV{DIXIE_ETC});
$ENV{DIXIE_LOG}     = $ENV{DIXIE_HOME}  . '/log'             if (not defined $ENV{DIXIE_LOG});
$ENV{DIXIE_TMP}     = $ENV{DIXIE_HOME}  . '/tmp'             if (not defined $ENV{DIXIE_TMP});
$ENV{DIXIE_SCRIPTS} = $ENV{DIXIE_HOME}  . '/rman'            if (not defined $ENV{DIXIE_SCRIPTS});

# Verify directories.
# ------------------------
@DirectoryList = ($ENV{DIXIE_ETC}, $ENV{DIXIE_LOG}, $ENV{DIXIE_TMP}, $ENV{DIXIE_SCRIPTS});
foreach $Directory (@DirectoryList) {
   if ( not -d $Directory ) {
      PrintError( "Unable to open directory: $Directory\nEnsure this directory exists and that you have access to it.");
      exit 1;
   }
}

# Set Dixie Filenames
# --------------------------
$ConfigFile     = $ENV{DIXIE_ETC} . '/' . $CmdName . '.conf';   # Set the configuration file name.
$PassFile       = $ENV{DIXIE_ETC} . '/' . $PassFile;            # Set preferred password file -- alternate password files defined further down.

# The following removes SQLPATH AND ORACLE_PATH from the
# environment. This is to protect calls dixie makes to sqlplus
# from customized login.sql scripts that have been put in place
# by the DBA.
# -------------------------------------------------------------
delete $ENV{SQLPATH};
delete $ENV{ORACLE_PATH};

# Make STDERR and STDOUT unbuffered
# ------------------------------------
select STDERR; $| = 1;
select STDOUT; $| = 1;

# NLS Lang & Date format handling
# ------------------------------------
$ENV{NLS_DATE_FORMAT} = 'YYYY-MM-DD HH24:MI:SS'          if (not defined $ENV{NLS_DATE_FORMAT});
$ENV{NLS_LANG}        = 'AMERICAN_AMERICA.WE8ISO8859P1'  if (not defined $ENV{NLS_LANG});

# Command line options
# ------------------------
$OptOutput = GetOptions (
  'archcopies:s'        => \$CoArchCopies,
  'archlogs'            => \$CoArchLogs,
  'catalog:s'           => \$CoCatSid,
  'catuser:s'           => \$CoCatUser,
  'channels:s'          => \$CoChannels,
  'checksyntax'         => \$CoCheckSyntax,
  'comprlevel:s'        => \$CoComprLevel,
  'comproptimized'      => \$CoComprOptim,
  'controlfile'         => \$CoControlfile,
  'configure'           => \$CoConfigureRman,
  'copy'                => \$CoCopy,
  'cumulative'          => \$CoCumulative,
  'datafiles:s'         => \$CoDbfList,
  'debug'               => \$CoDebug,
  'deletedelay:s'       => \$CoDeleteDelay,
  'deletelogs'          => \$CoDeleteLogs,
  'distchannels'        => \$CoDistChan,
  'device:s'            => \$CoBackupDevice,
  'distlist:s'          => \$CoDistList,
  'directory:s'         => \$CoBackupDir,
  'duration:s'          => \$CoMaxDuration,
  'filesperset:i'       => \$CoFilesPerSet,
  'force'               => \$CoForce,
  'format:s'            => \$CoBackupFormat,
  'generate'            => \$CoGenerate,
  'help'                => \$CoHelp,
  'keepdays:s'          => \$CoKeepDays,
  'keepnologs'          => \$CoKeepNoLogs,
  'level:s'             => \$CoIncrLevel,
  'maxopenfiles:s'      => \$CoMaxOpenFiles,
  'maxpiecesize:s'      => \$CoMaxPieceSize,
  'maxsetsize:s'        => \$CoMaxSetSize,
  'nocat'               => \$CoNoCat,
  'nochecksum'          => \$CoNoChecksum,
  'noexclude'           => \$CoNoExclude,
  'notify:s'            => \$CoNotify,
  'obsolete'            => \$CoDeleteObsolete,
  'parfile:s'           => \$CoParFile,
  'plusarchlogs'        => \$CoPlusArchlogs,
  'retention:s'         => \$CoRetention,
  'rate:s'              => \$CoStreamingRate,
  'sbtlib:s'            => \$CoSbtLibrary,
  'script:s'            => \$CoExternalScript,
  'sectionsize:s'       => \$CoSectionSize,
  'servicename:s'       => \$CoTargetService,
  'sid:s'               => \$CoTargetSid,
  'show'                => \$CoShow,
  'skip:s'              => \$CoSkip,
  'user:s'              => \$CoTargetUser,
  'tablespaces:s'       => \$CoTbsList,
  'tnsadmin:s'          => \$CoTnsAdmin,
  'trace'               => \$CoTrace,
  'type:s'              => \$CoOperType,
  'version'             => \$CoShowVersion
);

# If any invalid command line options then print usage.
# -------------------------------------------------------
if ($OptOutput != 1) {
   PrintUsage($Basename);
   exit 1;
}

# If run with -h option then print help screen.
# ------------------------------------------------
if ($CoHelp) {
   $Help = $CoHelp;
   PrintHelp();
   exit 0;
}

# If run with -parfile option
# ----------------------------
if ($CoParFile) {
   $ParFile = $CoParFile;
} else {
   undef $ParFile;
}

# If run with -script option
# ----------------------------
if ($CoExternalScript) {
   $ExternalScript = $CoExternalScript;
}

# If run with the -v option then print version info.
# -----------------------------------------------------
if ($CoShowVersion) {
   print '                                            do.                               ' . "\n";
   print '                                           :NOX                               ' . "\n";
   print '                                          ,NOM@:                              ' . "\n";
   print '                                          :NNNN:                              ' . "\n";
   print '                                          :XXXON                              ' . "\n";
   print '                                          :XoXXX.                             ' . "\n";
   print '                                          MM;ONO:                             ' . "\n";
   print '     .oob..                              :MMO;MOM                             ' . "\n";
   print '    dXOXYYNNb.                          ,NNMX:MXN                             ' . "\n";
   print '    Mo"\'  \'\':Nbb                        dNMMN MNN:                         ' . "\n";
   print '    Mo  \'O;; \':Mb.                     ,MXMNM MNX:                          ' . "\n";
   print '    @O :;XXMN..\'X@b.                  ,NXOMXM MNX:                           ' . "\n";
   print '    YX;;NMMMM@M;;OM@o.                dXOOMMN:MNX:                            ' . "\n";
   print '    \'MOONM@@@MMN:\':NONb.            ,dXONM@@MbMXX:                          ' . "\n";
   print '     MOON@M@@MMMM;;:OOONb          ,MX\'"\':ONMMMMX:                          ' . "\n";
   print '     :NOOM@@MNNN@@X;""XNN@Mb     .dP"\'   ,..OXM@N:                           ' . "\n";
   print '      MOON@@MMNXXMMO  :M@@M...@o.oN""":OOOXNNXXOo:                            ' . "\n";
   print '      :NOX@@@MNXXXMNo :MMMM@K"`,:;NNM@@NXM@MNO;.\'N.                          ' . "\n";
   print '       NO:X@@MNXXX@@O:\'X@@@@MOOOXMM@M@NXXN@M@NOO \'\'b                       ' . "\n";
   print '       `MO.\'NMNXXN@@N: \'XXM@NMMXXMM@M@XO"\'"XM@X;.  :b                      ' . "\n";
   print '        YNO;\'"NXXXX@M;;::"XMNN:""ON@@MO: ,;;.:Y@X: :OX.                      ' . "\n";
   print '         Y@Mb;;XNMM@@@NO: \':O: \'OXN@@MO" ONMMX:`XO; :X@.                    ' . "\n";
   print '         \'@XMX\':OX@@MN:    ;O;  :OX@MO" \'OMM@N; \':OO;N@N                  ' . "\n";
   print '          YN;":.:OXMX"\': ,:NNO;\';XMMX:  ,;@@MNN.\'.:O;:@X:                  ' . "\n";
   print '          `@N;;XOOOXO;;:O;:@MOO;:O:"" ,oMP@@K"YM.;NMO;`NM                     ' . "\n";
   print '           `@@MN@MOX@@MNMN;@@MNXXOO: ,d@NbMMP\'d@@OX@NO;.\'bb.                ' . "\n";
   print '          .odMX@@XOOM@M@@XO@MMMMMMNNbN"YNNNXoNMNMO"OXXNO.."";o.               ' . "\n";
   print '        .ddMNOO@@XOOM@@XOONMMM@@MNXXMMo;."\' .":OXO \':.\'"\'"\'  \'""o.      ' . "\n";
   print '       \'N@@X;,M@MXOOM@OOON@MM@MXOO:":ONMNXXOXX:OOO               ""ob.       ' . "\n";
   print '      \')@MP"\';@@XXOOMMOOM@MNNMOO""   \'"OXM@MM: :OO.        :...\';o;.;Xb.  ' . "\n";
   print '     .@@MX" ;X@@XXOOM@OOXXOO:o:\'      :OXMNO"\' ;OOO;.:     ,OXMOOXXXOOXMb   ' . "\n";
   print '    ,dMOo:  oO@@MNOON@N:::"      .    ,;O:""\'  .dMXXO:    ,;OX@XO"":ON@M@    ' . "\n";
   print '   :Y@MX:.  oO@M@NOXN@NO. ..: ,;;O;.       :.OX@@MOO;..   .OOMNMO.;XN@M@P     ' . "\n";
   print '   ,MP"OO\'  oO@M@O:ON@MO;;XO;:OXMNOO;.  ,.;.;OXXN@MNXO;.. oOX@NMMN@@@@@M:    ' . "\n";
   print '   `\' "O:;;OON@@MN::XNMOOMXOOOM@@MMNXO:;XXNNMNXXXN@MNXOOOOOXNM@NM@@@M@MP     ' . "\n";
   print '      :XN@MMM@M@M:  :\'OON@@XXNM@M@MXOOdN@@@MM@@@@MMNNXOOOXXNNN@@M@MMMM"\'    ' . "\n";
   print '      .oNM@MM@ONO\'   :;ON@@MM@MMNNXXXM@@@@M@PY@@MMNNNNNNNNNNNM@M@M@@P\'      ' . "\n";
   print '     ;O:OXM@MNOOO.   \'OXOONM@MNNMMXON@MM@@b. \'Y@@@@@@@@@@@@@M@@MP"\'"       ' . "\n";
   print '    ;O\':OOXNXOOXX:   :;NMO:":NMMMXOOX@MN@@@@b.:M@@@M@@@MMM@""""              ' . "\n";
   print '    :: ;"OOOOOO@N;:  \'ON@MO.\'":""OOOO@@NNMN@@@. Y@@@MMM@@@@b                ' . "\n";
   print '    :;   \':O:oX@@O;;  ;O@@XO\'   "oOOOOXMMNMNNN@MN""YMNMMM@@MMo.             ' . "\n";
   print '    :N:.   \'\'oOM@NMo.::OX@NOOo.  ;OOOXXNNNMMMNXNM@bd@MNNMMM@MM@bb           ' . "\n";
   print '     @;O .  ,OOO@@@MX;;ON@NOOO.. \' \':OXN@NNN@@@@@M@@@@MNXNMM@MMM@,          ' . "\n";
   print '     M@O;;  :O:OX@@M@NXXOM@NOO:;;:,;;ON@NNNMM\'`"@@M@@@@@MXNMMMMM@N           ' . "\n";
   print '     N@NOO;:oO;O:NMMM@M@OO@NOO;O;oOOXN@NNM@@\'   `Y@NM@@@@MMNNMM@MM           ' . "\n";
   print '     ::@MOO;oO:::OXNM@@MXOM@OOOOOOXNMMNNNMNP      ""MNNM@@@MMMM@MP            ' . "\n";
   print '       @@@XOOO\':::OOXXMNOO@@OOOOXNN@NNNNNNNN        \'`YMM@@@MMM@P\'         ' . "\n";
   print '       MM@@M:\'\'\'\' O:":ONOO@MNOOOOXM@NM@NNN@P            "`"""MM\'         ' . "\n";
   print '       \'\'MM@:     "\' \'OOONMOYOOOOO@MM@MNNM"                               ' . "\n";
   print '         YM@\'         :OOMN: :OOOO@MMNOXM\'                                  ' . "\n";
   print '         `:P           :oP\'\'  "\'OOM@NXNM\'                                 ' . "\n";
   print '          `\'                    \':OXNP\'                                    ' . "\n";
   print '                                  \'"\'                                       ' . "\n";
   printf "Dixie: Release $Version - Production, $ReleaseDate\n";
   exit 0;
}

# Running an external RMAN script
# --------------------------------------
if ( $ExternalScript ne '' ) {
   if (   ($ArchCopies)
       or ($ArchLogs          or $ArchLogs       eq 'true')
       or ($BackupDevice)
       or ($BackupDir)
       or ($BackupFormat)
       or ($CatSid)
       or ($CatUser)
       or ($Channels)
       or ($ComprLevel)
       or ($ComprOptim        or $ComprOptim     eq 'true')
       or ($Controlfile       or $Controlfile    eq 'true')
       or ($Copy              or $Copy           eq 'true')
       or ($Cumulative        or $Cumulative     eq 'true')
       or ($DeleteDelay)
       or ($DeleteLogs        or $DeleteLogs     eq 'true')
       or ($DeleteObsolete    or $DeleteObsolete eq 'true')
       or ($DistChan          or $DistChan       eq 'true')
       or ($FilesPerSet)
       or ($Force             or $Force          eq 'true')
       or ($Generate          or $Generate       eq 'true')
       or ($KeepDays)
       or ($KeepNoLogs        or $KeepNoLogs     eq 'true')
       or ($IncrLevel)
       or ($MaxDuration)
       or ($MaxOpenFiles)
       or ($MaxPieceSize)
       or ($MaxSetSize)
       or ($NoChecksum        or $NoChecksum     eq 'true')
       or ($NoExclude         or $NoExclude      eq 'true')
       or ($ParFile)
       or ($SbtLibrary)
       or ($SectionSize)
       or ($Skip)
       or ($StreamingRate)
       or ($TnsAdmin) ) {
      PrintError("Only -checksyntax, -debug, -nocatalog, -notify, -service, -sid, -show, -trace,\nand -user options are permitted when using -script option.");
      exit 1;
   }
   if (not (-r $ExternalScript and -T $ExternalScript)) {
      PrintError("External script file is not readable or is not plain text: $ExternalScript");
      exit 1;
   }
   ProcessOptions();                      # Process command line options.
} else {
   # Load Options from the Configuration file -- dixie default settings.
   # -----------------------------------------------------------------------
   $rc = LoadOptions($ConfigFile);
   if ($rc) {
      PrintError("Unable to open configuration file for read: $ConfigFile");
      exit($rc);
   }
   ProcessOptions();               # Process command line options.

   # Using a parfile...
   if ( $ParFile ne '' ) {
      # Note: When using a parfile, the parfile is loaded after the config file is loaded. This makes options in
      # the parfile override any conflicting options in the configuration file. The idea here is that the config
      # file carries the default settings for the system while the parfile allows you to override them. The command
      # line options take precedence over both parfile and config file options.
      # The order of precedence is as follows:
      #   1) Command-line --> 2) Parfile --> 3) Configfile
      # --------------------------------------------------------------------------------------------------------------

      # Load Options from the parameter file -- overrides configuration file options.
      # -------------------------------------------------------------------------------

      $rc = LoadOptions($ParFile);
      if ($rc) {
         PrintError("Unable to open parameter file for read: $ParFile");
         exit($rc);
      }
      ProcessOptions();               # Process command line options.
   }
   CheckFeatureCompatibility();    # Check for incompatibilities between selected options.
}

# Validate $ORACLE_SID and setup Oracle environment.
# -----------------------------------------------------
$rc = SetOracleEnv($TargetSid);
if ($rc != 0) {
   PrintError("Configuration of Oracle environment failed.");
   exit 1;
}

# Set the log file names.
# --------------------------
if ($ExternalScript ne '') {
   $DixieLog   = $ENV{DIXIE_LOG} . '/' . $CmdName . '_' . $TargetSid . '_EXTERNAL_SCRIPT_' . ShowDate(SHORT_DATE_TIME) . '.log';
} else {
   if (($OperType eq 'report_unrecoverable') or ($OperType eq 'resync'  ) or ($OperType eq 'report_schema') or ($OperType eq 'report_need_backup'  ) or ($OperType eq 'register')) {
      $DixieLog   = $ENV{DIXIE_LOG} . '/' . $CmdName . '_' . $TargetSid . '_'  . uc($OperType) . '_' . ShowDate(SHORT_DATE_TIME) . '.log';
   } else {
      $DixieLog   = $ENV{DIXIE_LOG} . '/' . $CmdName . '_' . $TargetSid . '_' . uc($OperType) . '_' . $BackupDevice . '_' . ShowDate(SHORT_DATE_TIME) . '.log';
   }
}

print "TRACE: DixieLog = $DixieLog\n" if ($Trace eq 'true');

# Delete any old logfile if found...
# --------------------------------------
unlink $DixieLog                      if (-f $DixieLog);

# Open a Tee pipe to redirect stdout to the logfile
# as well as the terminal.
# --------------------------------------------------
open(FILE, ">", $DixieLog);
open REAL_STDOUT,">&STDOUT";
tie *STDOUT, 'Multiple', \*REAL_STDOUT,\*FILE;

if ($Trace eq 'true') {
   print "TRACE: Directory: DIXIE_ETC     = $ENV{DIXIE_ETC}\n";
   print "TRACE: Directory: DIXIE_LOG     = $ENV{DIXIE_LOG}\n";
   print "TRACE: Directory: DIXIE_TMP     = $ENV{DIXIE_TMP}\n";
   print "TRACE: Directory: DIXIE_SCRIPTS = $ENV{DIXIE_SCRIPTS}\n";
}

# Set the long description of the RMAN operation.
# --------------------------------------------------
if ($ExternalScript ne '') {
   $cmdDesc = "Run an external RMAN script";
} else {
   if ($OperType eq 'database') {
      if ($IncrLevel eq 'full') {
         $cmdDesc  = "Full online database backup.";
         $cmdDesc .= " copy" if ($Copy eq 'true');
      } else {
         $cmdDesc  = "Incremental online database backup.";
         $cmdDesc .= " copy" if ($Copy eq 'true');
      }
   } elsif ($OperType eq 'datafile') {
      if ($IncrLevel eq 'full') {
         $cmdDesc  = "Datafile backup.";
         $cmdDesc .= " copy" if ($Copy eq 'true');
      } else {
         $cmdDesc  = "Incremental datafile backup.";
         $cmdDesc .= " copy" if ($Copy eq 'true');
      }
   } elsif ($OperType eq 'tablespace') {
      if ($IncrLevel eq 'full') {
         $cmdDesc  = "Tablespace backup.";
         $cmdDesc .= " copy" if ($Copy eq 'true');
      } else {
         $cmdDesc  = "Incremental tablespace backup.";
         $cmdDesc .= " copy" if ($Copy eq 'true');
      }
   } elsif ($OperType eq 'crosscheck') {
      $cmdDesc = "Verify backups in recovery catalog exist on backup media.";
   } elsif ($OperType eq 'fra') {
      $cmdDesc = "Backup the Flash Recovery Area.";
      undef $MaxSetSize;
   } elsif ($OperType eq 'arch') {
      $cmdDesc = "Backup archived redolog files.";
   } elsif ($OperType eq 'resync') {
      $cmdDesc = "Resyncronize with the RMAN catalog.";
   } elsif ($OperType eq 'register') {
      $cmdDesc = "Register the target database with the RMAN catalog.";
   } elsif ($OperType eq 'delete_expired') {
      $cmdDesc = "Crosscheck and delete expired backup sets.";
   } elsif ($OperType eq 'delete_obsolete') {
      $cmdDesc = "Delete obsolete backup sets.";
      $DeleteObsolete = 'true';
   } elsif ($OperType eq 'validate_backup') {
      $cmdDesc = "Dry-run backup to verify physical database integrity.";
   } elsif ($OperType eq 'validate_restore') {
      $cmdDesc = "Dry-run restore to verify the integrity of most recent backup.";
   } elsif ($OperType eq 'report_schema') {
      $cmdDesc = "Database Schema Report.";
   } elsif ($OperType eq 'report_need_backup') {
      $cmdDesc = "Report datafiles in need of a fresh backup.";
   } elsif ($OperType eq 'report_unrecoverable') {
      $cmdDesc  = "Report files in which unrecoverable transactions have occured.";
   } elsif ($OperType eq 'report_obsolete') {
      $cmdDesc = "Report backupsets no longer needed per retention policy.";
   } elsif ($OperType eq 'list_expired') {
      $cmdDesc = "Report backupsets that cannot be found on backup media.";
   }
}

# $MainRC should still be at its initialized value of 0.
# --------------------------------------------------------
if ($MainRC == 0) {
   # Collect information about the state of the instance and database.
   # ------------------------------------------------------------------

   # Check State of Database
   # ----------------------------
   ($tmpRC, $DbState) = GetInstState($SysConnStr);

   # If the database is mounted or open then collect info from v$database.
   # -----------------------------------------------------------------------
   if ($DbState eq MOUNTED or $DbState eq OPEN) {
      ($tmpRC, @DbInfo) = GetDbInfo($SysConnStr);
      $MainRC = $MainRC + $tmpRC;
      if ($tmpRC == 0) {
         $DbName              = @DbInfo[0];
         $DbUniqueName        = @DbInfo[1];
         $DbId                = @DbInfo[2];
         $DbOpenMode          = @DbInfo[3];
         $PrimaryDbUniqueName = @DbInfo[4];
         $DbRole              = @DbInfo[5];
         $DbSwitchoverStatus  = @DbInfo[6];
         $DbRecoveryDest      = @DbInfo[7];
         $DbRecoveryDestSize  = @DbInfo[8];
         $ClusterDatabase     = @DbInfo[9];
      }
   }

   # If it is a RAC database then how many active instances?
   # ----------------------------------------------------------
   if ($DbState eq 'DOWN') {
      $InstCount = 0;
   } else {
      if ($ClusterDatabase eq 'true') {
         ($tmpRC, $InstCount) = CountInstances($SysConnStr);
         $MainRC = $MainRC + $tmpRC;
      } else {
         $InstCount = 1;
      }
   }

   # If we're using a service name to connect to the database then
   # the # of active instances is the count of instances advertising
   # the service name.
   # -------------------------------------------------------------------
   if ($TargetService ne '') {
      ($tmpRC, $InstSvcCount) = GetInstSvcCount($SysConnStr,$TargetService);
      $MainRC += $tmpRC;

      if ($InstSvcCount == 0) {
         PrintError("No active instances found for service name: $TargetService. Terminating backup.");
         exit 1;
      }
      if ($InstSvcCount < $InstCount) {
         PrintWarning("Service is not active on all database instances: $TargetService. Active service names\nfound: $InstSvcCount.");
      }
   }

   # Get the version of the database
   # ---------------------------------
   if ($DbState eq 'DOWN') {
      # If I can't get the version from the database itself, then I'll use the SQL*Plus version.
      # -------------------------------------------------------------------------------------------
      $TargetVer = $BinVersion;
   } else {
      (my $tmpRC, $TargetVer) = GetDbVersion($SysConnStr);
      print "TRACE: GetDbVersion($SysConnStr) returned: $tmpRC\n" if ($Trace eq 'true');
      if ($tmpRC) {
         if ($BinVersion) {
            print "   -Cannot determine database version. Will use SQL*Plus version.\n";
            $TargetVer = $BinVersion
         } else {
            $TargetVer = 'unknown';
            $MainRC = $MainRC + $tmpRC;
         }
      } else {
         if ($TargetVer ne $BinVersion) {
            $VersionError  = "Warning: Version of Oracle binaries does not match version of database.\n";
            $VersionError .= "   BinVersion=$BinVersion\n";
            $VersionError .= "   TargetVer=$TargetVer";
            PrintWarning($VersionError);
         }
      }
   }

   # Print the banner.
   # -------------------
   printf "\n=========================================================================================\n";
   printf "RMAN Backup Utility for Oracle Databases       %42s\n", ShowDate('LONG_DATE_TIME');
   printf "=========================================================================================\n";
   printf " Program Info %75s\n";
   printf "  Command, version                   : %s, v%s\n", $Basename, $Version;
   printf "  Log File                           : %-s\n", basename($DixieLog);
   printf "  Host                               : %s\n", $HostName;
   printf "  Oracle SID                         : %s\n", $TargetSid            if ($TargetSid           ne '');
   printf "  Process ID                         : %s\n", $Pid;
   printf "\n";
   printf " Runtime Settings\n";
   printf "  Description                        : %s\n", $cmdDesc;
   printf "  Backup Archlogs                    : %s\n", $ArchLogs             if ($ArchLogs            ne '');
   printf "  Backup Archlogs n times            : %s\n", $ArchCopies           if ($ArchCopies          ne '');
   printf "  Backup Controlfile                 : %s\n", $Controlfile          if ($Controlfile         ne '');
   printf "  Backup Device                      : %s\n", lc($BackupDevice)     if ($BackupDevice        ne '');
   printf "  Backup Type/Operation              : %s\n", $OperType             if ($OperType            ne '');
   printf "  Backup as Copy                     : %s\n", $Copy                 if ($Copy                eq 'true');
   printf "  Connect String (target)            : %s\n", $SysConnStr           if ($SysConnStr          ne '');
   printf "  Connect String (service name)      : %s\n", $PrintServiceConnStr  if ($PrintServiceConnStr ne '');
   printf "  Connect String (catalog)           : %s\n", $PrintCatConnStr      if ($PrintCatConnStr     ne '');
   printf "  Channels per Instance              : %s\n", $Channels             if ($Channels            ne '');
   if ($ComprLevel eq '') {
      printf "  Compression                        : off\n";
   } else {
      printf "  Compression                        : %s\n", lc($ComprLevel);
      printf "  Compression Optimized for Load     : %s\n", lc($ComprOptim)    if ($ComprOptim          ne '');
   }
   printf "  Configure RMAN                     : %s\n", $ConfigureRman        if ($ConfigureRman       ne '');
   printf "  Connect String                     : %s\n", $PrintTargetConnStr   if ($$PrintTargetConnStr ne '');
   if ($Cumulative eq 'true') {
      printf "  Incremental Type                   : %s\n", 'Cumulative';
   } elsif ($Cumulative eq 'false') {
      printf "  Incremental Type                   : %s\n", 'Differential';
   }
   printf "  Database File List                 : %s\n", $DbfList              if ($DbfList             ne '');
   printf "  Debug RMAN                         : %s\n", $Debug                if ($Debug               ne '');
   printf "  Delay Delete Archlogs n days       : %s\n", $DeleteDelay          if ($DeleteDelay         ne '');
   printf "  Delete Archlogs                    : %s\n", $DeleteLogs           if ($DeleteLogs          ne '');
   printf "  Delete Obsolete                    : %s\n", $DeleteObsolete       if ($DeleteObsolete      ne '');
   printf "  Distributed Channels               : %s\n", $DistChan             if ($DistChan            ne '');
   printf "  Email Distribution List            : %s\n", $DistList             if ($DistList            ne '');
   printf "  Enternal Rman Script               : %s\n", $ExternalScript       if ($ExternalScript      ne '');
   printf "  Files Per Set                      : %s\n", $FilesPerSet          if ($FilesPerSet         ne '');
   printf "  Force                              : %s\n", $Force                if ($Force               ne '');
   if (($BackupFormat eq '') and ($BackupDir eq '') and
       ($OperType eq 'database' or $OperType eq 'datafile' or $OperType eq 'tablespace' or $OperType eq 'arch')) {
      printf "  Format                             : <Fast Recovery Area>\n";
   } elsif ($BackupFormat) {
      printf "  Format                             : %s\n",  join(",\n                                      ", split(',', $BackupFormat));
   }
   printf "  Generate Only                      : %s\n", $Generate             if ($Generate            ne '');
   if ($KeepDays) {
      if ($KeepNoLogs eq 'true') {
         printf "  Keep Days                          : %s, don't keep logs\n", $KeepDays;
      } else {
         printf "  Keep Days                          : %s, keep logs\n", $KeepDays;
      }
   }
   if ($IncrLevel ne '') {
      printf "  Level                              : %s", $IncrLevel;
      if ($IncrLevel == 1) {
         if ($Cumulative eq 'true') {
            print ", cumulative\n";
         } else {
            print ", differential\n";
         }
      } else {
         print "\n";
      }
   }
   printf "  Max Duration                       : %s\n", $MaxDuration          if ($MaxDuration         ne '');
   printf "  Max Open Files                     : %s\n", $MaxOpenFiles         if ($MaxOpenFiles        ne '');
   printf "  Max Piece Size                     : %s\n", $MaxPieceSize         if ($MaxPieceSize        ne '');
   printf "  Max Set Size                       : %s\n", $MaxSetSize           if ($MaxSetSize          ne '');
   printf "  No Checksum                        : %s\n", $NoChecksum           if ($NoChecksum          ne '');
   printf "  No Exclude                         : %s\n", $NoExclude            if ($NoExclude           ne '');
   if ($Notify eq 'success') {
      printf "  Notify                             : Always\n";
   } elsif ($Notify eq 'fail') {
      printf "  Notify                             : Failures only\n";
   } elsif ($Notify eq 'off') {
      printf "  Notify                             : Never\n";
   }
   printf "  Parameter file                     : %s\n", $ParFile              if ($ParFile             ne '');
   printf "  Plus Archlogs                      : %s\n", $PlusArchlogs         if ($PlusArchlogs        ne '');
   printf "  Retention                          : %s\n", $Retention            if ($Retention           ne '');
   printf "  Section Size                       : %s\n", $SectionSize          if ($SectionSize         ne '');
   printf "  Show Only                          : %s\n", $Show                 if ($Show                ne '');
   $tmpSkip = join(', ', @Skip);
   printf "  Skip                               : %s\n", $tmpSkip              if ($tmpSkip             ne '');
   printf "  Streaming Rate                     : %s\n", $StreamingRate        if ($StreamingRate       ne '');
   printf "  Target User                        : %s\n", $TargetUser           if ($TargetUser          ne '');
   printf "  Target Service Name                : %s\n", $TargetService        if ($TargetService       ne '');
   printf "  Tablespace List                    : %s\n", $TbsList              if ($TbsList             ne '');
   printf "\n";

   # Don't need this stuff if only showing or generating rman code.
   # ----------------------------------------------------------------
   if (    $OperType ne 'resync'
       and $OperType ne 'register'
       and $OperType ne 'list_expired'
       and $OperType ne 'report_schema'
       and $OperType ne 'report_need_backup'
       and $OperType ne 'report_unrecoverable'
       and $OperType ne 'report_obsolete' ) {
      printf " Begin\n";
   }
   if (($Show eq 'false') and ($Generate eq 'false')) {
      print "   -ORACLE_SID....................... [" . $ENV{ORACLE_SID} . "]\n"         if ($ENV{ORACLE_SID}           ne '');
      print "   -ORACLE_HOME...................... [" . $ENV{ORACLE_HOME} . "]\n"        if ($ENV{ORACLE_HOME}          ne '');
      print "   -TNS_ADMIN........................ [" . $ENV{TNS_ADMIN} . "]\n"          if ($ENV{TNS_ADMIN}            ne '');
      print "   -LD_LIBRARY_PATH.................. [" . $ENV{LD_LIBRARY_PATH} . "]\n"    if (($ENV{LD_LIBRARY_PATH}     ne '') and ($Trace));
      print "   -ORA_NLS10........................ [" . $ENV{ORA_NLS10} . "]\n"          if (($ENV{ORA_NLS10}           ne '') and ($Trace));
      print "   -Instance State................... [$DbState]\n";
      print "   -Database Name.................... [$DbName]\n";
      print "   -Database Unique Name............. [$DbUniqueName]\n";
      print "   -Database Version................. [$TargetVer]\n";
      print "   -Cluster Database................. [$ClusterDatabase]\n";
      print "   -Active Instances................. [$InstCount]\n";
      print "   -Active Service Instances......... [$InstSvcCount]\n"                    if ($TargetService ne '');
      print "   -Database Role.................... [$DbRole]\n";
      print "   -Database Mode.................... [$DbOpenMode]\n";
      print "   -Switchover Status................ [$DbSwitchoverStatus]\n";
      print "   -Primary Database Unique Name..... [$PrimaryDbUniqueName]\n"             if ($PrimaryDbUniqueName ne '');
      print "   -Recovery Dest.................... [$DbRecoveryDest]\n";
      print "   -Recovery Size.................... [$DbRecoveryDestSize]\n";
   }

   if (($DbState eq 'DOWN' or $DbState eq 'STARTED') and ($Show ne 'true' and $Generate ne 'true')) {
      PrintError("Database must be mounted or open for RMAN to execute backup.");
      exit $MainRC;
   }

   # Set the backup directory & format if device is DISK (and not using FRA)
   # or SBT (and using oracle.disksbt).
   # ------------------------------------------------------------------------
   if ($ExternalScript eq '') {
      # Set Channel multiplier using active instance count.
      # -----------------------------------------------------
      if (($DistChan eq 'true') and ($InstCount > 0)) {
         $Channels = $Channels * $InstSvcCount;
      }
      if ($Channels ne '0') {
         print "   -Total Backup Channels............ [$Channels]\n";
      }

      # Set the backup directory location.
      # ------------------------------------
      if ($BackupFormat ne '') {
         $BackupFormat =~ s/\[DBNAME\]/$DbUniqueName/;
         if ($BackupDevice eq 'DISK') {
            print "   -Backup Directory................." if ($BackupDir);
            if ($DbUniqueName) {
               $BackupDir =~ s/\[DBNAME\]/$DbUniqueName/;
            } else {
               $BackupDir =~ s/\[DBNAME\]/$TargetSid/;
            }
            print " [$BackupDir]\n" if ($BackupDir);
            printf "   -Channel Format................... [%s]\n", $BackupFormat;

            # Create the backup directory if necessary.
            # -------------------------------------------
            if ((defined $BackupDir) and (not -d $BackupDir)) {
               if (($Show ne 'true') and ($Generate ne 'true')) {
                  PrintWarning("Backup directory not found. Creating new backup directory.");
                  eval { mkpath $BackupDir };
                  if ($@) {
                     PrintError("Cannot create backup directory: $BackupDir");
                     $MainRC ++;
                  }
               }
            }
         } else {
            printf "   -Channel Format................... [%s]\n", join(",\n                                      ", split(',', $BackupFormat));

            if ($SbtLibrary eq 'oracle.disksbt') {
                 if ($BackupDir eq '') {
                  PrintError("Backup directory not defined. Backup directory must be set when using the\noracle.disksbt backup device driver.");
                  $MainRC ++;
               } else {
                  # Create a target directory for SBT backup if it uses the oracle.disksbt.
                  # -------------------------------------------------------------------------
                  if ($BackupFormat =~ m/.*\=.*\(.*BACKUP_DIR.*=(.*)\)/s) {
                     $SbtDir = $1;
                     print "   -SBT Backup Directory............. [$SbtDir]\n";
                     if (defined $SbtDir) {
                        if ((not -d $SbtDir) and (($Show ne 'true') or ($Generate ne 'true'))) {
                           print "   -Creating new backup directory for oracle.disksbt device.\n";
                           eval { mkpath $SbtDir };
                           if ($@) {
                              PrintError("Cannot create target directory for oracle.disksbt device: $SbtDir");
                              $MainRC ++;
                           }
                        }
                     } else {
                        PrintError("Malformed \'BACKUP_DIR=\' string for oracle.disksbt device.");
                        printError("BACKUP_DIR string should look something like: \"BACKUP_DIR=/oradba/RMAN_DB_BACKUPS/MYDB\)\')");
                        $MainRC ++;
                     }
                  }
               }
            }
         }
      }
   }

   # If this is an external script (-script option) ...
   if ($ExternalScript ne '') {
      if ($MainRC == 0) {
         if ($Show eq 'true') {
            # Print the External Script to the screen.
            # -------------------------------------------
            open(EXTERNAL_SCRIPT, "<", $ExternalScript) or die "Can't open EXTERNAL_SCRIPT for read: $ExternalScript\n";
            print "\n-----cut--------cut--------cut--------cut--------cut--------cut--------cut--------cut----\n";
            while (<EXTERNAL_SCRIPT>) {
               print;
            }
            print "-----cut--------cut--------cut--------cut--------cut--------cut--------cut--------cut----\n";
         } else {
            CheckInstState();                                # Check the current state of the database

            $RmanLog = basename($DixieLog);
            $RmanLog =~ s/^dixie/rman/;
            $RmanLog = $ENV{DIXIE_LOG} . '/' . $RmanLog;

            print "TRACE: \$RmanLog = $RmanLog\n" if ($Trace eq 'true');

            unlink $RmanLog if (-f $RmanLog);

            print "   -Rman Log......................... [" . basename($RmanLog) . "]\n";
            print "   -Rman Script...................... [" . basename($ExternalScript) . "]\n";

            if ($MainRC == 0) {
               # Run the RMAN Script.
               # --------------------------
               print "   -Executing external RMAN script\n";
               $tmpRC = RunRmanScript($ExternalScript);
               $MainRC = $MainRC + $tmpRC;

               print "   -Rman Operation Complete\n";
               print "   ------B-E-G-I-N---R-E-C-O-V-E-R-Y---M-A-N-A-G-E-R---L-O-G-----------------------------\n";
               ImportRmanLog($RmanLog);
               print "   ----------E-N-D---R-E-C-O-V-E-R-Y---M-A-N-A-G-E-R---L-O-G-----------------------------\n";
            }
            # Cleanup -- remove the RMAN log and RMAN script
            # ------------------------------------------------
            unlink $RmanLog;
         }
      }
   } else { # If this is *not* an external script ...
      if ($TargetVer < 11) {
         PrintError("Error: At this time Dixie supports Oracle RDBMS version 11+ only.");
         exit 1;
      }
      # Create the RMAN run{} block.
      # ---------------------------------
      if ($MainRC == 0) {
         $RunBlock = '';

         # Generate the main run block.
         # -------------------------------
         if (($OperType eq 'database') or
             ($OperType eq 'datafile') or
             ($OperType eq 'tablespace')) {               # Backup the database, a list of datafiles or a list of tablespaces.
            DbBackup11g($DbState);
         } elsif ($OperType eq 'fra') {                   # Backup the Recovery Area.
            FraBackup11g();
         } elsif ($OperType eq 'arch') {                  # Backup the archived redologs
            ArchBackup11g($DbState);
         } elsif ($OperType eq 'resync') {                # Resync with the catalog only.
            Resync();
         } elsif ($OperType eq 'validate_backup') {       # Doing a backup check logical validate.
            ValidateBackup();
         } elsif ($OperType eq 'validate_restore') {      # Doing a restore database validate check logical.
            ValidateRestore();
         } elsif ($OperType eq 'crosscheck') {            # Doing a crosscheck of backups.
            Crosscheck();
         } elsif ($OperType eq 'delete_expired') {        # Doing a delete expired.
            DeleteExpired();
         } elsif ($OperType eq 'delete_obsolete') {       # Doing a delete obsolete.
            DeleteObsolete();
         } elsif ($OperType eq 'register') {              # Register database with Catalog.
            Register();
         } elsif ($OperType eq 'report_schema') {         # Generate a schema report
            ReportSchema();
         } elsif ($OperType eq 'report_need_backup') {    # Generate a report of files in need of new backup.
            ReportNeedBackup();
         } elsif ($OperType eq 'report_unrecoverable') {  # Generate a report of unrecoverable datafiles.
            ReportUnrecoverable();
         } elsif ($OperType eq 'report_obsolete') {       # Generate a report of obsolete backups
            ReportObsolete();
         } elsif ($OperType eq 'list_expired') {          # Generate a report of expired backups
            ListExpired();
         }

         if ($ConfigureRman eq 'true') {
            my $ConfigRman = '';
            $ConfigRman .= "#----------------------------------------------------------\n";
            $ConfigRman .= "# Begin Configure RMAN commands.\n";
            $ConfigRman .= "#----------------------------------------------------------\n";

            # For Primary databases only.
            # ----------------------------
            if ($DbRole eq 'PRIMARY') {
               if ($Retention) {
                 $ConfigRman .= "CONFIGURE RETENTION POLICY TO " . $Retention . ";\n";
               }

               if ($ComprLevel ne '') {
                  $ConfigRman .= "CONFIGURE COMPRESSION ALGORITHM \'$ComprLevel\' AS OF RELEASE 'DEFAULT'";
                  if ($ComprOptim eq 'true') {
                     $ConfigRman .= " OPTIMIZE FOR LOAD TRUE;\n";
                  } else {
                     $ConfigRman .= " OPTIMIZE FOR LOAD FALSE;\n";
                  }
               }
            }

            # For data guard standby databases only.
            # ----------------------------------------
            if ($DbRole ne 'PRIMARY') {
               $ConfigRman .= "CONFIGURE ARCHIVELOG DELETION POLICY TO APPLIED ON STANDBY;\n";
            }
            # End Configure Rman Processing.

            # For Primary and Standby Databases.
            # -------------------------------------
            # Note that the IDENTIFIER does not include a username and password. It contains only the
            # Oracle Net service name that can be used from any database site to connect to the database.
            # After connect identifiers are configured for all standby databases, you can verify the list of
            # standbys by using the command, "LIST DB_UNIQUE_NAME OF DATABASE;".
            # --
            # Note: Reset the db_unique_name using the configure command: configure db_unique_name {name} clear;
            # ---------------------------------------------------------------------------------------------------
            if ($DbUniqueName eq '' and $DbRecoveryDest ne '' and $TargetService ne '') {
               $ConfigRman .= "#CONFIGURE DB_UNIQUE_NAME '[DB_UNIQUE_NAME]' CONNECT IDENTIFIER '" . $TargetService . "';\n";
            } else {
               $ConfigRman .= "CONFIGURE DB_UNIQUE_NAME '" . $DbUniqueName . "' CONNECT IDENTIFIER '" . $TargetService . "';\n";
            }
            if ($ComprLevel ne '') {
               $ConfigRman .= "CONFIGURE DEVICE TYPE DISK BACKUP TYPE TO COMPRESSED BACKUPSET;\n";
               $ConfigRman .= "CONFIGURE DEVICE TYPE SBT  BACKUP TYPE TO COMPRESSED BACKUPSET;\n";
            }

            $ConfigRman .= "CONFIGURE BACKUP OPTIMIZATION ON;\n";

            # Configure default Channel Parallelism
            # ---------------------------------------
            my $ConfigDiskChannels = 1;   # default
            my $ConfigSbtChannels  = 1;   # default

            # Disk device parallelism.
            # --------------------------
            if ($cfgHash{DISK_CHANNELS} ne '') {
               $ConfigDiskChannels = $cfgHash{DISK_CHANNELS};
            } else {
               if ($BackupDevice eq 'DISK') {
                  if ($DistChan eq 'true') {
                     $ConfigDiskChannels = $Channels / $InstCount;
                  } else {
                     $ConfigDiskChannels = $Channels;
                  }
               }
            }

            # Tape device parallelism.
            # --------------------------
            if ($cfgHash{SBT_CHANNELS} ne '') {
               $ConfigSbtChannels = $cfgHash{SBT_CHANNELS};
            } else {
               if ($BackupDevice eq 'SBT') {
                  if ($DistChan eq 'true') {
                     $ConfigSbtChannels = $Channels / $InstCount;
                  } else {
                     $ConfigSbtChannels = $Channels;
                  }
               }
            }
            $ConfigRman .= "CONFIGURE DEVICE TYPE DISK PARALLELISM "     . $ConfigDiskChannels . " BACKUP TYPE TO BACKUPSET;\n";
            $ConfigRman .= "CONFIGURE DEVICE TYPE SBT_TAPE PARALLELISM " . $ConfigSbtChannels  . " BACKUP TYPE TO BACKUPSET;\n";
            $ConfigRman .= "CONFIGURE CHANNEL DEVICE TYPE SBT_TAPE FORMAT " . $BackupFormat .  ";\n";

            # This allows for an example to be printed even if DbUniqueName
            # and DbRecoveryDest are not known.
            # ---------------------------------------------------------------
            if ($DbUniqueName eq '' and $DbRecoveryDest ne '') {
               $ConfigRman .= "#CONFIGURE CONTROLFILE AUTOBACKUP FORMAT FOR DEVICE TYPE DISK TO '[DB_RECOVERY_FILE_DEST]/[DB_UNIQUE_NAME]/%F';\n";
               $ConfigRman .= "#CONFIGURE SNAPSHOT CONTROLFILE NAME TO '[DB_RECOVERY_FILE_DEST]/[DB_UNIQUE_NAME]/'snapcf_[DB_UNIQUE_NAME].f';\n";
            } else {
               $ConfigRman .= "CONFIGURE CONTROLFILE AUTOBACKUP FORMAT FOR DEVICE TYPE DISK TO '" . $DbRecoveryDest . "/" . $DbUniqueName . "/%F'" . ";\n";
               $ConfigRman .= "CONFIGURE SNAPSHOT CONTROLFILE NAME TO '" . $DbRecoveryDest . "/" . $DbUniqueName . "/" . 'snapcf_' . $DbUniqueName . ".f'" . ";\n";
            }

            $ConfigRman .= "#----------------------------------------------------------\n";
            $ConfigRman .= "# End Configure RMAN commands.\n";
            $ConfigRman .= "#----------------------------------------------------------\n\n";

            if ($DbState ne 'MOUNTED' and $DbState ne 'OPEN') {
               PrintWarning("The database must be MOUNTED or OPEN in order to make configuration changes.\nConfigure RMAN will be skipped.");
            } else {
               # Prepend the Config commands to the beginning of the RMAN run{} block.
               if ($ConfigRman ne '') {
                  $RunBlock = $ConfigRman . $RunBlock;
               }
            }
         }
      }

      # Finished with all the prep work. Now lets get on with it.
      # -----------------------------------------------------------
      if (($Show eq 'true') or ($Generate eq 'true')) {
         if ($Show eq 'true') {
            if ($RunBlock eq '') {
               PrintError("No run block generated. Check output above for errors.");
               $MainRC ++;
            } else {
               print "\n-----cut--------cut--------cut--------cut--------cut--------cut--------cut--------cut----\n";
               print "$RunBlock";
               print "-----cut--------cut--------cut--------cut--------cut--------cut--------cut--------cut----\n";
            }
         }
         if ($Generate eq'true') {
            # Generate an RMAN script using the contents of $RunBlock.
            # ----------------------------------------------------------
            GenerateScript($TargetSid, $RunBlock, $TargetConnStr, $CatalogConnStr);
         }
      } else {
         # Generate an RMAN script using the contents of $RunBlock.
         # ----------------------------------------------------------
         GenerateScript($TargetSid, $RunBlock, $TargetConnStr, $CatalogConnStr);

         if ($MainRC == 0) {
            if (($DbState ne 'MOUNTED') and ($DbState ne 'OPEN')) {
               print "   -Cannot perform RMAN operation while database is $DbState\n";
               $MainRC ++;
            } else {
               if ($ServiceConnStr ne '') {
                  # Check tns service name resolution
                  # -----------------------------------
                  (my $TsnHost, my $TnsPort, my $TnsName) = Tnsping($TargetService);
                  print "   -Tnsping Service Name............. [HOST=" . $TsnHost . ", PORT=" . $TnsPort . ", SERVICE_NAME=" . $TnsName . "]\n";

                  if ($DbState eq MOUNTED or $DbState eq OPEN) {
                     ($tmpRC, @tmpDbInfo) = GetDbInfo($ServiceConnStr);
                     if ($tmpRC) {
                        exit $tmpRC;
                     }
                     $MainRC = $MainRC + $tmpRC;
                     if ($tmpRC == 0) {
                        $tmpDbName              = @tmpDbInfo[0];
                        $tmpDbUniqueName        = @tmpDbInfo[1];
                        $tmpDbId                = @tmpDbInfo[2];
                        $tmpDbOpenMode          = @tmpDbInfo[3];
                        $tmpPrimaryDbUniqueName = @tmpDbInfo[4];
                        $tmpDbRole              = @tmpDbInfo[5];
                        $tmpDbSwitchoverStatus  = @tmpDbInfo[6];
                        $tmpDbRecoveryDest      = @tmpDbInfo[7];
                        $tmpDbRecoveryDestSize  = @tmpDbInfo[8];
                        $tmpClusterDatabase     = @tmpDbInfo[9];
                     }
                  }

                  my $tmpMatch = 1;
                  $tmpMatch = 0 if (@DbInfo[0] ne @tmpDbInfo[0]);
                  $tmpMatch = 0 if (@DbInfo[1] ne @tmpDbInfo[1]);
                  $tmpMatch = 0 if (@DbInfo[2] ne @tmpDbInfo[2]);
                  $tmpMatch = 0 if (@DbInfo[3] ne @tmpDbInfo[3]);
                  $tmpMatch = 0 if (@DbInfo[4] ne @tmpDbInfo[4]);
                  $tmpMatch = 0 if (@DbInfo[5] ne @tmpDbInfo[5]);
                  $tmpMatch = 0 if (@DbInfo[6] ne @tmpDbInfo[6]);
                  $tmpMatch = 0 if (@DbInfo[7] ne @tmpDbInfo[7]);
                  $tmpMatch = 0 if (@DbInfo[8] ne @tmpDbInfo[8]);
                  $tmpMatch = 0 if (@DbInfo[9] ne @tmpDbInfo[9]);
                  if (not $tmpMatch) {
                     $tmpMsg  = "Service Name: $TargetService does not connect to the same database as \$ORACLE_SID: $TargetSid\n\n";
                     $tmpMsg .= sprintf("%-23s %-20s %-20s\n", 'Description', $TargetSid, $TargetService);
                     $tmpMsg .= sprintf("%-23s %-20s %-20s\n", '----------------------', '-------------------', '-----------------------');
                     $tmpMsg .= sprintf("%-23s %-20s %-20s\n", 'Db Name'                , $DbName              , $tmpDbName              );
                     $tmpMsg .= sprintf("%-23s %-20s %-20s\n", 'Db Unique Name'         , $DbUniqueName        , $tmpDbUniqueName        );
                     $tmpMsg .= sprintf("%-23s %-20s %-20s\n", 'Db ID'                  , $DbId                , $tmpDbId                );
                     $tmpMsg .= sprintf("%-23s %-20s %-20s\n", 'Db Open Mode'           , $DbOpenMode          , $tmpDbOpenMode          );
                     $tmpMsg .= sprintf("%-23s %-20s %-20s\n", 'Primary Db Unique Name' , $PrimaryDbUniqueName , $tmpPrimaryDbUniqueName );
                     $tmpMsg .= sprintf("%-23s %-20s %-20s\n", 'Db Role'                , $DbRole              , $tmpDbRole              );
                     $tmpMsg .= sprintf("%-23s %-20s %-20s\n", 'Db Switchover Status'   , $DbSwitchoverStatus  , $tmpDbSwitchoverStatus  );
                     $tmpMsg .= sprintf("%-23s %-20s %-20s\n", 'Db Recovery Dest'       , $DbRecoveryDest      , $tmpDbRecoveryDest      );
                     $tmpMsg .= sprintf("%-23s %-20s %-20s\n", 'Db Recovery Dest Size'  , $DbRecoveryDestSize  , $tmpDbRecoveryDestSize  );
                     $tmpMsg .= sprintf("%-23s %-20s %-20s\n", 'Cluster Database'       , $ClusterDatabase     , $tmpClusterDatabase     );
                     PrintError($tmpMsg);
                     exit 1;
                  }
               }
               $RmanLog = basename($DixieLog);
               $RmanLog =~ s/^dixie/rman/;
               $RmanLog = $ENV{DIXIE_LOG} . '/' . $RmanLog;

               print "TRACE: \$RmanLog = $RmanLog\n" if ($Trace eq 'true');

               unlink $RmanLog if (-f $RmanLog);

               print "   -Rman Log......................... [" . basename($RmanLog) . "]\n";

               if ($MainRC == 0) {
                  # Run the RMAN Script.
                  # --------------------------
                  print "   -Executing RMAN script\n";
                  $tmpRC = RunRmanScript($RmanScript);
                  $MainRC += $tmpRC;
                  print "   -Rman Operation Complete\n";
                  print "   ------B-E-G-I-N---R-E-C-O-V-E-R-Y---M-A-N-A-G-E-R---L-O-G-----------------------------\n";
                  ImportRmanLog($RmanLog);
                  print "   ----------E-N-D---R-E-C-O-V-E-R-Y---M-A-N-A-G-E-R---L-O-G-----------------------------\n";
               }
               # Cleanup -- remove the RMAN log and RMAN script
               # ------------------------------------------------
               #unlink $RmanScript;
               unlink $RmanLog;
            }
         }
      }
   }

   # $Result is used in email notification and final status
   # of the operation printed on the trailer at the end.
   # ---------------------------------------------------------
   if ($MainRC) {
      $Result = 'Failed';
   } else {
      $Result = 'Successful';
   }

   printf "=========================================================================================\n";
   printf "Operation %-20s    %+55s\n", $Result, ShowDate('LONG_DATE_TIME');
   printf "=========================================================================================\n";

   if (($Show ne 'true') and ($Generate ne 'true')) {
      # If failure or if notification is always on then send status of completion.
      if (((($MainRC) and ($Notify eq 'fail')) or ($Notify eq 'success')) and ($Show ne 'true') and ($Generate ne 'true')) {
         ($NotifyRC, $MailOut) = Notify($DistList, $Result, $DixieLog);

         if ($MailOut) {
            PrintWarning("Possible failure in delivering notification. Output from mail command follows:\n$MailOut");
            $NotifyRC = 1 if (not $NotifyRC);
         }
         if ($NotifyRC) {
            PrintWarning("Possible failure in delivering notification. Non-zero value returned by mail command: $NotifyRC");
         }
      }
   }
   $MainRC = $MainRC + $NotifyRC;
}
exit $MainRC;
# -----------------
# End Main
# -----------------


# --------------------------
#  Function Declarations
# --------------------------

# Sub : IsNumber()
# Desc: Tests a variable to see if it is a number.
# Args: 1=Variable to test.
# Retn: 1=0 or 1. 0=false - not a number, 1=true - is a number.
# ------------------------------------------------------------------------
sub IsNumber($) {
   my $numb = shift;
   my $rc;

   if ($Trace eq 'true') {
      print "TRACE: Entering sub IsNumber()\n";
      print "TRACE: Parameters: $numb\n";
   }

   # Test the variable.
   # --------------------
   if ($numb =~ /^?\d+$/ ) {
       $rc = 1;                      # Is a number
   } else {
       $rc = 0;                      # Is not a number
   }

   if ($Trace eq 'true') {
      print "TRACE: Exiting sub IsNumber()\n";
      print "TRACE: Returning: \$rc=$rc\n";
   }
   return $rc;
}
# ------------------------------------------------------------------------
# End IsNumber()
# ------------------------------------------------------------------------


# Sub : TrimString()
# Desc: Simple little function to trim the leading and trailing whitespace
#       from a string.
# Args: 1=Variable to trim.
# Retn: 1=Trimmed variable.
# ------------------------------------------------------------------------
sub TrimString($) {
   for (@_) {
       s/^\s*//; # trim leading spaces
       s/\s*$//; # trim trailing spaces
   }
   return @_;
}
# ------------------------------------------------------------------------
# End TrimString()
# ------------------------------------------------------------------------


# Sub:  PrintUsage()
# Desc: Prints program usage information.
# Args: <none>
# Retn: <none>
# ------------------------------------------------------------------------
sub PrintUsage($) {
   my $Basename = shift;

   print "\nUsage: " . $Basename . " -type [database|datafile|tablespace|arch|fra|register|crosscheck|...] [(-s)id MYDB] [(-che)cksyntax] [(-deb)ug] [(-tr)ace] [...]\n";
   print "Where: -(s)id         = Oracle SID for the local instance of the database\n";
   print "       -(che)cksyntax = Check the RMAN script for syntax errors. (script is *not* executed).\n";
   print "       -(deb)ug       = Rman debug output\n";
   print "       -(tr)ace       = Print trace level output\n";
   print "       -(h)elp        = Prints this message.\n\n";
   print "Examples:\n";
   print "       $Basename -sid MYDB -type database -device disk\n";
   print "       $Basename -sid MYDB -type database -device disk -debug\n";
   print "       $Basename -sid MYDB -type database -device disk -debug -trace\n";
   print "       $Basename -sid MYDB -type datafile -device sbt\n";
   print "       $Basename -sid MYDB -type tablespace -device sbt\n";
   print "       $Basename -sid MYDB -type crosscheck -device disk\n";
   print "       $Basename -sid MYDB -type fra -dev sbt -sbtlib 'ENV=(NB_ORA_CLIENT=my_host)\n";
   print "       $Basename -sid MYDB -type arch -device disk\n";
   print "       $Basename -sid MYDB -type resync\n";
   print "       $Basename -sid MYDB -type report_obsolete -device disk\n";
   print "       $Basename -sid MYDB -type delete_obsolete -device sbt\n";
   print "       $Basename -sid MYDB -type validate_backup -device disk\n";
   print "       $Basename -sid MYDB -type validate_restore -device disk\n";
   print "       $Basename -sid MYDB -type report_schema\n";
   print "       $Basename -sid MYDB -type report_need_backup\n";
   print "       $Basename -sid MYDB -type report_unrecoverable\n";
   print "       $Basename -sid MYDB -type list_expired -device sbt\n";
   print "       $Basename -sid MYDB -type delete_expired -device disk\n\n";
   print "       $Basename -sid MYDB -script my_backup_script.rcv\n";
   print "       $Basename -sid MYDB -script my_backup_script.rcv -checksyntax\n\n";
   exit 0;
}
# ------------------------------------------------------------------------
# End PrintUsage()
# ------------------------------------------------------------------------


# Sub:  PrintHelp()
# Desc: Prints alist of all the command line parameters available.
# Args: <none>
# Retn: <none>
# ------------------------------------------------------------------------
sub PrintHelp() {
   printf "\n=========================================================================================\n";
   printf "Dixie, version $Version\n";
   printf "=========================================================================================\n";
   print "The following options are supported:\n";
   print "  -archcopies   Backup n copies of archived redologs.\n";
   print "  -archlogs     Backup archived redolog files along with the database backup\n";
   print "  -catalog      Service name (SID) for the RMAN Recovery Catalog.\n";
   print "  -catuser      User account for logging into the RMAN Recovery Catalog.\n";
   print "  -channels     Number of channels to use for backup operation.\n";
   print "  -checksyntax  Check the RMAN script for syntax errors. (script is *not* executed).\n";
   print "  -comprlevel   Enable Rman's backup compression and set it to one of BASIC/LOW/MEDIUM/HIGH.\n";
   print "  -comproptim   Backup compression optimized for load?\n";
   print "  -controlfile  Backup the current controlfile and spfile with HOT/COLD backups.\n";
   print "  -configure    Generates and executes RMAN configuration commands as part of the RMAN operation.\n";
   print "  -copy         Database backup will be of type \"copy\" rather than backupset.\n";
   print "  -cumulative   Option to make incrementals cumulative rather than the default of\n";
   print "                differencial.\n";
   print "  -datafiles    Comma delimited list of datafiles to backup. (file ids not file names)\n";
   print "  -debug        Use Rman DEBUG optoin on the rman command line.\n";
   print "  -deletedelay  Delay the deletion of backed up archive logs for n days.\n";
   print "  -deletelogs   Delete archived redolog files at after they are backed up.\n";
   print "  -device       Backup device. DISK (default) or SBT.\n";
   print "  -directory    Backup directory for backupsets. Used with FORMAT if -device disk.\n";
   print "                Also used if -device sbt and -sbtlib oracle.disksbt\n";
   print "  -distchannels Distribute backup channels among all available instances (requires -user option).\n";
   print "  -duration     Maximum duration for database/datafile/tablespace/arch backups.\n";
   print "  -filesperset  Maximum files per set for database/datafile/tablespace/fra backups.\n";
   print "  -force        Forces Rman to ignore backup optimization option.\n";
   print "  -format       Format of backup piece file names. File names must be unique.\n";
   print "                Typical settings would be %U (default), %d_%u_%p_%c, etc...\n";
   print "  -generate     Generate Rman script only. Do not execute.\n";
   print "  -help         Displays this screen.\n";
   print "  -keepdays     Number of days to keep a backup set. This is used to override\n";
   print "                the normal retention policy.\n";
   print "  -keepnologs   Do not keep logs needed to recover a database backed-up using -keepdays\n";
   print "                option. This is required when the database is mounted (not open).\n";
   print "  -level        Incremental level for backup, Options include full (default), 0, and 1\n";
   print "  -maxopenfiles Maximum number of files to backup concurrently.\n";
   print "  -maxpiecesize Maximum size of a backup piece. Usefull for filesystems with 2G limit.\n";
   print "  -maxsetsize   Maximum size of a backup set. Usefull for tape size limitations.\n";
   print "  -nocat        No Recovery Catalog (use controlfile only).\n";
   print "  -nochecksum   Do not validate blocks for integrity. Carefull with this option.\n";
   print "  -noexclude    Rman will ignore the configuration setting for excluding tablespaces,\n";
   print "                CONFIGURE EXCLUDE FOR TABLESPACE tbs1, tbs2...\n";
   print "  -notify       Send notification (email) even if successful. Notify on fail is default.\n";
   print "  -obsolete     Check for and delete any backup sets no longer needed according to\n";
   print "                to the retention policy. See 'CONFIGURE RETENTION POLICY...'\n";
   print "  -parfile      Use this configuration file instead of the default dixie.conf.\n";
   print "  -plusarchlogs Adds backup of archived redo logs to the database backup.\n";
   print "                You may use this instead of the -archlogs option. When archivelogs\n";
   print "                are stored in the FRA this is the easiest way to automatically age them out.\n";
   print "                Make sure to use BACKUP OPTIMIZATION (RMAN Configure command) to keep from\n";
   print "                backing up archivelogs over and over again.\n";
   print "  -rate         Controls the max throughput of backup operations. Usefull for throttling\n";
   print "                I/O on busy systems or during peak periods of the day.\n";
   print "  -sbtlib       Used for backing up to SBT media. Settings required for Rman to talk\n";
   print "                to your media manager. See parms 'SBT_LIBRARY ...'\n";
   print "  -script       Run an external RMAN script\n";
   print "  -sectionsize  Parallelizes backups for bigfiles. Not compatible with with -copy option.\n";
   print "                Values allowed include nn...nnnn[{k|m|g}]. For example -sectionsize 250M\n";
   print "  -servicename  Service name used for connecting to the target database and establishing\n";
   print "                distributed channel connections (see -distchannels option).\n";
   print "  -show         Show Rman commands for this backup only. Do not execute backup commands.\n";
   print "  -sid          ORACLE_SID and ORACLE_HOME set based on this.\n";
   print "  -skip         Do not backup readonly, and/or offline, and/or inaccessible files.\n";
   print "  -tablespaces  Comma delimited list of tablespaces to backup. (Tablespace names, not ids)\n";
   print "  -trace        Print trace level output.\n";
   print "  -type         Backup type. Valid values are:\n";
   print "                resync                 Resyncronizes the RMAN catalog.\n";
   print "                register               Register the target database in the RMAN catalog.\n";
   print "                database               Full/incremental database backup.\n";
   print "                datafile               Full/incremental datafile backup.\n";
   print "                tablespace             Full/incremental tablespace backup.\n";
   print "                fra                    Full backup of the flash recovery area.\n";
   print "                arch                   Backup archived redologs.\n";
   print "                crosscheck             Crosscheck of the RMAN catalog.\n";
   print "                delete_expired         Crosscheck then delete expired backup sets.\n";
   print "                delete_obsolete        Delete obsolete backup sets.\n";
   print "                list_expired           Report backupsets that are not on backup media.\n";
   print "                report_schema          Database Schema Report.\n";
   print "                report_need_backup     Report datafiles in need of a fresh backup.\n";
   print "                report_unrecoverable   Report files in which unrecoverable transactions\n";
   print "                                       have occured.\n";
   print "                report_obsolete        Report unrecoverable files.\n";
   print "                validate_backup        Dry-run backup to verify physical database\n";
   print "                                       integrity.\n";
   print "                validate_restore       Dry-run restore to verify restorability of\n";
   print "                                       database.\n";
   print "  -user         Database username used for authenticating with the target database. Only\n";
   print "                required when using distributed channels or service name options.\n";
   print "  -version      Print version information.\n";
   printf "=========================================================================================\n";
   exit 0;
}


# Sub : DbBackup11g($)
# Desc: Build the RMAN Run Block execute a backup of the database.
# Args: $0 is the state of the database (OPEN, MOUNTED, DOWN, STARTED).
# Retn: RMAN runblock.
#------------------------------------------------------------------------
sub DbBackup11g($) {
   my $DbState = shift;
   my $TagOper = '';

   # Set $TagOper to be an abbreviation of $OperType due to TAG length constraint of 30 characters.
   # ------------------------------------------------------------------------------------------------
   if (uc($OperType) eq 'DATABASE') {
      $TagOper = 'DB';
   } elsif (uc($OperType) eq 'DATAFILE') {
      $TagOper = 'DF';
   } elsif (uc($OperType) eq 'TABLESPACE') {
      $TagOper = 'TS';
   }

   if ($Trace eq 'true') {
      print "TRACE: Entering sub DbBackup11g(\$)\n";
      print "TRACE: Parameters: \$DbState=$DbState\n";
   }

   # Assemble the backup run{} block based on active options.
   # -----------------------------------------------------------
   $RunBlock                .= "REPORT SCHEMA;\n\n";

   if ($ComprLevel ne '') {
      $RunBlock             .= "#----------------------------------------------------------\n";
      $RunBlock             .= "# Set Level of Compression Level\n";
      $RunBlock             .= "#----------------------------------------------------------\n";
      $RunBlock             .= "SET COMPRESSION ALGORITHM \'$ComprLevel\' AS OF RELEASE 'DEFAULT'";
      if ($ComprOptim eq 'true') {
         $RunBlock          .= " OPTIMIZE FOR LOAD TRUE;\n\n";
      } else {
         $RunBlock          .= " OPTIMIZE FOR LOAD FALSE;\n\n";
      }
   }

   $RunBlock                .= "#----------------------------------------------------------\n";
   $RunBlock                .= "# Database is $DbState $DbOpenMode\n"  if ($DbState eq 'OPEN');
   $RunBlock                .= "# Database is $DbState\n"              if ($DbState ne 'OPEN');
   $RunBlock                .= "#----------------------------------------------------------\n";

   $RunBlock                .= "run {\n";

   if ($KeepDays) {
      $Tag = 'DB_BS_' . uc($TagOper) . "_KEEP";
      ###! if ($KeepNoLogs eq 'true') {
      ###!    $Tag .= "_NOLOGS";
      ###! } else {
      ###!    $Tag .= "_LOGS";
      ###! }
   } else {
      $Tag = 'DB_BS_' . uc($TagLevel) . '_' . uc($TagOper);
   }
   print "   -Database Backup Tag.............. [$Tag]\n";

   $RunBlock                .= "  SET COMMAND ID TO 'RMAN:$Tag';\n\n";

   $RunBlock                .= "  # Allocate Channel(s)\n";
   $i=0;
   until ($i >= $Channels) {
      $i ++;
      $RunBlock             .= "  ALLOCATE CHANNEL " . $BackupDevice . $i  . " DEVICE TYPE " . $BackupDevice . $ChannelConnStr;
      $RunBlock             .= "\n   MAXOPENFILES $MaxOpenFiles" if ($MaxOpenFiles);
      $RunBlock             .= "\n   MAXPIECESIZE $MaxPieceSize" if ($MaxPieceSize);
      $RunBlock             .= "\n   RATE $StreamingRate"        if ($StreamingRate);
      $RunBlock             .= "\n   FORMAT $BackupFormat;\n\n"  if ($BackupFormat ne '');
      $RunBlock             .= ";\n\n"                           if ($BackupFormat eq '');
   }

  $RunBlock             .= "  #----------------------------------------------------------\n";
  $RunBlock             .= "  # Database Backup\n";
  $RunBlock             .= "  #----------------------------------------------------------\n";
  if ($Copy eq 'true') {
      $RunBlock             .= "  BACKUP AS COPY";
   } else {
      $RunBlock             .= "  BACKUP FULL AS"                   if ($IncrLevel eq 'full');
      $RunBlock             .= "  BACKUP INCREMENTAL LEVEL 0 AS"    if ($IncrLevel eq '0');
      $RunBlock             .= "  BACKUP INCREMENTAL LEVEL 1 AS"    if ($IncrLevel eq '1');
      $RunBlock             .= " COMPRESSED"                        if ($ComprLevel ne '');
      $RunBlock             .= " BACKUPSET";
      $RunBlock             .= "\n   DURATION $MaxDuration PARTIAL" if ($MaxDuration);
      $RunBlock             .= "\n   CUMULATIVE"                    if ($Cumulative eq 'true');
      $RunBlock             .= "\n   MAXSETSIZE $MaxSetSize"        if ($MaxSetSize);
      $RunBlock             .= "\n   SECTION SIZE $SectionSize"     if ($SectionSize);
      $RunBlock             .= "\n   FILESPERSET $FilesPerSet"      if ($FilesPerSet);
      foreach $Skip (@Skip) {
         $RunBlock          .= "\n   SKIP $Skip";
      }
   }
   $RunBlock                .= "\n   NOCHECKSUM" if ($NoChecksum eq 'true');

   if ($OperType eq 'database') {
      $RunBlock             .= "\n   DATABASE";
   } else {
      if ($OperType eq 'datafile') {
         $RunBlock          .= "\n   DATAFILE " . join(', ', @DbfList);
      } else {
         if ($OperType eq 'tablespace') {
            $RunBlock       .= "\n   TABLESPACE " . join(', ', @TbsList);
         }
      }
   }

   $RunBlock                .= "\n   FORCE"     if ($Force eq 'true');
   $RunBlock                .= "\n   NOEXCLUDE" if ($NoExclude eq 'true');

   if ($KeepDays) {
      if ($KeepNoLogs eq 'true') {
         $RunBlock          .= "\n   KEEP UNTIL TIME 'trunc(sysdate + " . $KeepDays . ")' NOLOGS";
      } else {
         $RunBlock          .= "\n   KEEP UNTIL TIME 'trunc(sysdate + " . $KeepDays . ")' LOGS";
      }
   }

   $RunBlock                .= "\n   INCLUDE CURRENT CONTROLFILE" if ($Controlfile eq 'true');
   $RunBlock                .= "\n   PLUS ARCHIVELOG"             if ($PlusArchlogs eq 'true');
   $RunBlock                .= "\n   TAG = '$Tag';\n";

   # Release Channel(s)
   # --------------------
   $RunBlock                .= "\n  # Release Channel(s)";
   $i=0;
   until ($i >= $Channels) {
      $i ++;
      $RunBlock             .= "\n  RELEASE CHANNEL " . $BackupDevice . $i . ";";
   }
   $RunBlock                .= "\n}\n";

   # Archivelog backup...
   # ----------------------------
   if ($ArchLogs eq 'true') {
      if ($Copy ne 'true') {
         $Tag = 'AL_BS_AL';
      } else {
         $Tag = 'AL_CP_AL';
         if ($ArchCopies) {
            $Tag .= '_NBU_' . $ArchCopies . 'X';
         }
      }
      if ($KeepDays) {
         $Tag .= "_KEEP";
      }
      print "   -Archivelog Backup Tag............ [$Tag]\n";
      $RunBlock             .= "\n#----------------------------------------------------------\n";
      $RunBlock             .= "# Database is $DbState $DbOpenMode\n"  if ($DbState eq 'OPEN');
      $RunBlock             .= "# Database is $DbState\n"              if ($DbState ne 'OPEN');
      $RunBlock             .= "#----------------------------------------------------------\n";
      if ($DbOpenMode eq 'READ WRITE' and $ArchLogs eq 'true') {
         $RunBlock          .= "# Flush online redologs to disk.\n";
         $RunBlock          .= "SQL 'alter system archive log current';\n\n";
      }

      $RunBlock             .= "run {\n";
      $RunBlock             .= "  SET COMMAND ID TO 'RMAN:$Tag';\n\n";

      $RunBlock             .= "  # Allocate Channel(s)\n";
      $i=0;
      until ($i >= $Channels) {
         $i ++;
         $RunBlock          .= "  ALLOCATE CHANNEL " . $BackupDevice . $i  . " DEVICE TYPE " . $BackupDevice . $ChannelConnStr;
         $RunBlock          .= "\n   MAXOPENFILES $MaxOpenFiles" if ($MaxOpenFiles);
         $RunBlock          .= "\n   MAXPIECESIZE $MaxPieceSize" if ($MaxPieceSize);
         $RunBlock          .= "\n   RATE $StreamingRate"        if ($StreamingRate);
         $RunBlock          .= "\n   FORMAT $BackupFormat;\n\n"  if ($BackupFormat ne '');
         $RunBlock          .= ";\n\n"                           if ($BackupFormat eq '');
      }

      $RunBlock             .= "  #----------------------------------------------------------\n";
      $RunBlock             .= "  # Archivelog Backup\n";
      $RunBlock             .= "  #----------------------------------------------------------\n";
      if ($Copy eq 'true') {
         $RunBlock          .= "  BACKUP AS COPY\n";
      } else {
         if ($ComprLevel ne '') {
            $RunBlock       .= "  BACKUP AS COMPRESSED BACKUPSET\n";
         } else {
            $RunBlock       .= "  BACKUP AS BACKUPSET\n";
         }
         $RunBlock          .= "   DURATION $MaxDuration PARTIAL\n" if ($MaxDuration);
         $RunBlock          .= "   CUMULATIVE\n"                    if ($Cumulative eq 'true');
         $RunBlock          .= "   MAXSETSIZE $MaxSetSize\n"        if ($MaxSetSize);
         $RunBlock          .= "   FILESPERSET $FilesPerSet\n"      if ($FilesPerSet);
         if ($KeepDays) {
            $RunBlock       .= "   KEEP UNTIL TIME 'trunc(sysdate + " . $KeepDays . ")'\n";
         }
      }
      $RunBlock    .= "   NOCHECKSUM\n"                       if ($NoChecksum eq 'true');
      if ($ArchCopies > 0) {
         $RunBlock          .= "   ARCHIVELOG ALL NOT BACKED UP $ArchCopies TIMES";
      } else {
         $RunBlock          .= "   ARCHIVELOG ALL";
      }
      $RunBlock             .= " DELETE INPUT" if (($DeleteLogs eq 'true') and ($DeleteDelay eq ''));
      if ($Copy eq 'true') {
         $RunBlock          .= ";\n";
      } else {
         $RunBlock          .= "\n   TAG = '" . $Tag . "';\n";
      }

      # Release Channel(s)
      # --------------------
      $RunBlock             .= "\n  # Release Channel(s)";
      $i=0;
      until ($i >= $Channels) {
         $i ++;
         $RunBlock          .= "\n  RELEASE CHANNEL " . $BackupDevice . $i . ";";
      }
      $RunBlock             .= "\n}\n";
   }

   # Delete Obsolete Backups
   # --------------------------
   if (($DeleteObsolete eq 'true') or (($DeleteLogs eq 'true') and ($DeleteDelay ne ''))) {
      $RunBlock             .= "\n# Allocate Channel for Maintenance";
      $RunBlock             .= "\nALLOCATE CHANNEL FOR MAINTENANCE DEVICE TYPE " . $BackupDevice . " FORMAT " . $BackupFormat . $ChannelConnStr . ";\n";
   }
   if ($DeleteObsolete eq 'true') {
      $RunBlock             .= "\n#-------------------------";
      $RunBlock             .= "\n# Delete Obsolete Backups";
      $RunBlock             .= "\n#-------------------------";
      $RunBlock             .= "\nDELETE FORCE NOPROMPT OBSOLETE " . $Retention . " DEVICE TYPE "   . $BackupDevice . ";\n";
   }

   if (($DeleteLogs eq 'true') and ($DeleteDelay ne '')) {
      $RunBlock             .= "\n" if ($DeleteObsolete eq 'true');
      $RunBlock             .= "\n#-------------------------";
      $RunBlock             .= "\n# Delete Old Archivelogs";
      $RunBlock             .= "\n#-------------------------";
      $RunBlock             .= "\nDELETE ARCHIVELOG ALL COMPLETED BEFORE \'TRUNC(SYSDATE-$DeleteDelay)\';\n" ;
   }

   if ($Trace eq 'true') {
      print "TRACE: Exiting sub DbBackup11g(\$)\n";
      print "TRACE: Returning: \$RunBlock=$RunBlock\n";
   }
   return;
}
# ------------------------------------------------------------------------
# End DbBackup11g()
# ------------------------------------------------------------------------


# Sub : ArchBackup11g($)
# Desc: Build the RMAN Run Block execute a backup of the recovery area.
# Args: 1=The state of the database (OPEN, MOUNTED, DOWN, STARTED).
# Retn: 1=Rman runblock.
# ------------------------------------------------------------------------
sub ArchBackup11g($) {
   my $DbState = shift;

   if ($Trace eq 'true') {
      print "TRACE: Entering sub ArchBackup11g(\$)\n";
      print "TRACE: Parameters: \$DbState=$DbState\n";
   }

   # Set the backup Tag
   # ---------------------
   if ($Copy ne 'true') {
      $Tag = 'AL_BS_ALL';
   } else {
      $Tag = 'AL_CP_ALL';
      if ($ArchCopies) {
         $Tag .= '_NBU_' . $ArchCopies . 'X';
      }
   }
   if ($KeepDays) {
      $Tag .= "_KEEP";
   }
   print "   -Archivelog Backup Tag............ [$Tag]\n";

   if ($ComprLevel ne '') {
      $RunBlock    .= "#----------------------------------------------------------\n";
      $RunBlock    .= "# Set Level of Compression Level\n";
      $RunBlock    .= "#----------------------------------------------------------\n";
      $RunBlock    .= "SET COMPRESSION ALGORITHM \'$ComprLevel\' AS OF RELEASE 'DEFAULT'";
      if ($ComprOptim eq 'true') {
         $RunBlock .= " OPTIMIZE FOR LOAD TRUE;\n\n";
      } else {
         $RunBlock .= " OPTIMIZE FOR LOAD FALSE;\n\n";
      }
   }

   if ($DbOpenMode eq 'READ WRITE' and $ArchLogs eq 'true') {
      $RunBlock             .= "# Flush online redologs to disk.\n";
      $RunBlock             .= "SQL 'alter system archive log current';\n\n";
   }

   $RunBlock             .= "#----------------------------------------------------------\n";
   $RunBlock             .= "# Database is $DbState $DbOpenMode\n"  if ($DbState eq 'OPEN');
   $RunBlock             .= "# Database is $DbState\n"              if ($DbState ne 'OPEN');
   $RunBlock             .= "#----------------------------------------------------------\n";

   $RunBlock             .= "run {\n";
   $RunBlock             .= "  SET COMMAND ID TO 'RMAN:$Tag';\n\n";


   $RunBlock             .= "  # Allocate Channel(s)\n";
   $i=0;
   until ($i >= $Channels) {
      $i ++;
      $RunBlock          .= "  ALLOCATE CHANNEL " . $BackupDevice . $i  . " DEVICE TYPE " . $BackupDevice . $ChannelConnStr;
      $RunBlock          .= "\n   MAXOPENFILES $MaxOpenFiles" if ($MaxOpenFiles);
      $RunBlock          .= "\n   MAXPIECESIZE $MaxPieceSize" if ($MaxPieceSize);
      $RunBlock          .= "\n   RATE $StreamingRate"        if ($StreamingRate);
      $RunBlock          .= "\n   FORMAT $BackupFormat;\n\n"  if ($BackupFormat ne '');
      $RunBlock          .= ";\n\n"                           if ($BackupFormat eq '');
   }

   $RunBlock       .= "  #----------------------------------------------------------\n";
   $RunBlock       .= "  # Archivelog Backup\n";
   $RunBlock       .= "  #----------------------------------------------------------\n";
   if ($Copy eq 'true') {
      $RunBlock    .= "  BACKUP AS COPY\n";
   } else {
      if ($ComprLevel ne '') {
         $RunBlock .= "  BACKUP AS COMPRESSED BACKUPSET\n";
      } else {
         $RunBlock .= "  BACKUP AS BACKUPSET\n";
      }
      $RunBlock    .= "   DURATION $MaxDuration PARTIAL\n" if ($MaxDuration);
      $RunBlock    .= "   CUMULATIVE\n"                    if ($Cumulative eq 'true');
      $RunBlock    .= "   MAXSETSIZE $MaxSetSize\n"        if ($MaxSetSize);
      $RunBlock    .= "   FILESPERSET $FilesPerSet\n"      if ($FilesPerSet);
      if ($KeepDays) {
         $RunBlock       .= "   KEEP UNTIL TIME 'trunc(sysdate + " . $KeepDays . ")'\n";
      }
   }
   $RunBlock    .= "   NOCHECKSUM\n" if ($NoChecksum eq 'true');
   if ($ArchCopies > 0) {
      $RunBlock    .= "   ARCHIVELOG ALL NOT BACKED UP $ArchCopies TIMES";
   } else {
      $RunBlock    .= "   ARCHIVELOG ALL";
   }
   $RunBlock       .= " DELETE INPUT" if (($DeleteLogs eq 'true') and ($DeleteDelay eq ''));
   if ($Copy eq 'true') {
      $RunBlock    .= ";\n\n";
   } else {
      $RunBlock    .= "\n   TAG = '" . $Tag . "';\n\n";
   }

   # Release Channel(s)
   # --------------------
   $RunBlock       .= "  # Release Channel(s)\n";
   $i=0;
   until ($i >= $Channels) {
      $i ++;
      $RunBlock    .= "  RELEASE CHANNEL " . $BackupDevice . $i . ";\n";
   }
   $RunBlock       .= "}\n";

   # Delete Obsolete Backups
   # --------------------------
   if (($DeleteObsolete eq 'true') or (($DeleteLogs eq 'true') and ($DeleteDelay ne ''))) {
      $RunBlock    .= "\n";
      $RunBlock    .= "# Allocate Channel for Maintenance\n";
      $RunBlock    .= "ALLOCATE CHANNEL FOR MAINTENANCE DEVICE TYPE " . $BackupDevice . " FORMAT " . $BackupFormat . $ChannelConnStr . ";\n";
   }

   if ($DeleteObsolete eq 'true') {
      $RunBlock    .= "\n#-------------------------\n";
      $RunBlock    .= "# Delete Obsolete Backups\n";
      $RunBlock    .= "#-------------------------\n";
      $RunBlock    .= "DELETE FORCE NOPROMPT OBSOLETE " . $Retention . " DEVICE TYPE "   . $BackupDevice . ";\n";
   }

   if (($DeleteLogs eq 'true') and ($DeleteDelay ne '')) {
      $RunBlock    .= "\n" if ($DeleteObsolete eq 'true');
      $RunBlock    .= "#-------------------------\n";
      $RunBlock    .= "# Delete Old Archivelogs  \n";
      $RunBlock    .= "#-------------------------\n";

      # Delete archivelogs backed up n days ago.
      # -----------------------------------------
      $RunBlock    .= "DELETE ARCHIVELOG ALL COMPLETED BEFORE \'TRUNC(SYSDATE-$DeleteDelay)\';\n" ;
   }

   if ($Trace eq 'true') {
      print "TRACE: Exiting sub ArchBackup11g(\$)\n";
      print "TRACE: Returning: \$RunBlock=$RunBlock\n";
   }
   return;
}
# ------------------------------------------------------------------------
# End ArchBackup11g()
# ------------------------------------------------------------------------


# Sub:  FraBackup11g()
# Desc: Build the RMAN Run Block execute a backup of the recovery area.
# Args: <none>
# Retn: 1=RMAN runblock.
# ------------------------------------------------------------------------
sub FraBackup11g() {

   if ($Trace eq 'true') {
      print "TRACE: Entering sub FraBackup11g()\n";
      print "TRACE: Parameters: none\n";
   }

   $Tag = 'RECOVERY_AREA_BACKUP';
   print "   -Recovery Area Backup Tag......... [$Tag]\n";

   if ($DbOpenMode eq 'READ WRITE' and $ArchLogs eq 'true') {
      $RunBlock .= "# Flush online redologs to disk.\n";
      $RunBlock .= "SQL 'alter system archive log current';\n\n";
   }

   $RunBlock    .= "#----------------------------------------------------------\n";
   $RunBlock    .= "# Database is $DbState $DbOpenMode\n"  if ($DbState eq 'OPEN');
   $RunBlock    .= "# Database is $DbState\n"              if ($DbState ne 'OPEN');
   $RunBlock    .= "#----------------------------------------------------------\n";
   $RunBlock    .= "run {\n";
   $RunBlock    .= "  SET COMMAND ID TO 'RMAN:$Tag';\n\n";
   $RunBlock    .= "  # Allocate Channel(s)\n";
   $i=0;
   until ($i >= $Channels) {
      $i ++;
      $RunBlock .= "  ALLOCATE CHANNEL " . $BackupDevice . $i  . " DEVICE TYPE " . $BackupDevice . $ChannelConnStr;
      $RunBlock .= "\n   MAXOPENFILES $MaxOpenFiles"                               if ($MaxOpenFiles);
      $RunBlock .= "\n   MAXPIECESIZE $MaxPieceSize"                               if ($MaxPieceSize);
      $RunBlock .= "\n   RATE $StreamingRate"                                      if ($StreamingRate);
      $RunBlock .= "\n   FORMAT $BackupFormat;\n\n"                                if ($BackupFormat ne '');
      $RunBlock .= ";\n"                                                           if ($BackupFormat eq '');
   }
   $RunBlock    .= "\n"                                                            if ($BackupFormat eq '');

   $RunBlock    .= "  #-----------------------\n";
   $RunBlock    .= "  # Recovery Area Backup\n";
   $RunBlock    .= "  #-----------------------\n";
   $RunBlock    .= "  BACKUP AS";
   if ($Copy eq 'true') {
      $RunBlock .= " COPY\n";
   } else {
      $RunBlock .= " BACKUPSET\n";
   }
   $RunBlock    .= "   DURATION $MaxDuration PARTIAL\n"                            if ($MaxDuration);
   $RunBlock    .= "   FILESPERSET $FilesPerSet\n"                                 if ($FilesPerSet);
   if ($KeepDays) {
      $RunBlock .= "   KEEP UNTIL TIME 'trunc(sysdate + " . $KeepDays . ")'\n";
   }
   $RunBlock    .= "   RECOVERY AREA\n";
   $RunBlock    .= "   TAG = '$Tag';\n\n";

   $RunBlock    .= "  REPORT OBSOLETE;\n\n"                                        if ($DeleteObsolete eq 'false');

   # Release Channel(s)
   # -------------------
   $RunBlock    .= "  # Release Channel(s)\n";
   $i=0;
   until ($i >= $Channels) {
      $i ++;
      $RunBlock .= "  RELEASE CHANNEL " . $BackupDevice . $i . ";\n";
   }
   $RunBlock    .= "}\n";

   # Delete Obsolete Backups
   # -------------------------
   if ($DeleteObsolete eq 'true') {
      $RunBlock .= "\n";
      $RunBlock .= "#-------------------------\n";
      $RunBlock .= "# Delete Obsolete Backups\n";
      $RunBlock .= "#-------------------------\n";
      $RunBlock .= "ALLOCATE CHANNEL FOR MAINTENANCE DEVICE TYPE " . $BackupDevice . " FORMAT " . $BackupFormat . $ChannelConnStr . ";\n";
      $RunBlock .= "DELETE FORCE NOPROMPT OBSOLETE " . $Retention . " DEVICE TYPE "   . $BackupDevice . ";\n";
   }

   if ($Trace eq 'true') {
      print "TRACE: Exiting sub FraBackup11g()\n";
      print "TRACE: Returning: \$RunBlock=$RunBlock\n";
   }
   return;
}
# ------------------------------------------------------------------------
# End FraBackup11g()
# ------------------------------------------------------------------------


# Sub : Resync()
# Desc: Build the RMAN Run Block to resynchronize the recovery catalog.
# Args: <none>
# Retn: RMAN runblock.
# ------------------------------------------------------------------------
sub Resync() {
   if ($Trace eq 'true') {
      print "TRACE: Entering sub Resync()\n";
      print "TRACE: Parameters: none\n";
   }

   $RunBlock .= "#-----------------\n";
   $RunBlock .= "# Resync Catalog  \n";
   $RunBlock .= "#-----------------\n";
   $RunBlock .= "SET COMMAND ID TO 'RMAN:RESYNC CATALOG';\n";
   $RunBlock .= "RESYNC CATALOG;\n";

   if ($Trace eq 'true') {
      print "TRACE: Exiting sub Resync()\n";
      print "TRACE: Returning: \$RunBlock=$RunBlock\n";
   }
   return;
}
# ------------------------------------------------------------------------
# End Resync()
# ------------------------------------------------------------------------


# Sub : ValidateBackup()
# Desc: Build the RMAN Run Block to validate database physical integrity.
# Args: <none>
# Retn: RMAN runblock.
# ------------------------------------------------------------------------
sub ValidateBackup() {
   if ($Trace eq 'true') {
      print "TRACE: Entering sub ValidateBackup()\n";
      print "TRACE: Parameters: none\n";
   }

   $RunBlock    .= "#--------------------------------\n";
   $RunBlock    .= "# Backup Check Logical Validate\n";
   $RunBlock    .= "#--------------------------------\n";
   $RunBlock    .= "run {\n";
   $RunBlock    .= "  SET COMMAND ID TO 'RMAN:VALIDATE BACKUP';\n\n";
   $RunBlock    .= "  # Allocate Channel(s)\n";
   $i=0;
   until ($i >= $Channels) {
      $i ++;
      $RunBlock .= "  ALLOCATE CHANNEL " . $BackupDevice . $i  . " DEVICE TYPE " . $BackupDevice . $ChannelConnStr;
      $RunBlock .= "\n   MAXOPENFILES $MaxOpenFiles"                               if ($MaxOpenFiles);
      $RunBlock .= "\n   MAXPIECESIZE $MaxPieceSize"                               if ($MaxPieceSize);
      $RunBlock .= "\n   RATE $StreamingRate"                                      if ($StreamingRate);
      $RunBlock .= "\n   FORMAT $BackupFormat;\n\n"                                if ($BackupFormat ne '');
      $RunBlock .= ";\n"                                                           if ($BackupFormat eq '');
   }
   $RunBlock    .= "\n"                                                            if ($BackupFormat eq '');
   $RunBlock    .= "  # Execute Validate\n";
   $RunBlock    .= "  BACKUP CHECK LOGICAL VALIDATE";

   foreach $Skip (@Skip) {
      $RunBlock .= " SKIP $Skip"
   }
   $RunBlock    .= " DATABASE;\n\n";

   # Release Channel(s)
   # --------------------
   $RunBlock    .= "  # Release Channel(s)\n";
   $i=0;
   until ($i >= $Channels) {
      $i ++;
      $RunBlock .= "  RELEASE CHANNEL " . $BackupDevice . $i . ";\n";
   }
   $RunBlock    .= "}\n";

   if ($Trace eq 'true') {
      print "TRACE: Exiting sub ValidateBackup()\n";
      print "TRACE: Returning: \$RunBlock=$RunBlock\n";
   }
   return;
}
# ------------------------------------------------------------------------
# End ValidateBackup()
# ------------------------------------------------------------------------


# Sub : ValidateRestore()
# Desc: Build the RMAN Run Block to verify restorability of database from backup.
# Args: <none>
# Retn: RMAN runblock.
# ------------------------------------------------------------------------
sub ValidateRestore() {
   if ($Trace eq 'true') {
      print "TRACE: Entering sub ValidateRestore()\n";
      print "TRACE: Parameters: none\n";
   }

   $RunBlock    .= "#--------------------------------\n";
   $RunBlock    .= "# Backup Check Logical Validate\n";
   $RunBlock    .= "#--------------------------------\n";
   $RunBlock    .= "run {\n";
   $RunBlock    .= "  SET COMMAND ID TO 'RMAN:VALIDATE RESTORE';\n\n";
   $RunBlock    .= "  # Allocate Channel(s)\n";
   $i=0;
   until ($i >= $Channels) {
      $i ++;
      $RunBlock .= "  ALLOCATE CHANNEL " . $BackupDevice . $i  . " DEVICE TYPE " . $BackupDevice . $ChannelConnStr;
      $RunBlock .= "\n   MAXOPENFILES $MaxOpenFiles"                               if ($MaxOpenFiles);
      $RunBlock .= "\n   MAXPIECESIZE $MaxPieceSize"                               if ($MaxPieceSize);
      $RunBlock .= "\n   RATE $StreamingRate"                                      if ($StreamingRate);
      $RunBlock .= "\n   FORMAT $BackupFormat;\n\n"                                if ($BackupFormat ne '');
      $RunBlock .= ";\n"                                                           if ($BackupFormat eq '');
   }
   $RunBlock    .= "\n"                                                            if ($BackupFormat eq '');
   $RunBlock    .= "  # Execute Validate\n";
   $RunBlock    .= "  RESTORE DATABASE VALIDATE CHECK LOGICAL;\n\n";

   # Release Channel(s)
   # ---------------------
   $RunBlock    .= "  # Release Channel(s)\n";
   $i=0;
   until ($i >= $Channels) {
      $i ++;
      $RunBlock .= "  RELEASE CHANNEL " . $BackupDevice . $i . ";\n";
   }
   $RunBlock    .= "}\n";

   if ($Trace eq 'true') {
      print "TRACE: Exiting sub ValidateRestore()\n";
      print "TRACE: Returning: \$RunBlock=$RunBlock\n";
   }
   return;
}
# ------------------------------------------------------------------------
# End ValidateRestore()
# ------------------------------------------------------------------------


# Sub : Crosscheck()
# Desc: Build the RMAN Run Block to crosscheck the catalog.
# Args: <none>
# Retn: RMAN runblock.
# ------------------------------------------------------------------------
sub Crosscheck() {
   if ($Trace eq 'true') {
      print "TRACE: Entering sub Crosscheck()\n";
      print "TRACE: Parameters: none\n";
   }

   $RunBlock    .= "#---------------------\n";
   $RunBlock    .= "# Crosscheck Backups\n";
   $RunBlock    .= "#---------------------\n";
   $RunBlock    .= "run {\n";

   $RunBlock    .= "  SET COMMAND ID TO 'RMAN:CROSSCHECK';\n\n";
   $RunBlock    .= "  # Allocate Channel(s)\n";

   $i=0;
   until ($i >= $Channels) {
      $i ++;
      $RunBlock .= "  ALLOCATE CHANNEL " . $BackupDevice . $i  . " DEVICE TYPE " . $BackupDevice . $ChannelConnStr;
      $RunBlock .= "\n   FORMAT $BackupFormat;\n\n"                       if ($BackupFormat ne '');
      $RunBlock .= ";\n"                                                  if ($BackupFormat eq '');
   }
   $RunBlock    .= "\n"                                                   if ($BackupFormat eq '');

   $RunBlock    .= "  CROSSCHECK BACKUPSET DEVICE TYPE " . $BackupDevice . ";\n";
   $RunBlock    .= "  CROSSCHECK BACKUP DEVICE TYPE " . $BackupDevice . ";\n";
   $RunBlock    .= "  CROSSCHECK COPY DEVICE TYPE " . $BackupDevice . ";\n";
   $RunBlock    .= "  CROSSCHECK ARCHIVELOG ALL DEVICE TYPE " . $BackupDevice . ";\n\n";

   # Release Channel(s)
   # ---------------------
   $RunBlock    .= "  # Release Channel(s)\n";
   $i=0;
   until ($i >= $Channels) {
      $i ++;
      $RunBlock .= "  RELEASE CHANNEL " . $BackupDevice . $i . ";\n";
   }
   $RunBlock    .= "}\n";

   if ($Trace eq 'true') {
      print "TRACE: Exiting sub Crosscheck()\n";
      print "TRACE: Returning: \$RunBlock=$RunBlock\n";
   }
   return;
}
# ------------------------------------------------------------------------
# End CrossCheck()
# ------------------------------------------------------------------------


# Sub : Register()
# Desc: Build the RMAN Run Block for registering the database.
# Args: <none>
# Retn: RMAN runblock.
# ------------------------------------------------------------------------
sub Register() {
   if ($Trace eq 'true') {
      print "TRACE: Entering sub Register()\n";
      print "TRACE: Parameters: none\n";
   }

   $RunBlock .= "\n#---------------------\n";
   $RunBlock .= "# Register Database\n";
   $RunBlock .= "#---------------------\n";
   $RunBlock .= "SET COMMAND ID TO 'RMAN:REGISTER DATABASE';\n";
   $RunBlock .= "REGISTER DATABASE;\n";

   if ($Trace eq 'true') {
      print "TRACE: Exiting sub Register()\n";
      print "TRACE: Returning: \$RunBlock=$RunBlock\n";
   }
   return;
}
# ------------------------------------------------------------------------
# End Register()
# ------------------------------------------------------------------------

# Sub : DeleteExpired()
# Desc: Build the RMAN Run Block for deleting expired backup sets.
# Args: <none>
# Retn: RMAN runblock.
# ------------------------------------------------------------------------
sub DeleteExpired() {
   if ($Trace eq 'true') {
      print "TRACE: Entering sub DeleteExpired()\n";
      print "TRACE: Parameters: none\n";
   }

   $RunBlock    .= "\n#-------------------------\n";
   $RunBlock    .= "# Delete Expired Backups  \n";
   $RunBlock    .= "#-------------------------\n";
   $RunBlock    .= "SET COMMAND ID TO 'RMAN:DELETE EXPIRED';\n\n";
   $RunBlock    .= "ALLOCATE CHANNEL FOR MAINTENANCE DEVICE TYPE " . $BackupDevice . " FORMAT " . $BackupFormat . $ChannelConnStr . ";\n\n";

   $RunBlock    .= "  CROSSCHECK BACKUPSET DEVICE TYPE " . $BackupDevice . ";\n";
   $RunBlock    .= "  DELETE FORCE NOPROMPT EXPIRED BACKUPSET DEVICE TYPE " . $BackupDevice . ";\n\n";

   $RunBlock    .= "  CROSSCHECK BACKUP DEVICE TYPE " . $BackupDevice . ";\n";
   $RunBlock    .= "  DELETE FORCE NOPROMPT EXPIRED BACKUP DEVICE TYPE " . $BackupDevice . ";\n\n";

   $RunBlock    .= "  CROSSCHECK COPY DEVICE TYPE " . $BackupDevice . ";\n";
   $RunBlock    .= "  DELETE FORCE NOPROMPT EXPIRED COPY DEVICE TYPE " . $BackupDevice . ";\n\n";

   $RunBlock    .= "  CROSSCHECK ARCHIVELOG ALL DEVICE TYPE " . $BackupDevice . ";\n";
   $RunBlock    .= "  DELETE FORCE NOPROMPT EXPIRED ARCHIVELOG ALL DEVICE TYPE " . $BackupDevice . ";\n";

   if ($Trace eq 'true') {
      print "TRACE: Exiting sub DeleteExpired()\n";
      print "TRACE: Returning: \$RunBlock=$RunBlock\n";
   }
   return;
}
# ------------------------------------------------------------------------
# End DeleteExpired()
# ------------------------------------------------------------------------


# Sub : DeleteObsolete()
# Desc: Build the RMAN Run Block for deleting obsolete backup sets.
#       This subroutinE is also employed to old archivelogs completed
#       before "sysdate - nnn"
# Args: <none>
# Retn: RMAN runblock.
# ------------------------------------------------------------------------
sub DeleteObsolete() {
   if ($Trace eq 'true') {
      print "TRACE: Entering sub DeleteObsolete()\n";
      print "TRACE: Parameters: none\n";
   }

   $RunBlock .= "#-------------------------\n";
   $RunBlock .= "# Delete Obsolete Backups\n";
   $RunBlock .= "#-------------------------\n";
   $RunBlock .= "SET COMMAND ID TO 'RMAN:DELETE OBSOLETE';\n\n";
   $RunBlock .= "# Allocate Channel for Maintenance\n";
   $RunBlock .= "ALLOCATE CHANNEL FOR MAINTENANCE DEVICE TYPE " . $BackupDevice . " FORMAT " . $BackupFormat . $ChannelConnStr . ";\n\n";
   if ($Retention) {
      $RunBlock .= "DELETE FORCE NOPROMPT OBSOLETE " . $Retention . " DEVICE TYPE "   . $BackupDevice . ";\n";
   } else {
      $RunBlock .= "DELETE FORCE NOPROMPT OBSOLETE DEVICE TYPE "   . $BackupDevice . ";\n";
  }

   if ($Trace eq 'true') {
      print "TRACE: Exiting sub DeleteObsolete()\n";
      print "TRACE: Returning: \$RunBlock=$RunBlock\n";
   }
   return;
}
# ------------------------------------------------------------------------
# End DeleteObsolete()
# ------------------------------------------------------------------------


# Sub : ReportSchema()
# Desc: Build the RMAN Run Block for reporting the database schema.
# Args: <none>
# Retn: RMAN runblock.
# ------------------------------------------------------------------------
sub ReportSchema() {
   if ($Trace eq 'true') {
      print "TRACE: Entering sub ReportSchema()\n";
      print "TRACE: Parameters: none\n";
   }

   $RunBlock .= "#----------------\n";
   $RunBlock .= "# Report Schema\n";
   $RunBlock .= "#----------------\n";
   $RunBlock    .= "SET COMMAND ID TO 'RMAN:REPORT SCHEMA';\n\n";
   $RunBlock .= "REPORT SCHEMA;\n";

   if ($Trace eq 'true') {
      print "TRACE: Exiting sub ReportSchema()\n";
      print "TRACE: Returning: \$RunBlock=$RunBlock\n";
   }
   return;
}
# ------------------------------------------------------------------------
# End ReportSchema()
# ------------------------------------------------------------------------

# Sub : ReportNeedBackup()
# Desc: Build the RMAN Run Block for reporting database files in need of
#       a fresh backup.
# Args: <none>
# Retn: RMAN runblock.
# ------------------------------------------------------------------------
sub ReportNeedBackup() {
   if ($Trace eq 'true') {
      print "TRACE: Entering sub ReportNeedBackup()\n";
      print "TRACE: Parameters: none\n";
   }

   $RunBlock    .= "#---------------------------------\n";
   $RunBlock    .= "# Files that need a fresh backup\n";
   $RunBlock    .= "#---------------------------------\n";
   $RunBlock    .= "run {\n";
   $RunBlock    .= "  SET COMMAND ID TO 'RMAN:REPORT NEED BACKUP';\n\n";

   # Allocate Channel(s)
   # -----------------------
   $RunBlock    .= "  # Allocate Channel(s)\n";
   $i=0;
   until ($i >= $Channels) {
      $i ++;
      $RunBlock .= "  ALLOCATE CHANNEL " . $BackupDevice . $i  . " DEVICE TYPE " . $BackupDevice . $ChannelConnStr;
      $RunBlock .= "\n   FORMAT $BackupFormat;\n\n"                                  if ($BackupFormat ne '');
      $RunBlock .= ";\n"                                                             if ($BackupFormat eq '');
   }
   $RunBlock    .= "\n"                                                              if ($BackupFormat eq '');
   $RunBlock    .= "  REPORT NEED BACKUP DEVICE TYPE " . $BackupDevice . ";\n\n";

   # Release Channel(s)
   # --------------------
   $RunBlock    .= "  # Release Channel(s)\n";
   $i=0;
   until ($i >= $Channels) {
      $i ++;
      $RunBlock .= "  RELEASE CHANNEL " . $BackupDevice . $i . ";\n";
   }
   $RunBlock    .= "}\n";

   if ($Trace eq 'true') {
      print "TRACE: Exiting sub ReportNeedBackup()\n";
      print "TRACE: Returning: \$RunBlock=$RunBlock\n";
   }
   return;
}
# ------------------------------------------------------------------------
# End ReportNeedBackup()
# ------------------------------------------------------------------------

# Sub : ReportUnrecoverable()
# Desc: Build the RMAN Run Block for checking for database files in which
#        unrecoverable operations have occured.
# Args: <none>
# Retn: RMAN runblock.
# ------------------------------------------------------------------------
sub ReportUnrecoverable() {
   if ($Trace eq 'true') {
      print "TRACE: Entering sub ReportUnrecoverable()\n";
      print "TRACE: Parameters: none\n";
   }

   $RunBlock    .= "#-----------------------------------------------------\n";
   $RunBlock    .= "# Report all files in which unrecoverable operations\n";
   $RunBlock    .= "# operations have taken place since the last backup.\n";
   $RunBlock    .= "#-----------------------------------------------------\n";
   $RunBlock    .= "run {\n";
   $RunBlock    .= "  SET COMMAND ID TO 'RMAN:REPORT UNRECOVERABLE';\n\n";

   # Allocate Channel(s)
   # ----------------------
   $RunBlock    .= "  # Allocate Channel(s)\n";
   $i=0;
   until ($i >= $Channels) {
      $i ++;
      $RunBlock .= "  ALLOCATE CHANNEL " . $BackupDevice . $i  . " DEVICE TYPE " . $BackupDevice . $ChannelConnStr;
      $RunBlock .= "\n   FORMAT $BackupFormat;\n\n"                                  if ($BackupFormat ne '');
      $RunBlock .= ";\n"                                                             if ($BackupFormat eq '');
   }
   $RunBlock    .= "\n"                                                              if ($BackupFormat eq '');
   $RunBlock    .= "  REPORT UNRECOVERABLE DEVICE TYPE " . $BackupDevice . ";\n\n";

   # Release Channel(s)
   # ---------------------
   $RunBlock    .= "  # Release Channel(s)\n";
   $i=0;
   until ($i >= $Channels) {
      $i ++;
      $RunBlock .= "  RELEASE CHANNEL " . $BackupDevice . $i . ";\n";
   }
   $RunBlock    .= "}\n";

   if ($Trace eq 'true') {
      print "TRACE: Exiting sub ReportUnrecoverable()\n";
      print "TRACE: Returning: \$RunBlock=$RunBlock\n";
   }
   return;
}
# ------------------------------------------------------------------------
# End ReportUnreoverable()
# ------------------------------------------------------------------------


# Sub : ReportObsolete()
# Desc: Build the RMAN Run Block for checking for obsolete backup pieces.
# Args: <none>
# Retn: RMAN runblock.
# ------------------------------------------------------------------------
sub ReportObsolete() {
   if ($Trace eq 'true') {
      print "TRACE: Entering sub ReportObsolete()\n";
      print "TRACE: Parameters: none\n";
   }

   $RunBlock    .= "#--------------------------------------------------------------\n";
   $RunBlock    .= "# Report backup sets no longer needed to meet retention specs.\n";
   $RunBlock    .= "#--------------------------------------------------------------\n";
   $RunBlock    .= "run {\n";
   $RunBlock    .= "  SET COMMAND ID TO 'RMAN:REPORT OBSOLETE';\n\n";

   # Allocate Channel(s)
   # ----------------------
   $RunBlock    .= "  # Allocate Channel(s)\n";
   $i=0;
   until ($i >= $Channels) {
      $i ++;
      $RunBlock .= "  ALLOCATE CHANNEL " . $BackupDevice . $i  . " DEVICE TYPE " . $BackupDevice . $ChannelConnStr;
      $RunBlock .= "\n   FORMAT $BackupFormat;\n\n"                                  if ($BackupFormat ne '');
      $RunBlock .= ";\n"                                                             if ($BackupFormat eq '');
   }
   $RunBlock    .= "\n"                                                              if ($BackupFormat eq '');
   $RunBlock    .= "  REPORT OBSOLETE DEVICE TYPE " . $BackupDevice . ";\n\n";

   # Release Channel(s)
   # ---------------------
   $RunBlock    .= "  # Release Channel(s)\n";
   $i=0;
   until ($i >= $Channels) {
      $i ++;
      $RunBlock .= "  RELEASE CHANNEL " . $BackupDevice . $i . ";\n";
   }
   $RunBlock    .= "}\n";

   if ($Trace eq 'true') {
      print "TRACE: Exiting sub ReportObsolete()\n";
      print "TRACE: Returning: \$RunBlock=$RunBlock\n";
   }
   return;
}
# ------------------------------------------------------------------------
# End ReportObsolete()
# ------------------------------------------------------------------------


# Sub : ListExpired()
# Desc: Build the RMAN Run Block for checking for expired backup pieces.
# Args: <none>
# Retn: RMAN runblock.
# ------------------------------------------------------------------------
sub ListExpired() {
   if ($Trace eq 'true') {
      print "TRACE: Entering sub ListExpired()\n";
      print "TRACE: Parameters: none\n";
   }

   $RunBlock .= "#---------------------------------------------\n";
   $RunBlock .= "# Report backupsets for which backup files\n";
   $RunBlock .= "# can no longer found on backup media.\n";
   $RunBlock .= "#---------------------------------------------\n\n";
   $RunBlock .= "SET COMMAND ID TO 'RMAN:LIST EXPIRED';\n";
   $RunBlock .= "LIST EXPIRED BACKUP DEVICE TYPE " . $BackupDevice . ";\n";
   $RunBlock .= "LIST EXPIRED BACKUPSET DEVICE TYPE " . $BackupDevice . ";\n";
   $RunBlock .= "LIST EXPIRED COPY;\n";
   $RunBlock .= "LIST EXPIRED ARCHIVELOG ALL;\n";
   if ($Trace eq 'true') {
      print "TRACE: Exiting sub ListExpired()\n";
      print "TRACE: Returning: \$RunBlock=$RunBlock\n";
   }
   return;
}
# ------------------------------------------------------------------------
# End ListExpired()
# ------------------------------------------------------------------------


# Sub : RunSqlplus($$;$)
# Desc: Execute a Sqlplus script.
# Args: 1=SQL*Net connect string
#       2=SQL text to run.
#       3=Check for errors flag (optional)
# Retn: 0=Success, >0=failure -- return code from sqlplus session.
# ------------------------------------------------------------------------
sub RunSqlplus($$;$) {
   my $ConnectString = shift;
   my $SqlText       = shift;
   my $ErrChk        = shift;
   my $SqlFileName   = "$ENV{DIXIE_TMP}/$CmdName.sql.$$";
   my $rc = 0;

   if ($Trace eq 'true') {
      print "TRACE: Entering sub RunSqlplus(\$\$)\n";
      print "TRACE: Parameters:\n";
      print "TRACE:    \$ConnectString = $ConnectString\n";
      print "TRACE:    \$SqlText       = $SqlText      \n";
      print "TRACE: Other:\n";
      print "TRACE:    $SqlFileName = $SqlFileName\n";
   }

   open (SQL_FILE, ">", $SqlFileName) or do {
      PrintError("Unable to open file $SqlFileName");
      if ($Trace eq 'true') {
         print "TRACE: Exiting sub RunSqlplus(\$\$)\n";
         print "TRACE: Returning: 1\n";
      }
      return 1;
   };

   print SQL_FILE "connect $ConnectString\n";
   print SQL_FILE "set linesize 10000\n";
   print SQL_FILE "set pagesize 0\n";
   print SQL_FILE "set feedback off\n";
   print SQL_FILE "set echo off\n";
   print SQL_FILE "set head off\n";
   print SQL_FILE "$SqlText\n";
   print SQL_FILE "exit\n";

   close(SQL_FILE);

   my $SqlOut    = `$Sqlplus \@$SqlFileName`;
   my $SqlplusRC = $?;
   unlink "$SqlFileName";

   if ($ErrChk) {
      my ($rc, @ErrorStack) = ErrorCheck($SqlOut);
      if ($rc) {
         my $ErrorMsg;
         foreach my $line (@ErrorStack) {
            $ErrorMsg .= "$line\n";
         }
         PrintError($ErrorMsg);
         if ($Trace eq 'true') {
            print "TRACE: Exiting sub RunSqlplus(\$\$)\n";
            print "TRACE: Returning: \$rc = $rc\n";
         }
         return $rc;
      }
      if ($Trace eq 'true') {
         print "TRACE: Exiting sub RunSqlplus(\$\$)\n";
         print "TRACE: Returning: \$rc     = $rc\n";
         print "TRACE:            \$SqlOut = $SqlOut\n";
      }
   }
   return $rc, $SqlOut;
}
# ------------------------------------------------------------------------
# End RunSqlplus()
# ------------------------------------------------------------------------


# Sub : Tnsping($)
# Desc: Tests TNS Name resolution for Service Name
# Args: 1:ServiceName
# Retn: 1:Host
#       2:Port
#       3:Sid
# ------------------------------------------------------------------------
sub Tnsping($) {
   my $ServiceName = shift;
   my $ErrType     = 0;
   my $Host        = '';
   my $Port        = '';
   my $Servce      = '';

   if ($Trace eq 'true') {
      print "TRACE: Entering sub Tnsping(\$)\n";
      print "TRACE: Parameters:\n";
      print "TRACE:    \$ServiceName = $ServiceName\n";
   }

   my $TnspingOut = `$Tnsping $ServiceName`;
   my $TnspingRC  = $?;
   my ($ErrType, @ErrorStack) = ErrorCheck($TnspingOut);
   if ($ErrType) {
      my $ErrorMsg;
      foreach my $line (@ErrorStack) {
         $ErrorMsg .= "$line\n";
      }
      PrintWarning($ErrorMsg);
   }
   if ($Trace eq 'true') {
      print "TRACE: Exiting sub Tnsping(\$)\n";
      print "TRACE: Returning: \$ErrType    = $rc\n";
      print "TRACE:            \$TnspingOut = $TnspingOut\n";
   }

   if ($TnspingOut =~ m/.*\(HOST = ([a-zA-Z0-9_\-\.]+)/i) {
      $Host = $1;
   }
   if ($TnspingOut =~ m/.*\(PORT = ([0-9]+)/i) {
      $Port = $1;
   }
   if ($TnspingOut =~ m/.*\(SERVICE_NAME = ([a-zA-Z0-9_\-\.]+)/i) {
      $Service = $1;
   }
   return($Host, $Port, $Service);
}
# ------------------------------------------------------------------------
# End Tnsping()
# ------------------------------------------------------------------------


# Sub : PrintError()
# Desc: Print an error message.
# Args: 1=Error message
# Retn: <none>
# ------------------------------------------------------------------------
sub PrintError($) {
    my $ErrorMsg = shift;

    print "\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n";
    foreach (split /\n/,$ErrorMsg) {
       chomp;
       print "ERROR: $_\n";
    }
    print ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n";
}
# ------------------------------------------------------------------------
# End PrintError()
# ------------------------------------------------------------------------


# Sub : PrintWarning()
# Desc: Print and email a program warning messages
# Args: 1=Error message
# Retn: <none>
# ------------------------------------------------------------------------
sub PrintWarning($) {
    my $WarningMsg  = shift;

    print "\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n";
    foreach (split /\n/,$WarningMsg) {
       chomp;
       print "WARNING: $_\n";
    }
    print ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n";
}
# ------------------------------------------------------------------------
# End PrintWarning()
# ------------------------------------------------------------------------


# Sub : ShowDate($)
# Desc: Emulate the "date" comand in UNIX
# Args: 1=The date format to be returned:
#         - LONG_DATE_TIME
#         - LONG_DATE_TIME2
#         - LONG_TIME
#         - LONG_TIME2
#         - RECOVER_DB
#         - LONG_DATE
#         - SHORT_DATE
#         - SHORT_DATE_TIME
#         - SHORT_TIME
# Retn: Date/Time in the format requested.
# ------------------------------------------------------------------------
sub ShowDate($) {
   my $sec  = $min  = $hour = $mday  = $mon = '';
   my $year = $wday = $yday = $isdst = '';

   return(scalar(localtime)) if (scalar(@_) == 0);

   return time() if ($_[0] eq 'EPOCH');

   ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime;
   $year += 1900;
   $mon++ ;
   if ($mday < 10) { $mday = "0$mday" }
   if ($mon  < 10) { $mon  = "0$mon"  }
   if ($hour < 10) { $hour = "0$hour" }
   if ($min  < 10) { $min  = "0$min"  }
   if ($sec  < 10) { $sec  = "0$sec"  }

   if ($_[0] eq 'LONG_DATE_TIME') {
      return "$mon/$mday/$year $hour:$min:$sec";
   } elsif ($_[0] eq 'LONG_DATE_TIME2') {
      return "$year$mon${mday}_$hour$min$sec";
   } elsif ($_[0] eq 'LONG_TIME') {
      return "$hour:$min:$sec";
   } elsif ($_[0] eq 'LONG_TIME2') {
      return "$hour$min$sec";
   } elsif ($_[0] eq 'RECOVER_DB') {
      return "$year-$mon-$mday:$hour:$min:$sec";
   } elsif ($_[0] eq 'LONG_DATE') {
      return "$mon/$mday/$year";
   } elsif ($_[0] eq 'SHORT_DATE') {
      return "$year$mon$mday";
   } elsif ($_[0] eq 'SHORT_DATE_TIME') {
      return "$year$mon${mday}_$hour$min$sec";
   } elsif ($_[0] eq 'SHORT_TIME') {
      return "$hour$min";
   } else {
      return (scalar(localtime));
   }
}

# Sub : GetDbVersion($)
# Desc: Determine the Oracle RDBMS version
# Args: 1=Database connect string
# Retn: 1=-1 if failure. Oracle version otherwise.
# ------------------------------------------------------------------------
sub GetDbVersion($) {
   my $ConnectString = shift;

   if ($Trace eq 'true') {
      print "TRACE: Entering sub GetDbVersion(\$)\n";
      print "TRACE: Parameters:\n";
      print "TRACE:    \$ConnectString = $ConnectString\n";
   }

   my $rc     = 0;
   my $SqlOut = '';
   my $ShortDbVer = '';
   my $LongDbVer = '';

   ($rc, $SqlOut) = RunSqlplus($ConnectString, "select banner from v\$version where banner like 'Oracle%';", $ErrChk);
   foreach (split /\n/,$SqlOut) {
      if (m/^(Oracle.*Release )([\d]+)(\.)([\d+\.]+)/s) {   # Oracle Database 11g Enterprise Edition Release 11.2.0.3.0 - 64bit
         my $VerPrefix = $2;                     # 8 | 9 | 10 | 11
         $LongDbVer = "$VerPrefix.$4";
         (my $VerSuffix = $4) =~ s/\.//g;        # ie. 2.0.2.0 -> 2020
         $ShortDbVer = "$VerPrefix.$VerSuffix";
         last;
      }
   }

   if ($ShortDbVer !~ m/^[\d]+\.[\d]+$/i) {
      PrintError('Unable to detect Oracle version');
      if ($Trace eq 'true') {
         print "TRACE: Exiting sub GetDbVersion(\$)\n";
         print "TRACE: Returning: 1\n";
      }
      return 1;
   }

   if ($Trace eq 'true') {
      print "TRACE: Exiting sub GetDbVersion(\$)\n";
      print "TRACE: Returning: \$rc         = $rc\n";
      print "TRACE:            \$LongDbVer = $LongDbVer\n";
   }
   return $rc, $LongDbVer;
}
# ------------------------------------------------------------------------
# End GetDbVersion()
# ------------------------------------------------------------------------


# Sub : GetBinVersion()
# Desc: Get the version returned by sqlplus -V
# Args: <none>
# Retn: 1=-1 if failure. Oracle version otherwise.
# ------------------------------------------------------------------------
sub GetBinVersion() {
   if ($Trace eq 'true') {
      print "TRACE: Entering sub GetBinVersion(\$)\n";
      print "TRACE: Parameters: none\n";
   }

   my $rc         = 0;
   my $SqlOut     = '';
   my $LongBinVer = '';

   $SqlOut = `$ENV{ORACLE_HOME}/bin/sqlplus -V`;
   $rc = $?;

   foreach (split /\n/,$SqlOut) {
      # SQL*Plus: Release 11.2.0.3.0 - Production
      # --------------------------------------------
      if (m/^(SQL\*Plus: Release )([\d]+)(\.)([\d+\.]+)/s) {
         my $VerPrefix = $2;
         $LongBinVer = "$VerPrefix.$4";
         last;
      }
   }

   if ($Trace eq 'true') {
      print "TRACE: Exiting sub GetBinVersion(\$)\n";
      print "TRACE: Returning: \$rc         = $rc\n";
      print "TRACE:            \$LongBinVer = $LongBinVer\n";
   }
   return $rc, $LongBinVer;
}
# ------------------------------------------------------------------------
# End GetBinVersion()
# ------------------------------------------------------------------------


# Sub : SetOracleEnv($)
# Desc: Make sure database has a valid oratab entry
# Args: 1=The ORACLE_SID to validate
# Retn: 0 for success, >1 failure
# ------------------------------------------------------------------------
sub SetOracleEnv($) {
   my $OraSid = shift;

   if ($Trace eq 'true') {
      print "TRACE: Entering sub SetOracleEnv(\$)\n";
      print "TRACE: Parameters:\n";
      print "TRACE:    \$OraSid = $OraSid\n";
   }

   # Before we can proceed we need $OraSid and the ORACLE_SID
   # environment variable to be set (using oraenv)
   # -------------------------------------------------------------
   if (not $OraSid) {
      if ($ENV{ORACLE_SID} eq '') {
         PrintError("You must specify an ORACLE_SID with the -(si)d option or export ORACLE_SID.");
         if ($Trace eq 'true') {
            print "TRACE: Exiting sub SetOracleEnv(\$)\n";
            print "TRACE: Returning: 1\n";
         }
         return 1;
      } else {
         $OraSid = $ENV{ORACLE_SID};
      }
   }

   my $tmpSid;
   my $tmpHome;
   my $ORATAB;

   # Locate the oratab file.
   # --------------------------
   if ( -r '/etc/oratab') {
      $ORATAB = '/etc/oratab';
   } elsif ( -r '/var/opt/oracle/oratab') {
      $ORATAB = '/var/opt/oracle/oratab';
   }

   if (! defined($ORATAB)) {
      PrintError('Unable to find a readable oratab file in /etc or /var/opt/oracle.');
      if ($Trace eq 'true') {
         print "TRACE: Exiting sub SetOracleEnv(\$)\n";
         print "TRACE: Returning: 1\n";
      }
      return 1;
   } else {
      # Load the oratab file.
      # ------------------------
      if (! open (ORATAB, "<", $ORATAB)) {
         PrintError("Unable to open oratab file: $ORATAB\n");
         return 1;
      }

      my @Oratab = ();
      my $FoundFirstEntry = 0;
      while (my $Line = <ORATAB>) {
         chomp($Line);
         next if $Line =~ /^\s*$/;  # skip blank lines
         next if $Line =~ /^\s*\#/; # skip comment lines
         next if $Line =~ /^\s*\*/; # skip comment lines

         print "TRACE: \$Line=$Line\n"     if ($Trace eq 'true');
         print "TRACE: \$OraSid=$OraSid\n" if ($Trace eq 'true');

         if ($Line =~ m/^($OraSid):([\S]+):[Y,N,y,n].*$/) {
            $tmpSid  = $1;
            $tmpHome = $2;
         } else {
            next;
         }
      }
      close(ORATAB);

      if ($Trace eq 'true') {
          print "TRACE: \$tmpSid  = $tmpSid\n";
          print "TRACE: \$tmpHome = $tmpHome\n";
      }

      if ($tmpHome eq '') {
         PrintError("Invalid or missing entry for \[$OraSid\] in $ORATAB file.");
         return 1;
      } else {
         $ENV{ORACLE_SID}  = $tmpSid;
         $ENV{ORACLE_HOME} = $tmpHome;
         use Env 'ORACLE_SID';
         use Env 'ORACLE_HOME';

         if ($Trace eq 'true') {
           print "TRACE: ORACLE_SID  = " . $ENV{ORACLE_SID}  . "\n";
           print "TRACE: ORACLE_HOME = " . $ENV{ORACLE_HOME} . "\n";
         }

         # What version of the database binaries are we using (Sqlplus -V)
         # -----------------------------------------------------------------
         (my $RC, $BinVersion) = GetBinVersion;
         if ($RC) {
            PrintError("Error occured in call to sqlplus.");
            exit $RC;
         }

         # If 11g >
         # --------------
         use Env 'ORA_NLS10';
         use Env 'PATH';

         $ENV{PATH}   = "$ORACLE_HOME/bin:$PATH:.";
         $ENV{ORATAB} = $ORATAB;

         if ($Trace eq 'true') {
            print "TRACE: \$ORACLE_SID         = $ORACLE_SID         \n";
            print "TRACE: \$ORACLE_HOME        = $ORACLE_HOME        \n";
            print "TRACE: \$ORA_NLS10          = $ORA_NLS10          \n";
            print "TRACE: \$PATH               = $PATH               \n";
         }
      }
   }

   if ( ! defined $ENV{ORACLE_HOME}) {
      PrintError("\$ORACLE_HOME is undefined");
      if ($Trace eq 'true') {
         print "TRACE: Exiting sub SetOracleEnv(\$)\n";
         print "TRACE: Returning: 1\n";
      }
      return 1;
   }

   $Rman    = "$ENV{ORACLE_HOME}/bin/rman"               if (-x "$ENV{ORACLE_HOME}/bin/rman");
   $Sqlplus = "$ENV{ORACLE_HOME}/bin/sqlplus -s /nolog"  if (-x "$ENV{ORACLE_HOME}/bin/sqlplus");
   $Tnsping = "$ENV{ORACLE_HOME}/bin/tnsping"            if (-x "$ENV{ORACLE_HOME}/bin/tnsping");

   if ($Rman eq '') {
      PrintError("Unable to locate rman in $ENV{ORACLE_HOME}/bin");
      if ($Trace eq 'true') {
         print "TRACE: Exiting sub SetOracleEnv(\$)\n";
         print "TRACE: Returning: 2\n";
      }
      return 2;
   }

   if ($Sqlplus eq '') {
      PrintError("Unable to locate sqlplus in $ENV{ORACLE_HOME}/bin");
      if ($Trace eq 'true') {
         print "TRACE: Exiting sub SetOracleEnv(\$)\n";
         print "TRACE: Returning: 2\n";
      }
      return 2;
   }

   if ($Tnsping eq '') {
      PrintError("Unable to locate tnsping in $ENV{ORACLE_HOME}/bin");
      if ($Trace eq 'true') {
         print "TRACE: Exiting sub SetOracleEnv(\$)\n";
         print "TRACE: Returning: 2\n";
      }
      return 2;
   }

   if ($Trace eq 'true') {
      print "TRACE: Exiting sub SetOracleEnv(\$)\n";
      print "TRACE: Returning: 0\n";
   }
   return 0;
}
# ------------------------------------------------------------------------
# End SetOracleEnv
# ------------------------------------------------------------------------


# Sub : WriteNewFile($$)
# Desc: Create file and write a string into it
# Args: 1=The file name to create
#       2=The file contents
# Retn: 1=0 for success, >1 failure
# ------------------------------------------------------------------------
sub WriteNewFile($$) {
   my $OutFile  = shift;
   my $WriteStr = shift;

   if ($Trace eq 'true') {
      print "TRACE: Entering sub WriteNewFile(\$)\n";
      print "TRACE: Parameters:\n";
      print "TRACE:    \$OutFile  = $OutFile \n";
      print "TRACE:    \$WriteStr = $WriteStr\n";
   }

   my $CreateFile = 'Y';
   if (scalar(@_) == 3) {
      if (uc($_[2]) eq 'NOCR') {
         $CreateFile = 'N';
      }
   }

   if ( -e "$OutFile") {
      if ( ! -w "$OutFile") {
         PrintError("Cannot write to file $OutFile");
         return 1;
      }
   } elsif (( ! -e  File::Basename::dirname("$OutFile")) or ( ! -w File::Basename::dirname("$OutFile"))) {
      PrintError("Error writing to $OutFile, directory may not exist or have write access enabled.");
      if ($Trace eq 'true') {
         print "TRACE: Exiting sub WriteNewFile(\$)\n";
         print "TRACE: Returning: 1\n";
      }
      return 1;
   }

   open (CREATE_FILE, ">", $OutFile) or do {
      PrintError("Unable to open(file) for write: $OutFile");
      if ($Trace eq 'true') {
         print "TRACE: Exiting sub WriteNewFile(\$)\n";
         print "TRACE: Returning: 1\n";
      }
      return 1;
   };

   if ($CreateFile eq 'Y') {
      print CREATE_FILE "$WriteStr\n";
   } else {
      print CREATE_FILE "$WriteStr";
   }

   close(CREATE_FILE);
   if ($Trace eq 'true') {
      print "TRACE: Exiting sub WriteNewFile(\$)\n";
      print "TRACE: Returning: 0\n";
   }
   return 0;
}
# ------------------------------------------------------------------------
# WriteNewFile()
# ------------------------------------------------------------------------


# Sub : GetInstState()
# Desc: Get the current state of the database (down, mounted, open)
# Args: 1=Database connect string
# Retn: 1=DOWN, STARTED, MOUNTED, OPEN
# ------------------------------------------------------------------------
sub GetInstState($) {
   my $ConnectString = shift;
   my $DbState       = 'DOWN';
   my $rc            = 0;
   my @ErrorStack    = ();

   if ($Trace eq 'true') {
      print "TRACE: Entering sub GetInstState(\$)\n";
      print "TRACE: Parameters:\n";
      print "TRACE:    \$ConnectString = $ConnectString\n";
   }

   my $SqlQuery  = "connect $ConnectString\n";
      $SqlQuery .= "set pagesize 0\n";
      $SqlQuery .= "set feedback off\n";
      $SqlQuery .= "select 'DB_STATUS:' || upper(status) from v\$instance;\n";
      $SqlQuery .= "exit\n";

   (my $rc, my $SqlOut) = RunSqlplus($ConnectString,$SqlQuery);
   if ($SqlOut =~ m/ORA-01034.*/) {
      return($rc, 'DOWN');
   } else {
      foreach my $Line (split('\n',$SqlOut)) {
         if ($Line =~ m/^DB_STATUS:/) {
            ($junk, $DbState) = split(':', $Line);
            TrimString($DbState);
            last;
         } else {
            next;
         }
      }
   }
   if ($Trace eq 'true') {
      print "TRACE: Exiting sub GetInstState(\$)\n";
      print "TRACE: Returning: \$DbState = $DbState\n";
   }
   return($rc, $DbState);
}
# ------------------------------------------------------------------------
# End GetInstState()
# ------------------------------------------------------------------------


# Sub : GetDbInfo()
# Desc: Get information about the the database from v$database
# Args: 1=Database connect string
# Retn: 1: return code, 2: DbName, 3: DbUniqueName, 4: Open Mode,
#       5: DbRole, 6: SwitchoverStatus
# ------------------------------------------------------------------------
sub GetDbInfo($) {
   my $ConnectString = shift;

   my $DbName;
   my $DbUniqueName;
   my $DbOpenMode;
   my $PrimaryDbUniqueName;
   my $DbRole;
   my $DbSwitchoverStatus;
   my $DbRecoveryDest;
   my $DbRecoveryDestSize;
   my $ClusterDatabase;

   my $SqlQuery  = "select 'DB_NAME:'                 || name                          from v\$database;\n";
      $SqlQuery .= "select 'DB_UNIQUE_NAME:'          || db_unique_name                from v\$database;\n";
      $SqlQuery .= "select 'DBID:'                    || dbid                          from v\$database;\n";
      $SqlQuery .= "select 'OPEN_MODE:'               || upper(open_mode)              from v\$database;\n";
      $SqlQuery .= "select 'PRIMARY_DB_UNIQUE_NAME:'  || upper(primary_db_unique_name) from v\$database;\n";
      $SqlQuery .= "select 'DATABASE_ROLE:'           || upper(database_role)          from v\$database;\n";
      $SqlQuery .= "select 'SWITCHOVER_STATUS:'       || upper(switchover_status)      from v\$database;\n";
      $SqlQuery .= "SELECT 'RECOVERY_DEST:'           || value                         from v\$parameter where upper(name) = 'DB_RECOVERY_FILE_DEST';\n";
      $SqlQuery .= "SELECT 'RECOVERY_SIZE:'           || value                         from v\$parameter where upper(name) = 'DB_RECOVERY_FILE_DEST_SIZE';\n";
      $SqlQuery .= "SELECT 'CLUSTER_DATABASE:'        || decode(UPPER(PARALLEL), 'YES', 'true', 'NO', 'false', '') from v\$instance;\n";
      $SqlQuery .= "exit\n";

   if ($Trace eq 'true') {
      print "TRACE: Entering sub GetDbInfo(\$)\n";
      print "TRACE: Parameters:\n";
      print "TRACE:    \$ConnectString = $ConnectString\n";
      print "TRACE: SqlQuery:\n";
      print "TRACE:    $SqlQuery\n";
   }

   (my $rc, my $SqlOut) = RunSqlplus($ConnectString,$SqlQuery,$ErrChk);

   foreach my $Line (split('\n',$SqlOut)) {
      if ($Line =~ m/^DB_NAME:/) {
         ($junk, $DbName) = split(':', $Line);
         chomp($DbName);
      }
      if ($Line =~ m/^DB_UNIQUE_NAME:/) {
         ($junk, $DbUniqueName) = split(':', $Line);
         chomp($DbUniqueName);
      }
      if ($Line =~ m/^DBID:/) {
         ($junk, $DbId) = split(':', $Line);
         chomp($DbId);
      }
      if ($Line =~ m/^OPEN_MODE:/) {
         ($junk, $DbOpenMode) = split(':', $Line);
         chomp($DbOpenMode);
      }
      if ($Line =~ m/^PRIMARY_DB_UNIQUE_NAME:/) {
         ($junk, $PrimaryDbUniqueName) = split(':', $Line);
         chomp($PrimaryDbUniqueName);
      }
      if ($Line =~ m/^DATABASE_ROLE:/) {
         ($junk, $DbRole) = split(':', $Line);
         chomp($DbRole);
      }
      if ($Line =~ m/^SWITCHOVER_STATUS:/) {
         ($junk, $DbSwitchoverStatus) = split(':', $Line);
         chomp($DbSwitchoverStatus);
      }
      if ($Line =~ m/^RECOVERY_DEST:/) {
         ($junk, $DbRecoveryDest) = split(':', $Line);
         chomp($DbRecoveryDest);
      }
      if ($Line =~ m/^RECOVERY_SIZE:/) {
         ($junk, $DbRecoveryDestSize) = split(':', $Line);
         chomp($DbRecoveryDestSize);
      }
      if ($Line =~ m/^CLUSTER_DATABASE:/) {
         ($junk, $ClusterDatabase) = split(':', $Line);
         chomp($ClusterDatabase);
      }
   }
   if ($Trace eq 'true') {
      print "TRACE: Exiting sub GetDbInfo(\$)\n";
      print "TRACE: Returning: \$rc                  : $rc\n";
      print "TRACE:            \$DbName              : $DbName\n";
      print "TRACE:            \$DbUniqueName        : $DbUniqueName\n";
      print "TRACE:            \$DbOpenMode          : $DbOpenMode\n";
      print "TRACE:            \$PrimaryDbUniqueName : $PrimaryDbUniqueName\n";
      print "TRACE:            \$DbRole              : $DbRole\n";
      print "TRACE:            \$DbSwitchoverStatus  : $DbSwitchoverStatus\n";
      print "TRACE:            \$DbRecoveryDest      : $DbRecoveryDest\n";
      print "TRACE:            \$DbRecoveryDestSize  : $DbRecoveryDestSize\n";
      print "TRACE:            \$ClusterDatabase     : $ClusterDatabase\n";
   }
   return($rc, $DbName, $DbUniqueName, $DbId, $DbOpenMode, $PrimaryDbUniqueName, $DbRole, $DbSwitchoverStatus, $DbRecoveryDest, $DbRecoveryDestSize, $ClusterDatabase);
}
# ------------------------------------------------------------------------
# End GetDbInfo()
# ------------------------------------------------------------------------


# Sub : GetInstSvcCount()
# Desc: Get information about the the database from v$database
# Args: 1: Connect string
#       2: Service name
# Retn: 1: # of instances advertising the service name (active instances).
# ------------------------------------------------------------------------
sub GetInstSvcCount($$) {
   my $ConnectString   = shift;
   my $ServiceName     = shift;
   my $ActiveInstances = 0;
   my $SqlQuery        = '';

   if ($Trace eq 'true') {
      print "TRACE: Entering sub GetInstSvcCount(\$\$)\n";
      print "TRACE: Parameters:\n";
      print "TRACE:    \$ConnectString = $ConnectString\n";
      print "TRACE:    \$ServiceName   = $ServiceName\n";
   }

   if ($BinVersion >= 12) {
      if ($InstCount > 1) {
         $SqlQuery  = "SELECT 'INST_COUNT:' || count(*) from gv\$active_services where upper(name) = '" . $ServiceName . "';\n";
      } else {
         $SqlQuery  = "SELECT 'INST_COUNT:' || count(*) from v\$active_services where upper(name) = '" . $ServiceName . "';\n";
      }

      $SqlQuery .= "exit\n";
      (my $rc, my $SqlOut) = RunSqlplus($ConnectString,$SqlQuery,$ErrChk);

      foreach my $Line (split('\n',$SqlOut)) {
         if ($Line =~ m/^INST_COUNT:/) {
            ($junk, $ActiveInstances) = split(':', $Line);
         }
      }
   } else {
      if ($InstCount > 1) {
         $SqlQuery  = "SELECT 'SERVICE_NAMES:' || inst_id || ':' || value from gv\$parameter where upper(name) = 'SERVICE_NAMES';\n";
      } else {
         $SqlQuery  = "SELECT 'SERVICE_NAMES:' || '1'     || ':' || value from v\$parameter where upper(name) = 'SERVICE_NAMES';\n";
      }

      $SqlQuery .= "exit\n";
      (my $rc, my $SqlOut) = RunSqlplus($ConnectString,$SqlQuery,$ErrChk);

      foreach my $Line (split('\n',$SqlOut)) {
         if ($Line =~ m/^SERVICE_NAMES:/) {
            ($junk, $InstId, $ServiceList) = split(':', $Line);
            @ServiceList = split(',', $ServiceList);

            # Find the $TargetService in the list of services
            # advertised by the instance.
            # --------------------------------------------------
            foreach my $Service (@ServiceList) {
               TrimString($Service);
               # if ($Service eq uc($ServiceName)) {      <- Uncomment if you want to force service names to upper case.
               if ($Service eq $ServiceName) {
                  $ActiveInstances += 1;
               }
            }
         }
      }
      if ($Trace eq 'true') {
         print "TRACE: Exiting sub GetDbInfo(\$)\n";
         print "TRACE: Returning: \$ActiveInstances : $ActiveInstances\n";
      }
   }
   return($rc, $ActiveInstances);
}
# ------------------------------------------------------------------------
# End GetInstSvcCount()
# ------------------------------------------------------------------------


# Sub : CountInstances()
# Desc: Check to see how many clustered (RAC) instances are started.
# Args: 1=Database connect string
# Retn: 1=nnn - the count of active instances found
# ------------------------------------------------------------------------
sub CountInstances($) {
   my $ConnectString = shift;

   if ($Trace eq 'true') {
      print "TRACE: Entering sub CountInstances(\$)\n";
      print "TRACE: Parameters:\n";
      print "TRACE:    \$ConnectString= $ConnectString\n";
   }

   my $InstCount;
   my $rc;
   my $SqlOut;

   ($rc, $SqlOut) = RunSqlplus($ConnectString,"select 'INSTANCES:' || count(*) from gv\$instance;",$ErrChk);

   if ($rc) {
      PrintError("Cannot determine the number of active instances.\n");
   }

   if ($SqlOut =~ m/^(INSTANCES:)(\d).*$/im) {
      chomp($InstCount = $2);
   }

   if ($Trace eq 'true') {
      print "TRACE: Exiting sub CountInstances(\$)\n";
      print "TRACE: Returning: \$rc            = $rc\n";
      print "TRACE:            \$InstCount = $InstCount\n";
   }
   return $rc, $InstCount;
}
# ------------------------------------------------------------------------
# End CountInstances()
# ------------------------------------------------------------------------


# Sub : GenerateScript($$$$)
# Desc: Generate an RMAN script
# Args: 1=Service name for the target database
#       2=Rman run{} block
#       3=Connect string for target database
#       4=Connect string for the rman catalog
# Retn: <none>
# ------------------------------------------------------------------------
sub GenerateScript($$$$) {
   my $TargetSid      = shift;
   my $RunBlock       = shift;
   my $TargetConnStr  = shift;
   my $CatConnStr     = shift;

   if ($Trace eq 'true') {
      print "TRACE: Entering sub GenerateScript(\$\$\$\$)\n";
      print "TRACE: Parameters:\n";
      print "TRACE:    \$TargetSid     = $TargetSid    \n";
      print "TRACE:    \$RunBlock      = $RunBlock     \n";
      print "TRACE:    \$TargetConnStr = $TargetConnStr\n";
      print "TRACE:    \$CatConnStr    = $CatConnStr   \n";
      print "TRACE:    \$RmanScript    = $RmanScript   \n";

   }

   # Name the Rman script file
   # ---------------------------
   if (($OperType eq 'database') or ($OperType eq 'datafile') or ($OperType eq 'tablespace')) {
      $RmanScript = $ENV{DIXIE_SCRIPTS} . '/' . $TargetSid . '_' . uc($TagLevel) . '_' . uc($OperType) . '_' . $BackupDevice . '.rcv';
   } else {
      $RmanScript = $ENV{DIXIE_SCRIPTS} . '/' . $TargetSid. '_'  . uc($OperType) . '_' . $BackupDevice . '.rcv';
   }

   unlink $RmanScript if (-f $RmanScript);
   print "   -Generating Script................ [" . basename($RmanScript) . "]\n";

   $ShortName = basename($RmanScript);

   my $NoCatStr = 'nocatalog' if ($CatConnStr eq '');
   my $ScriptContent = "#==============================================================================\n";
   $ScriptContent   .= "# Script Name : $ShortName\n";
   $ScriptContent   .= "# Description : $cmdDesc\n";
   $ScriptContent   .= "# Use         : rman $NoCatStr cmdfile $ShortName\n";
   $ScriptContent   .= "# Hist        : Generated by $CmdName " . ShowDate('LONG_DATE') . "\n";
   $ScriptContent   .= "#==============================================================================\n\n";
   $ScriptContent   .= "connect target $TargetConnStr\n\n";
   $ScriptContent   .= "connect catalog $CatalogConnStr\n\n" if ($CatConnStr ne '');
   $ScriptContent   .= $RunBlock;
   $ScriptContent   .= "\n#==============================================================================\n";

   # Write the file and set permissions.
   # -------------------------------------
   WriteNewFile($RmanScript, $ScriptContent);
   chmod 0640, "$RmanScript";
   if ($Trace eq 'true') {
      print "TRACE: Exiting sub GenerateScript(\$\$\$\$)\n";
   }
}
# ------------------------------------------------------------------------
# End GenerateScript()
# ------------------------------------------------------------------------


# Sub : RunRmanScript($)
# Desc: Run an Oracle RMAN script
# Args: 1=The script to execute.
# Retn: 1=0 if successful, anythin else=fail.
# ------------------------------------------------------------------------
sub RunRmanScript($) {
   my $RmanScript = shift;

   if ($Trace eq 'true') {
      print "TRACE: Entering sub RunRmanScript(\$)\n";
      print "TRACE: Parameters:\n";
      print "TRACE:    \$RmanScript = $RmanScript\n";
   }

   if ($Debug eq 'true') {
      my $RmanOut = `$Rman cmdfile $RmanScript log=$RmanLog APPEND DEBUG 2>&1`;
   } else {
      my $RmanOut = `$Rman cmdfile $RmanScript log=$RmanLog APPEND  2>&1`;
   }

   $RmanRC = $?;

   my ($rc, @ErrorStack) = ErrorCheck($RmanLog);
   if ($rc >= 2) {
      my $ErrorMsg;
      foreach my $line (@ErrorStack) {
         $ErrorMsg .= "$line\n";
      }
      PrintError($ErrorMsg);
      if ($Trace eq 'true') {
         print "TRACE: Exiting sub RunRmanScript(\$)\n";
         print "TRACE: Returning: \$rc = $rc\n";
      }
      return $rc;
   }
   if ($Trace eq 'true') {
      print "TRACE: Exiting sub RunRmanScript(\$)\n";
      print "TRACE: Returning: \$RmanRC = $RmanRC\n";
   }
   return $RmanRC;
}
# ------------------------------------------------------------------------
# End RuRmanScript()
# ------------------------------------------------------------------------


# Sub : ProcessOptions()
# Desc: Handle command line options. Merge config file options with
#       with command line options (if not using a parfile and not running
#       an external script).
# Args: None
# Retn: None
#------------------------------------------------------------------------
sub ProcessOptions() {
   $BackupDevice  = uc($CoBackupDevice);
   $OperType      = lc($CoOperType);
   $IncrLevel     = lc($CoIncrLevel);
   $MaxOpenFiles  = uc($CoMaxOpenFiles);
   $MaxPieceSize  = uc($CoMaxPieceSize);
   $MaxSetSize    = uc($CoMaxSetSize);
   $SectionSize   = uc($CoSectionSize);
   $StreamingRate = uc($CoStreamingRate);
   $Skip          = lc($CoSkip);
   $DeleteLogs    = lc($CoDeleteLogs);
   $ComprLevel    = lc($CoComprLevel);
   $ComprOptim    = lc($CoComprOptim);
   $Notify        = lc($CoNotify);

   # This section will be executed even if running an external rman script (-script option).
   # ------------------------------------------------------------------------------------------

   # Set Trace option
   # --------------------------
   if ($CoTrace) {
      $Trace = 'true';
   } else {
      if (($cfgHash{TRACE} eq 'true') or ($cfgHash{TRACE} eq 'false')) {
         $Trace = $cfgHash{TRACE};
      } else {
         $Trace = 'false';
      }
   }

   if ($Trace eq 'true') {
      print "TRACE: Entering sub ProcessOptions()\n";
      print "TRACE: Parameters: none\n";
   }

   if ($CoDistList) {
      $DistList = $CoDistList;
      $DistList =~ s/\s+//g;
      @DistList = split(',', uc($DistList));
      $DistList = join(', ', @DistList);
   } else {
      if (defined $cfgHash{DISTLIST}) {
         $DistList = $cfgHash{DISTLIST};
         $DistList =~ s/\s+//g;
         @DistList  = split(',', $DistList);
         $DistList = join(', ', @DistList);
      } else {
        $DistList = '';
      }
   }

   # Set External Script option
   # ----------------------------
   if ($CoExternalScript) {
      $ExternalScript = $CoExternalScript;
   } else {
      if (defined $cfgHash{SCRIPT}) {
         $ExternalScript = $cfgHash{SCRIPT};
      } else {
        $ExternalScript = '';
      }
   }

   # Set TnsAdmin option (sets the $TNS_ADMIN environment variable)
   # ----------------------------------------------------------------
   if ($CoTnsAdmin) {
      $TnsAdmin       = $CoTnsAdmin;
      $ENV{TNS_ADMIN} = $TnsAdmin;
   } else {
      if (defined $cfgHash{TNS_ADMIN}) {
         if ($cfgHash{TNS_ADMIN} eq '$ORACLE_HOME/network/admin') {
            $TnsAdmin       = $ENV{ORACLE_HOME} . '/network/admin';
            $ENV{TNS_ADMIN} = $TnsAdmin;
         } else {
            $TnsAdmin       = $cfgHash{TNS_ADMIN};
            $ENV{TNS_ADMIN} = $cfgHash{TNS_ADMIN};
         }
      } else {
         if (defined $ENV{TNS_ADMIN}) {
            $TnsAdmin = $ENV{TNS_ADMIN};
         } else {
          $TnsAdmin = '';
         }
      }
   }

   # Set LD_LIBRARY_PATH (sets the $LD_LIBRARY_PATH environment variable)
   # ----------------------------------------------------------------------
   undef $ENV{LD_LIBRARY_PATH};
   if (defined $cfgHash{LD_LIBRARY_PATH}) {
      $ENV{LD_LIBRARY_PATH} = $cfgHash{LD_LIBRARY_PATH};
   }

   # Set Rman CheckSyntax option
   # ------------------------------
   if ($CoCheckSyntax) {
      $CheckSyntax = 'true';
   } else {
      if (($cfgHash{CHECK_SYNTAX} eq 'true') or ($cfgHash{CHECK_SYNTAX} eq 'false')) {
         $CheckSyntax = $cfgHash{CHECK_SYNTAX};
      } else {
         $CheckSyntax = 'false';
      }
   }

   # Set Rman Debug option
   # -----------------------
   if ($CoDebug) {
      $Debug = 'true';
   } else {
      if (($cfgHash{DEBUG} eq 'true') or ($cfgHash{DEBUG} eq 'false')) {
         $Debug = $cfgHash{DEBUG};
      } else {
         $Debug = 'false';
      }
   }

   # Set $Show only.
   # ------------------------------
   if ($CoShow) {
      $Show = 'true';
   } else {
      if (($cfgHash{SHOW} eq 'true') or ($cfgHash{SHOW} eq 'false')) {
         $Show = $cfgHash{SHOW};
      } else {
         $Show = 'false';
      }
   }

   # Set Target Sid
   # ------------------
   if ($CoTargetSid) {
      $TargetSid = $CoTargetSid;
   } else {
      if (defined $cfgHash{ORACLE_SID}) {
         $TargetSid = $cfgHash{ORACLE_SID};
      } else {
         if (defined $ENV{ORACLE_SID}) {
            if (substr($ENV{ORACLE_SID}, 0,1) eq '+') {
               PrintError( "Invalid ORACLE_SID for database backup operations: $ENV{ORACLE_SID}");
               exit 1;
            } else {
               $TargetSid = $ENV{ORACLE_SID};
            }
         } else {
           $TargetSid = '';
         }
      }
   }

   # Set Target Service Name.
   # --------------------------
   if ($CoTargetService) {
      $TargetService = $CoTargetService;
   } else {
      if (defined $cfgHash{SERVICE_NAME}) {
         $TargetService = $cfgHash{SERVICE_NAME};
      } else {
        $TargetService = '';
      }
   }

   # Set Username.
   # ---------------
   if ($CoTargetUser) {
      $TargetUser = $CoTargetUser;
   } else {
      if ($cfgHash{USER} ne '') {
         $TargetUser = $cfgHash{USER};
      } else {
         $TargetUser = '';
      }
   }

   # Get the target database password.
   # ------------------------------------
   if ($TargetUser ne '') {
      if ($TargetService ne '') {
         $TargetPassword = GetPassword($TargetService, $TargetUser);
         if (not $TargetPassword) {
            PrintError("Password lookup failure for target database.\n   Service: $TargetService\n      User: $TargetUser\n");
            if ($Trace eq 'true') {
               print "TRACE: Exiting sub ProcessOptions()\n";
               print "TRACE: Exiting: 1\n";
            }
            exit 1;
         }
      } else {
         $TargetPassword = GetPassword($TargetSid, $TargetUser);
         if (not $TargetPassword) {
            PrintError("Password lookup failure for target database.\n   SID: $TargetSid\n  User: $TargetUser\n");
            if ($Trace eq 'true') {
               print "TRACE: Exiting sub ProcessOptions()\n";
               print "TRACE: Exiting: 1\n";
            }
            exit 1;
         }
      }
   }

   # Set the Sqlplus an RMAN connect string.
   # -----------------------------------------
   if (($TargetUser ne '') and ($TargetPassword ne '') and ($TargetService ne '')) {
      $ServiceConnStr      = $TargetUser . '/' . $TargetPassword . '@' . $TargetService . ' as sysdba';
      $PrintServiceConnStr = $TargetUser . '/<***>@' . $TargetService;
   }
   if ($Trace eq 'true') {
      print "TRACE: ServiceConnStr      = $ServiceConnStr\n";
      print "TRACE: PrintServiceConnStr = $PrintServiceConnStr\n";
   }

   # This section only gets executed when *NOT* running an external Rman script (-script option).
   # -------------------------------------------------------------------------------------------------
   if ($ExternalScript eq '') {

      # Set $Generate only.
      # ------------------------------
      if ($CoGenerate) {
         $Generate = 'true';
      } else {
         if (($cfgHash{GENERATE} eq 'true') or ($cfgHash{GENERATE} eq 'false')) {
            $Generate = $cfgHash{GENERATE};
         } else {
            $Generate = 'false';
         }
      }

      # Set Notification option
      # ------------------------------
      if ($CoNotify) {
         if (($CoNotify ne 'success') and ($CoNotify ne 'fail') and ($CoNotify ne 'off')) {
            PrintError("Invalid value for -notify option: $CoNotify\nValid values: 'success', 'fail', 'off'");
            exit 1;
         } else {
           $Notify = $CoNotify;
         }
      } elsif ($cfgHash{NOTIFY}) {
         if (($cfgHash{NOTIFY} ne 'success') and ($cfgHash{NOTIFY} ne 'fail') and ($cfgHash{NOTIFY} ne 'off')) {
            PrintError("Invalid value for notify option: $cfgHash{NOTIFY}\nValid values: 'success', 'fail', 'off'");
            exit 1;
         } else {
            $Notify = $cfgHash{NOTIFY};
         }
      } else {
         $Notify = 'fail';
      }

      # Set Retention
      # Valid values:
      #    REDUNDANCY nnn
      #    WINDOW OF nnn DAYS
      # -----------------------
      if ($CoRetention) {
         $Retention = $CoRetention;
      } else {
         if (defined $cfgHash{RETENTION}) {
            $Retention = uc($cfgHash{RETENTION});
         } else {
            $Retention = '';
         }
      }

      # Set Distributed Channels.
      # ----------------------------
      if ($CoDistChan) {
         $DistChan = 'true';
      } else {
         if (defined $cfgHash{DISTRIBUTED_CHANNELS}) {
            $DistChan = $cfgHash{DISTRIBUTED_CHANNELS};
         } else {
            $DistChan = 'false';
         }
      }

      # Set the channel connect string.
      # ----------------------------------
      if ($DistChan eq 'true') {
         if ($TargetService ne '') {
            if ($TargetUser ne '') {
              $ChannelConnStr = ' CONNECT ' . $TargetUser . '/' . $TargetPassword . '@' . $TargetService;
              $PrintChannelConnStr = $TargetUser . '/<***>@' . $TargetService . ' as sysdba';
            } else {
               PrintError "User option (-user) is required when using distributed channels option\n(-distchannels).";
               exit(1);
            }
         } else {
            PrintError "Service Name option (-servicename) is required when using distributed channels\noption (-distchannels).";
            exit(1);
         }
      } else {
         $ChannelConnStr = '';
         $PrintChannelConnStr = 'None';
      }

      # Validate Backup Type
      # ------------------------------
      if ($CoOperType) {
         $OperType = $CoOperType;
      } else {
         if (defined $cfgHash{BACKUP_TYPE}) {
            $OperType = $cfgHash{BACKUP_TYPE};
         } else {
            $ErrMsg  = "Backup type not selected. Backup type may be set using the command line option\n";
            $ErrMsg .= "-type or BACKUP_TYPE in the configuration or parameter files.";
            PrintError($ErrMsg);
            if ($Trace eq 'true') {
               print "TRACE: Exiting sub ProcessOptions()\n";
               print "TRACE: Exiting: 1\n";
            }
            exit 1;
         }
      }

      if (($OperType ne 'database')   and ($OperType ne 'validate_backup')  and ($OperType ne 'list_expired')         and
          ($OperType ne 'datafile')   and
          ($OperType ne 'tablespace') and ($OperType ne 'validate_restore') and ($OperType ne 'register')             and
          ($OperType ne 'fra')        and ($OperType ne 'report_schema')    and ($OperType ne 'report_need_backup')   and
          ($OperType ne 'arch')       and ($OperType ne 'delete_expired')   and ($OperType ne 'report_obsolete')      and
          ($OperType ne 'resync')     and ($OperType ne 'delete_obsolete')  and ($OperType ne 'report_unrecoverable') and
          ($OperType ne 'crosscheck')) {
         PrintError("Invalid backup type: $OperType");
         if ($Trace eq 'true') {
            print "TRACE: Exiting sub ProcessOptions()\n";
            print "TRACE: Exiting: 1\n";
         }
         exit 1;
      }

      if ($OperType ne 'datafile') {
        $DbfList = '';
      }

      if ($OperType ne 'tablespace') {
        $TbsList = '';
      }

      if ($OperType eq 'arch') {
         $ArchLogs = 'true';
      }

      # Set Backup Device option
      # ------------------------------
      if ($CoBackupDevice) {
         $BackupDevice = uc($CoBackupDevice);
      } else {
         if (defined $cfgHash{BACKUP_DEVICE}) {
            $BackupDevice = uc($cfgHash{BACKUP_DEVICE});
         } else {
            $BackupDevice = 'DISK';     # Default backup device is disk.
         }
      }

      # Convert tape device name to sbt.
      # ------------------------------
      if ($BackupDevice eq 'TAPE') {
         $BackupDevice = 'SBT';
      }

      if ($BackupDevice ne 'DISK' and $BackupDevice ne 'SBT') {
         PrintError("Invalid device type specified: $BackupDevice. Device must be of type DISK or SBT.");
         exit(1);
      }

      if ($ExternalScript eq '') {                             #  !!!!!!!!!!!!!!!! Need to remove this if statement???
         # Set DbfList (list of datafiles to backup).
         # ---------------------------------------------
         if ($CoDbfList) {
            $DbfList = $CoDbfList;
            $DbfList =~ s/\s+//g;
            @DbfList = split(',', uc($DbfList));
            $DbfList = join(', ', @DbfList);
         } else {
            if (defined $cfgHash{DATAFILES}) {
               $DbfList = $cfgHash{DATAFILES};
               $DbfList =~ s/\s+//g;
               @DbfList  = split(',', $DbfList);
               $DbfList = join(', ', @DbfList);
            } else {
              $DbfList = '';
            }
         }

         # Set TbsList (list of tablespaces to backup).
         # ---------------------------------------------
         if ($CoTbsList) {
            $TbsList = $CoTbsList;
            $TbsList =~ s/\s+//g;
            @TbsList = split(',', uc($TbsList));
            $TbsList = join(', ', @TbsList);
         } else {
            if (defined $cfgHash{TABLESPACES}) {
               $TbsList = $cfgHash{TABLESPACES};
               $TbsList =~ s/\s+//g;
               @TbsList  = split(',', $TbsList);
               $TbsList = join(', ', @TbsList);
            } else {
              $TbsList = '';
            }
         }

         # Set Delete Archive Logs option
         # ----------------------------------
         if ($CoDeleteLogs) {
            $DeleteLogs = 'true';
         } else {
            if (($cfgHash{DELETE_ARCHLOGS} eq 'true') or ($cfgHash{DELETE_ARCHLOGS} eq 'false')) {
               $DeleteLogs = $cfgHash{DELETE_ARCHLOGS};
            } else {
               $DeleteLogs = 'false';
            }
         }

         # Set Delete Delay option
         # -------------------------
         if ($CoDeleteDelay) {
            $DeleteDelay = $CoDeleteDelay;
         } else {
            $DeleteDelay = $cfgHash{DELETE_DELAY};
         }
         if ($DeleteDelay) {
            $ChkNumber = IsNumber($DeleteDelay);
            if ($ChkNumber) {
                $DeleteLogs = 'true';
            } else {
               PrintError("DELETE_DELAY option must be a whole number representing \"n\" days.");
               PrintError($ErrMsg);
               if ($Trace eq 'true') {
                  print "TRACE: Exiting sub ProcessOptions()\n";
                  print "TRACE: Exiting: 1\n";
               }
               exit 1
            }
         } else {
            undef $DeleteDelay;
         }

         # Set $PlusArchlogs Option
         # ---------------------------
         if ($CoPlusArchlogs) {
            $PlusArchlogs = 'true';
         } else {
            if (( $cfgHash{PLUS_ARCHLOGS} eq 'true' ) or ( $cfgHash{PLUS_ARCHLOGS} eq 'false' )) {
               $PlusArchlogs = $cfgHash{PLUS_ARCHLOGS};
            } else {
               $PlusArchlogs = 'false';
            }
         }

         # Set Backup Archive Logs option
         # ----------------------------------
         if ($CoArchLogs) {
            $ArchLogs = 'true';
         } else {
            if (($cfgHash{BACKUP_ARCHLOGS} eq 'true') or ($cfgHash{BACKUP_ARCHLOGS} eq 'false')) {
               $ArchLogs = $cfgHash{BACKUP_ARCHLOGS};
            } else {
               undef $ArchLogs;
            }
         }

         # Set # of archivelog backups option
         # ------------------------------------
         if ($CoArchCopies) {
            $ArchCopies = $CoArchCopies;
         } else {
            if ($cfgHash{ARCH_COPIES} ne '') {
               $ChkNumber = IsNumber($cfgHash{ARCH_COPIES});
               if (not $ChkNumber) {
                  PrintError("ARCH_COPIES option must be a whole number representing \'n\' backup copies.");
                  if ($Trace eq 'true') {
                     print "TRACE: Exiting sub ProcessOptions()\n";
                     print "TRACE: Exiting: 1\n";
                  }
                  exit 1
               } else {
                  $ArchCopies = $cfgHash{ARCH_COPIES};
               }
            } else {
               undef $ArchCopies;
            }
         }

         # Set Force option
         # -------------------
         if ($CoForce) {
            $Force = 'true';
         } else {
            if (($cfgHash{FORCE} eq 'true') or ($cfgHash{FORCE} eq 'false')) {
               $Force = $cfgHash{FORCE};
            } else {
               undef $Force;
            }
         }

         # Set Noexclude option
         # -----------------------
         if ($CoNoExclude) {
            $NoExclude = 'true';
         } else {
            if (($cfgHash{NO_EXCLUDE} eq 'true') or ($cfgHash{NO_EXCLUDE} eq 'false')) {
               $NoExclude = $cfgHash{NO_EXCLUDE};
            } else {
               undef $NoExclude;
            }
         }

         # Set $DeleteObsolete option
         # -----------------------------
         if ($CoDeleteObsolete) {
            $DeleteObsolete = 'true';
         } else {
            if (($cfgHash{DELETE_OBSOLETE} eq 'true') or ($cfgHash{DELETE_OBSOLETE} eq 'false')) {
               $DeleteObsolete = $cfgHash{DELETE_OBSOLETE};
            } else {
               $DeleteObsolete = 'false';
            }
         }

         # Set Incremental level
         # -------------------------
         if ($CoIncrLevel ne '') {
            $IncrLevel = $CoIncrLevel;
         } else {
            if (defined $cfgHash{INCREMENTAL_LEVEL}) {
               $IncrLevel = $cfgHash{INCREMENTAL_LEVEL};
            } else {
               $IncrLevel = '';
            }
         }
         if (($IncrLevel ne '0') and ($IncrLevel ne '1') and ($IncrLevel ne 'full')) {
            $IncrLevel = 'full';
         }

         if ($IncrLevel eq 'full') {
            $TagLevel = 'full';
         } elsif ($IncrLevel eq '0') {
            $TagLevel = 'LEV-0';
         } elsif ($IncrLevel eq '1') {
            $TagLevel = 'LEV-1';
         }

         # Set Cumulative option
         # -----------------------
         if ($CoCumulative) {
            $Cumulative = 'true';
         } else {
            if (($cfgHash{CUMULATIVE} eq 'true') or ($cfgHash{CUMULATIVE} eq 'false')) {
               $Cumulative = $cfgHash{CUMULATIVE};
            } else {
               $Cumulative = 'false';
            }
         }

         # Add cumulative/differential to tag for Incremental Backups
         # -----------------------------------------------------------
         if (($IncrLevel ne 'full') and ($IncrLevel ne '0')) {
            if ($Cumulative eq 'true') {
               $TagLevel .= 'C' ;
            } else {
               $TagLevel .= 'D' ;
            }
         }

         # If this is not an actual backup operation then the backup directory or sbt_libaray are not needed.
         # ----------------------------------------------------------------------------------------------------
         if ((   $OperType eq 'database')
             or ($OperType eq 'datafile')
             or ($OperType eq 'tablespace')
             or ($OperType eq 'validate_backup')
             or ($OperType eq 'validate_restore')
             or ($OperType eq 'fra')
             or ($OperType eq 'arch')
             or ($OperType eq 'crosscheck')
             or ($OperType eq 'delete_obsolete')
             or ($ConfigureRman eq 'true')) {

            # Set the device format using BACKUP_DIRECTORY, SBT_LIBRARY, {DISK|SBT}_FORMAT
            # ---------------------------------------------------------------------------------
            if ($CoBackupDir) {
               $BackupDir = $CoBackupDir . "/[DBNAME]";
            } elsif (defined $cfgHash{BACKUP_DIRECTORY}) {
               $BackupDir = $cfgHash{BACKUP_DIRECTORY} . "/[DBNAME]";
            } else {
              $BackupDir = '';
            }

            # Set the format of the backupset/copy...
            # -----------------------------------------
            ###! print("CoBackupFormat: $CoBackupFormat\n");
            ###! print("BackupFormat: $BackupFormat\n");
            ###! print("BackupDevice: $BackupDevice\n");
            ###! print("cfgHash{DISK_FORMAT}: $$cfgHash{DISK_FORMAT}\n");

            if ($CoBackupFormat) {
               $BackupFormat = $CoBackupFormat;
            } elsif ($BackupDevice eq 'DISK') {
               if (defined $cfgHash{DISK_FORMAT}) {
                 $BackupFormat = $cfgHash{DISK_FORMAT};
               #} else {
               #  $BackupFormat = '%d_%U';
               }
            } else {   # SBT device
               if (defined $cfgHash{SBT_FORMAT}) {
                 $BackupFormat = $cfgHash{SBT_FORMAT};
               #} else {
               #  $BackupFormat = '%d_%U';
               }
            }
            ###! print("\nCoBackupFormat: $CoBackupFormat\n");
            ###! print("BackupFormat: $BackupFormat\n");
            ###! print("BackupDevice: $BackupDevice\n");
            ###! print("cfgHash{DISK_FORMAT}: $$cfgHash{DISK_FORMAT}\n");
            ###! exit();
            # Set the sbt library
            # -----------------------------------------
            if ($CoSbtLibrary) {
               $SbtLibrary = $CoSbtLibrary;
            } else {
              $SbtLibrary = '';
            }

            # If this is a backup to disk
            # -----------------------------
            if ($BackupDevice eq 'DISK') {
               undef $SbtLibrary;
               if ($CoBackupFormat eq '' ) {
                  if (defined $cfgHash{DISK_FORMAT}) {
                     $BackupFormat = $cfgHash{DISK_FORMAT};
                  }
               }
               ###! print("BackupFormat: $BackupFormat\n");
               ###! print("BackupDir: $BackupDir\n");
               ###! exit();
               if (($BackupDir ne '') and ($BackupFormat ne '')) {
                  $BackupFormat = "'" . $BackupDir . '/' . $BackupFormat . "'";
               } else {
                  if (($BackupDir ne '') and ($BackupFormat eq '')) {
                     undef $BackupDir;
                     undef $BackupFormat;
                     $Msg  = "The backup format was not set and this is a backup to device type DISK. We will\n";
                     $Msg .= "assume this is a backup to the Fast Recovery Area (FRA). This warning message\n";
                     $Msg .= "can be cleared by setting the format option in the configuration file,\n";
                     $Msg .= "parameter, files or by not using -directory option. Continuing with backup...\n";
                     PrintWarning($Msg);
                     undef $Msg;
                  } else {
                     if (($BackupFormat ne '') and ($BackupDir eq '')) {
                        undef $BackupFormat;
                        undef $BackupDir;
                         $Msg  = "The backup directory was not been set and this is a backup to device type DISK.\n";
                         $Msg .= "We will assume this is a backup to the Fast Recovery Area (FRA). This warning\n";
                         $Msg .= "message can be cleared by setting the directory option in the configuiration\n";
                         $Msg .= "file, the parameter files, or by not using -format option. Continuing with\n";
                         $Msg .= "backup...";
                         PrintWarning($Msg);
                        undef $Msg;
                     }
                  }
               }
            } else {
               # If this is a backup to tape
               # -------------------------------
               if ($BackupDevice eq 'SBT') {
                  if ($SbtLibrary eq '') {
                     if (defined $cfgHash{SBT_LIBRARY}) {
                        $SbtLibrary = $cfgHash{SBT_LIBRARY};
                     } else {
                         $tmpMsg  = "No value specified for SBT_LIBRARY, defaulting to oracle.sbt. You can set";
                         $tmpMsg .= "\nSBT_LIBRARY using the -sbtlib command line option, or sbt_library key word in";
                         $tmpMsg .= "\nthe configuration file or in the parameter files. SBT_LIBRARY defaulting to\n\'oracle.disksbt\'.";
                        PrintWarning($tmpMsg);
                        undef $tmpMsg;
                        $SbtLibrary = 'oracle.disksbt';
                     }
                  }
                  if ($BackupFormat eq '') {
                     if (defined $cfgHash{SBT_FORMAT}) {
                        $BackupFormat = $cfgHash{SBT_FORMAT};
                     } else {
                        $tmpMsg  = "Format not specified for device type SBT. Format string may be set using the\n";
                        $tmpMsg .= "command line option -format or SBT_FORMAT in the configuration or parameter\n";
                        $tmpMsg .= "files. Defaulting to format of \'%d-%U\'.\n";
                        PrintWarning($tmpMsg);
                        undef $tmpMsg;
                        $BackupFormat = '%d-%U';
                     }
                  }
                  if ($SbtLibrary eq 'oracle.disksbt') {
                     if ($BackupDir) {
                        $BackupFormat = "'" . $BackupFormat . "' parms='SBT_LIBRARY=$SbtLibrary,ENV=(BACKUP_DIR=$BackupDir)'";
                     } else {
                        $ErrMsg  = "BACKUP_DIRECTORY not defined. A backup directory is required when SBT Library is\n";
                        $ErrMsg .= "set to oracle.disksbt. BACKUP_DIRECTORY may be set using command line option\n";
                        $ErrMsg .= " -directory or BACKUP_DIRECTORY in the configuration or parameter files.";
                        PrintError($ErrMsg);
                        if ($Trace eq 'true') {
                           print "TRACE: Exiting sub ProcessOptions()\n";
                           print "TRACE: Exiting: 1\n";
                        }
                        exit 1;
                     }
                  } else {
                     $BackupFormat = "'" . $BackupFormat . "' parms='$SbtLibrary'";
                  }

                  if ($SbtLibrary eq 'oracle.disksbt') {
                     $tmpMsg  = "The RMAN disksbt library emulates a SBT (tape) library but instead of writing\n";
                     $tmpMsg .= "backup sets/copies to tape, it writes them to a file system. It should be used\n";
                     $tmpMsg .= "for testing purposes only. Please do not use this device to perform actual\n";
                     $tmpMsg .= "database backups. Recovery using this device is not supported by Oracle Corp.\n";
                     PrintWarning($tmpMsg);
                     undef $tmpMsg;
                  }
               }
            }
         }

         # Set #Channels
         # ----------------
         if ($CoChannels) {
            $Channels = $CoChannels;
         } else {
            if ( $BackupDevice eq 'SBT' ) {
               if (defined $cfgHash{SBT_CHANNELS}) {
                  $Channels = $cfgHash{SBT_CHANNELS};
               } else {
                  $Channels = 1;
               }
            } else { # Device = Disk
               if (defined $cfgHash{DISK_CHANNELS}) {
                  $Channels = $cfgHash{DISK_CHANNELS};
               } else {
                    $Channels = 1;
               }
            }
         }

         $ChkNumber = IsNumber($Channels);
         if ( not $ChkNumber ) {
            print "Invalid value for # of channels: $Channels. Defaulting to 1 channel.\n";
            $Channels = 1;
         }

         # Set the noChecksum option
         # ----------------------------
         if ($CoNoChecksum) {
            $NoChecksum = 'true';
         } else {
            if (($cfgHash{NO_CHECKSUM} eq 'true') or ($cfgHash{NO_CHECKSUM} eq 'false')) {
               $NoChecksum = $cfgHash{NO_CHECKSUM};
            } else {
               undef $NoChecksum;
            }
         }

         # Set Max Set Size
         # --------------------
         if ($CoMaxSetSize) {
            $MaxSetSize = $CoMaxSetSize;
         } else {
            if ($BackupDevice eq 'SBT' and defined $cfgHash{SBT_MAX_SET_SIZE}) {
               $MaxSetSize = $cfgHash{SBT_MAX_SET_SIZE};
            } elsif ($BackupDevice eq 'DISK' and defined $cfgHash{DISK_MAX_SET_SIZE}) {
               $MaxSetSize = $cfgHash{DISK_MAX_SET_SIZE};
            } else {
               undef $MaxSetSize;
            }
         }

         # Set Max Piece Size
         # ---------------------
         if ($CoMaxPieceSize) {
            $MaxPieceSize = $CoMaxPieceSize;
         } else {
            if ($BackupDevice eq 'SBT' and defined $cfgHash{SBT_MAX_PIECE_SIZE}) {
               $MaxPieceSize = $cfgHash{SBT_MAX_PIECE_SIZE};
            } elsif ($BackupDevice eq 'DISK' and defined $cfgHash{DISK_MAX_PIECE_SIZE}) {
               $MaxPieceSize = $cfgHash{DISK_MAX_PIECE_SIZE};
            } else {
               undef $MaxPieceSize;
            }
         }


         # Set Section Size
         # --------------------
         if ($CoSectionSize) {
            $SectionSize = $CoSectionSize;
         } else {
            if (defined $cfgHash{SECTION_SIZE}) {
               $SectionSize = $cfgHash{SECTION_SIZE};
            } else {
               undef $SectionSize;
            }
         }

         # Set # of Files Per Set
         # -------------------------
         if ($CoFilesPerSet) {
            $FilesPerSet = $CoFilesPerSet;
         } else {
            if ($BackupDevice eq 'SBT' and defined $cfgHash{SBT_FILES_PER_SET}) {
               $FilesPerSet = $cfgHash{SBT_FILES_PER_SET};
            } elsif ($BackupDevice eq 'DISK' and defined $cfgHash{DISK_FILES_PER_SET}) {
               $FilesPerSet = $cfgHash{DISK_FILES_PER_SET};
            } else {
               undef $FilesPerSet;
            }
         }

         # Set number of days to keep the backup.
         # -----------------------------------------
         if ($CoKeepDays) {
            $KeepDays = $CoKeepDays;
         } else {
            if (defined $cfgHash{KEEP_DAYS}) {
               $KeepDays = $cfgHash{KEEP_DAYS};
            } else {
               undef $KeepDays;
            }
         }
         if ($KeepDays) {
            $ChkNumber = IsNumber($KeepDays);
            if ( not $ChkNumber ) {
               $ErrMsg  = "KEEP_DAYS must be a whole number representing the number of days to keep the\nbackup: $KeepDays\n";
                PrintError($ErrMsg);
               if ($Trace eq 'true') {
                  print "TRACE: Exiting sub ProcessOptions()\n";
                  print "TRACE: Exiting: 1\n";
               }
               exit 1
            }
         } else {
            undef $KeepDays;
         }

         # Set Keep Logs.
         # ------------------
         if ($CoKeepNoLogs) {
            $KeepNoLogs = 'true';
         } else {
            if (($cfgHash{KEEP_NOLOGS} eq 'true') or ($cfgHash{KEEP_NOLOGS} eq 'false')) {
               $KeepNoLogs = $cfgHash{KEEP_NOLOGS};
            } else {
               $KeepNoLogs = 'false';
            }
         }

         # Set number of concurrent open files.
         # ---------------------------------------
         if ($CoMaxOpenFiles) {
            $MaxOpenFiles = $CoMaxOpenFiles;
         } else {
            if (defined $cfgHash{MAX_OPEN_FILES}) {
               $MaxOpenFiles = $cfgHash{MAX_OPEN_FILES};
            } else {
               undef $MaxOpenFiles;
            }
         }
         if ($MaxOpenFiles) {
            $ChkNumber = IsNumber($MaxOpenFiles);
            if ( not $ChkNumber ) {
               $ErrMsg  = "MAX_OPEN_FILES must be a whole number representing the maximum number of open files per\n";
               $ErrMsg .= "backup channel: $MaxOpenFiles.";
                PrintError($ErrMsg);
               if ($Trace eq 'true') {
                  print "TRACE: Exiting sub ProcessOptions()\n";
                  print "TRACE: Exiting: 1\n";
               }
               exit 1
            }
         }

         # Set Skip
         # ------------
         if ($CoSkip) {
            $Skip = $CoSkip;
            $Skip =~ s/\s+//g;
            @Skip = split(',', uc($Skip));
         } else {
            if (defined $cfgHash{SKIP}) {
               $Skip = uc($cfgHash{SKIP});
               $Skip =~ s/\s+//g;
               @Skip  = split(',', $Skip);
            } else {
               undef $Skip;
               undef @Skip;
            }
         }
         foreach my $ChkSkip (@Skip) {
            if (($ChkSkip ne 'READONLY') and ($ChkSkip ne 'OFFLINE') and ($ChkSkip ne 'INACCESSIBLE')) {
               PrintError("Invalid value specified for -skip option: $ChkSkip");
               exit(1)
            }
         }

         # Set Compression Level
         # ------------------------------
         if ($CoComprLevel) {
            $ComprLevel = $CoComprLevel;
            if (($ComprLevel ne 'basic') and ($ComprLevel ne 'low') and ($ComprLevel ne 'medium') and ($ComprLevel ne 'high')) {
               PrintError("Invalid value for -comprlevel option: $ComprLevel\nValid values: 'basic', 'low', 'medium', 'high'");
               exit 1;
            } else {
               $ComprLevel = uc($ComprLevel);
            }
         } elsif ($cfgHash{COMPRESSION_LEVEL}) {
            if (($cfgHash{COMPRESSION_LEVEL} ne 'basic') and ($cfgHash{COMPRESSION_LEVEL} ne 'low') and
                ($cfgHash{COMPRESSION_LEVEL} ne 'medium') and ($cfgHash{COMPRESSION_LEVEL} ne 'high')) {
               PrintError("Invalid value for -comprlevel option: $cfgHash{COMPRESSION_LEVEL}\nValid values: 'basic', 'low', 'medium', 'high'");
               exit 1;
            } else {
               $ComprLevel = uc($cfgHash{COMPRESSION_LEVEL});
            }
         } else {
            undef $ComprLevel;
         }

         # Set Compression Optimizated for Load
         # ---------------------------------------
         if ($CoComprOptim) {
            $ComprOptim = 'true';
         } else {
            if (($cfgHash{COMPRESSION_OPTIMIZATION} eq 'true') or ($cfgHash{COMPRESSION_OPTIMIZATION} eq 'false')) {
               $ComprOptim = $cfgHash{COMPRESSION_OPTIMIZATION};
            } else {
               $ComprOptim = 'false';
            }
         }

         # Set Duration option
         # ----------------------
         if ($CoMaxDuration) {
            $MaxDuration = $CoMaxDuration;
         } else {
            if (defined $cfgHash{DURATION}) {
               $MaxDuration = $cfgHash{DURATION};
            } else {
               undef $MaxDuration;
            }
         }

         # Validate the time format of MaxDuration
         # -------------------------------------------
         my $InvalidHour   = 0;
         my $InvalidMinute = 0;
         my $hh            = 0;
         my $mm            = 0;

         if ($MaxDuration) {
            ($hh, $mm) = split(':', $MaxDuration);
            $ValidHour = IsNumber($hh);
            $ValidMinute = IsNumber($mm);

            if (not $ValidHour or not $ValidMinute) {
               $ErrMsg  = "DURATION must be in the form of hh:mm\n";
               if (not $ValidHour) {
                  $ErrMsg .= "Invalid Hour: $hh\n";
               }
               if (not $ValidMinute) {
                  $ErrMsg .= "Invalid Minute: $mm\n";
               }
               PrintError($ErrMsg);
               if ($Trace eq 'true') {
                  print "TRACE: Exiting sub ProcessOptions()\n";
                  print "TRACE: Exiting: 1\n";
               }
               exit(1)
            }
         }


         # Set Backup Controlfile & Spfile option
         # -------------------------------------------
         if ($CoControlfile) {
            $Controlfile = 'true';
         } else {
            if (( $cfgHash{BACKUP_CONTROLFILE} eq 'true' ) or ( $cfgHash{BACKUP_CONTROLFILE} eq 'false' )) {
               $Controlfile = $cfgHash{BACKUP_CONTROLFILE};
            } else {
               $Controlfile = 'false';
            }
         }

         # Set Streaming Rate
         # ---------------------
         if ($CoStreamingRate) {
            $StreamingRate = $CoStreamingRate;
         } else {
            if ($BackupDevice eq 'SBT') {
               if (defined $cfgHash{SBT_STREAMING_RATE}) {
                  $StreamingRate = $cfgHash{SBT_STREAMING_RATE};
               } else {
                  undef $StreamingRate;
               }
            } elsif ($BackupDevice eq 'DISK') {
               if (defined $cfgHash{DISK_STREAMING_RATE}) {
                  $StreamingRate = $cfgHash{DISK_STREAMING_RATE};
               } else {
                  undef $StreamingRate;
               }
            } else {
              undef $StreamingRate;
            }
         }


         # Set catalog info.
         # ---------------------
         if ($CoNoCat) {
            $NoCat = 'true';
            undef $CatSid;
            undef $CatUser;
         } else {
            $NoCat = 'false';

            # Set Catalog SID
            # -------------------
            if ($CoCatSid) {
               $CatSid = $CoCatSid;
            } else {
               if (defined $cfgHash{CATALOG}) {
                  $CatSid = $cfgHash{CATALOG};
               } else {
                  undef $CatSid;
               }
            }
            # Set Catalog user account
            # ----------------------------
            if ($CoCatUser) {
               $CatUser = $CoCatUser;
            } else {
               if (defined $cfgHash{CATALOG_USER}) {
                  $CatUser = $cfgHash{CATALOG_USER};
               } else {
                  undef $CatUser;
               }
            }
         }
         if (($CatSid ne '' ) and ($CatUser ne '')) {
            $CatPassword = GetPassword($CatSid, $CatUser);
            if (not $CatPassword) {
               PrintError("Password lookup failure for catalog database.\n   SID : $CatSid\n   User: $CatUser\n");
               if ($Trace eq 'true') {
                  print "TRACE: Exiting sub ProcessOptions()\n";
                  print "TRACE: Exiting: 1\n";
               }
               exit 1;
            } else {
               $CatalogConnStr  = $CatUser . '/' . $CatPassword . '@' . $CatSid;
               $PrintCatConnStr = $CatUser . '/<***>@' . $CatSid;
            }
         } else {
            undef $CatalogConnStr;
            $PrintCatConnStr = '<No Catalog>';
         }

         # Set Delete Archive Logs option
         # ----------------------------------
         if ($CoCopy) {
            $Copy = 'true';
         } else {
            if (($cfgHash{COPY} eq 'true') or ($cfgHash{COPY} eq 'false')) {
               $Copy = $cfgHash{COPY};
            } else {
               $Copy = 'false';
            }
         }
      }

      # Set ConfigureRman option
      # --------------------------
      if ($CoConfigureRman) {
         $ConfigureRman = 'true';
      } else {
        if (($cfgHash{CONFIGURE_RMAN} eq 'true') or ($cfgHash{CONFIGURE_RMAN} eq 'false')) {
            $ConfigureRman = $cfgHash{CONFIGURE_RMAN};
         } else {
            $ConfigureRman = 'false';
         }
      }
      # Disable ConfigureRman option is this is just a register operation.
      if ($ConfigureRman eq 'true') {
         if ($OperType eq 'register') {
            $ConfigureRman = 'false';
         }
      }
   }   # end of *** Not An External Script *** section.

   if ($Trace eq 'true') {
      print("\n---------------------------------------------------------------");
      print("\nCommand Line Options Used:");
      print("\n---------------------------------------------------------------");
      print("\n\$CoArchCopies       = $CoArchCopies      ")   if ($CoArchCopies     );
      print("\n\$CoArchLogs         = $CoArchLogs        ")   if ($CoArchLogs       );
      print("\n\$CoCatSid           = $CoCatSid          ")   if ($CoCatSid         );
      print("\n\$CoCatUser          = $CoCatUser         ")   if ($CoCatUser        );
      print("\n\$CoChannels         = $CoChannels        ")   if ($CoChannels       );
      print("\n\$CoCheckSyntax      = $CoCheckSyntax     ")   if ($CoCheckSyntax    );
      print("\n\$CoComprLevel       = $CoComprLevel      ")   if ($CoComprLevel     );
      print("\n\$CoComprOptim       = $CoComprOptim      ")   if ($CoComprOptim     );
      print("\n\$CoControlfile      = $CoControlfile     ")   if ($CoControlfile    );
      print("\n\$CoConfigureRman    = $CoConfigureRman   ")   if ($CoConfigureRman  );
      print("\n\$CoCopy             = $CoCopy            ")   if ($CoCopy           );
      print("\n\$CoCumulative       = $CoCumulative      ")   if ($CoCumulative     );
      print("\n\$CoDbfList          = $CoDbfList         ")   if ($CoDbfList        );
      print("\n\$CoDebug            = $CoDebug           ")   if ($CoDebug          );
      print("\n\$CoDeleteDelay      = $CoDeleteDelay     ")   if ($CoDeleteDelay    );
      print("\n\$CoDeleteLogs       = $CoDeleteLogs      ")   if ($CoDeleteLogs     );
      print("\n\$CoDistChan         = $CoDistChan        ")   if ($CoDistChan       );
      print("\n\$CoBackupDevice     = $CoBackupDevice    ")   if ($CoBackupDevice   );
      print("\n\$CoDistList         = $CoDistList        ")   if ($CoDistList       );
      print("\n\$CoBackupDir        = $CoBackupDir       ")   if ($CoBackupDir      );
      print("\n\$CoMaxDuration      = $CoMaxDuration     ")   if ($CoMaxDuration    );
      print("\n\$CoFilesPerSet      = $CoFilesPerSet     ")   if ($CoFilesPerSet    );
      print("\n\$CoForce            = $CoForce           ")   if ($CoForce          );
      print("\n\$CoBackupFormat     = $CoBackupFormat    ")   if ($CoBackupFormat   );
      print("\n\$CoGenerate         = $CoGenerate        ")   if ($CoGenerate       );
      print("\n\$CoHelp             = $CoHelp            ")   if ($CoHelp           );
      print("\n\$CoKeepDays         = $CoKeepDays        ")   if ($CoKeepDays       );
      print("\n\$CoKeepNoLogs       = $CoKeepNoLogs      ")   if ($CoKeepNoLogs     );
      print("\n\$CoIncrLevel        = $CoIncrLevel       ")   if ($CoIncrLevel      );
      print("\n\$CoMaxOpenFiles     = $CoMaxOpenFiles    ")   if ($CoMaxOpenFiles   );
      print("\n\$CoMaxPieceSize     = $CoMaxPieceSize    ")   if ($CoMaxPieceSize   );
      print("\n\$CoMaxSetSize       = $CoMaxSetSize      ")   if ($CoMaxSetSize     );
      print("\n\$CoNoCat            = $CoNoCat           ")   if ($CoNoCat          );
      print("\n\$CoNoChecksum       = $CoNoChecksum      ")   if ($CoNoChecksum     );
      print("\n\$CoNoExclude        = $CoNoExclude       ")   if ($CoNoExclude      );
      print("\n\$CoNotify           = $CoNotify          ")   if ($CoNotify         );
      print("\n\$CoDeleteObsolete   = $CoDeleteObsolete  ")   if ($CoDeleteObsolete );
      print("\n\$CoParFile          = $CoParFile         ")   if ($CoParFile        );
      print("\n\$CoPlusArchlogs     = $CoPlusArchlogs    ")   if ($CoPlusArchlogs   );
      print("\n\$CoRetention        = $CoRetention       ")   if ($CoRetention      );
      print("\n\$CoStreamingRate    = $CoStreamingRate   ")   if ($CoStreamingRate  );
      print("\n\$CoSbtLibrary       = $CoSbtLibrary      ")   if ($CoSbtLibrary     );
      print("\n\$CoExternalScript   = $CoExternalScript  ")   if ($CoExternalScript );
      print("\n\$CoSectionSize      = $CoSectionSize     ")   if ($CoSectionSize    );
      print("\n\$CoTargetService    = $CoTargetService   ")   if ($CoTargetService  );
      print("\n\$CoTargetSid        = $CoTargetSid       ")   if ($CoTargetSid      );
      print("\n\$CoShow             = $CoShow            ")   if ($CoShow           );
      print("\n\$CoSkip             = $CoSkip            ")   if ($CoSkip           );
      print("\n\$CoTargetUser       = $CoTargetUser      ")   if ($CoTargetUser     );
      print("\n\$CoTbsList          = $CoTbsList         ")   if ($CoTbsList        );
      print("\n\$CoTnsAdmin         = $CoTnsAdmin        ")   if ($CoTnsAdmin       );
      print("\n\$CoTrace            = $CoTrace           ")   if ($CoTrace          );
      print("\n\$CoOperType         = $CoOperType        ")   if ($CoOperType       );
      print("\n\$CoShowVersion      = $CoShowVersion     \n") if ($CoShowVersion    );
      print("\n---------------------------------------------------------------\n");
   }

   # Nullify any options that don't apply to this Rman operation.
   # ---------------------------------------------------------------
   if ($OperType eq 'arch' or $ArchLogs) {
      undef $FilesPerSet   if ($OperType eq 'validate_restore');
      undef $NoChecksum    if ($OperType eq 'validate_restore');
   }

   if (    $OperType eq 'resync'
        or $OperType eq 'register'
        or $OperType eq 'list_expired'
        or $OperType eq 'report_schema'
        or $OperType eq 'report_need_backup'
        or $OperType eq 'report_unrecoverable'
        or $OperType eq 'report_obsolete' ) {
      $Channels = '0';
   }

   if ($OperType eq 'resync'               or
       $OperType eq 'register'             or
       $OperType eq 'delete_expired'       or
       #$OperType eq 'delete_obsolete'      or
       $OperType eq 'list_expired'         or
       $OperType eq 'report_obsolete'      or
       $OperType eq 'report_unrecoverable' or
       $OperType eq 'report_need_backup'   or
       $OperType eq 'report_schema') {
       #$OperType eq 'report_schema'        or
       #$OperType eq 'validate_restore') {
      undef $ArchCopies;
      undef $ArchLogs;
      undef $BackupDir;
      undef $BackupFormat;
      undef $ComprLevel;
      undef $ComprOptim;
      undef $Controlfile;
      undef $Copy;
      undef $Cumulative;
      undef $DeleteDelay;
      undef $DeleteLogs;
      undef $DistChan;
      undef $FilesPerSet;
      undef $Force;
      undef $KeepDays;
      undef $KeepNoLogs;
      undef $IncrLevel;
      undef $MaxDuration;
      undef $MaxOpenFiles;
      undef $MaxPieceSize;
      undef $MaxSetSize       if ($OperType ne 'validate_restore');
      undef $NoChecksum;
      undef $NoExclude;
      undef $PlusArchlogs;
      undef $SectionSize;
      undef $TargetService;
      undef $StreamingRate;
      undef $TargetUser;
   }

   if ($OperType eq 'crosscheck' or $OperType eq 'validate_restore') {
      undef $ArchCopies;
      undef $ArchLogs;
      undef $ComprLevel;
      undef $ComprOptim;
      undef $Controlfile;
      undef $Copy;
      undef $Cumulative;
      undef $DeleteDelay;
      undef $DeleteLogs;
      undef $FilesPerSet;
      undef $Force;
      undef $KeepDays;
      undef $KeepNoLogs;
      undef $IncrLevel;
      undef $MaxDuration;
      undef $MaxOpenFiles;
      undef $MaxPieceSize;
      undef $MaxSetSize;
      undef $NoChecksum;
      undef $NoExclude;
      undef $PlusArchlogs;
      undef $SectionSize;
      undef $StreamingRate;
   }

   if ($OperType ne 'datafile') {
      undef $DbfList;
   }

   if ($OperType ne 'tablespace') {
      undef $TbsList;
   }

   if ($Trace eq 'true') {
      print "TRACE: Exiting sub ProcessOptions()\n";
      print "TRACE: Exiting: 0\n";
   }
}
# ------------------------------------------------------------------------
# End ProcessOptions()
# ------------------------------------------------------------------------


# Sub : ErrorCheck($)
# Desc: Check a log file for SQL PLus & Rman errors
# Args: 1=The file to scan for errors
# Retn: 1=Sqlplus Error
#       2=Rman Error
# ------------------------------------------------------------------------
sub ErrorCheck($) {
   my $Output = shift;

   if ($Trace eq 'true') {
      print "TRACE: Entering sub ErrorCheck(\$)\n";
      print "TRACE: Parameters:\n";
      print "TRACE:    \$Output = $Output\n";
   }

   my @ErrorStack = ();
   my $rc         = 0;
   my $ErrType    = 0;
   my $SQLError   = 0;
   my $RmanError  = 0;

   if ($Output) {
      if (-f $Output) {
         open(OUTPUT, "<", $Output);
         @AllLines = <OUTPUT>;
         chomp(@AllLines);
      } else {
         @AllLines = split("\n", $Output);
      }

      print "TRACE: Checking \$Output for errors.\n" if ($Trace eq 'true');

      foreach $Line (@AllLines) {
         next if $Line =~ /^\s*$/;  # skip blank lines

         # Check for warning and error messages
         # -------------------------------------
         $RmanError = 1 if ($Line =~ m/^RMAN-00569:.*$/); # This is the beginning of an RMAN stack trace.

         # RMAN Errors
         # --------------
         if ($Line =~ m/^RMAN-[\d]+:.*$/) {
           push @ErrorStack, $Line;
         }

         # Database, Sqlplus & Other Errors
         # ------------------------------------
         if ((($Line =~ m/^ORA-[\d]+:.*$/)  or
              ($Line =~ m/^SP2-[\d]+:.*$/)  or
              ($Line =~ m/.*error.*$/)      or
              ($Line =~ m/.*WARNING.*/))    and
              (not $Line =~ m/.*WARNING: Oracle Test Disk API.*/)) {
           push @ErrorStack, $Line;
           $SqlError = 1;
         }

         # TNS Errors
         # ------------------------------------
         if ($Line =~ m/^TNS-[\d]+:.*$/) {
           push @ErrorStack, $Line;
           $TNSError = 1;
         }
      }
      close(OUTPUT) if (-f $Output);
   }

   if ($SqlError) {
      $ErrType = 1;
   }

   if ($RmanError) {
      $ErrType = 2;
   }

   if ($TnsError) {
      $ErrType = 3;
   }

   if ($Trace eq 'true') {
      print "TRACE: Exiting sub ErrorCheck(\$)\n";
      print "TRACE: Returning:\n";
      print "TRACE:    \$ErrType    = $ErrType\n";
      print "TRACE:    \@ErrorStack = @ErrorStack\n";
   }
   return ($ErrType, @ErrorStack);
}
# ------------------------------------------------------------------------
# End ErrorCheck()
# ------------------------------------------------------------------------


# Sub Notify($$$)
# Desc: Check the recovery area configuration
# Args: $0 is the distribution list.
#       $1 is the result of the operation (Successful/Failed).
#       $2 is the message string or name of the file to send.
# Retn: $rc = result code from sqlplus session
#       $RecoveryDest = Location of the Flash Recovery Area
#       $RecoverySize = Size of the FRA in bytes.
#-------------------------------------------------------------------------
sub Notify($$$) {
   my $DistList = shift;
   my $Result   = shift;
   my $Msg      = shift;
   my $rc       = 0;

   if ($Trace eq 'true') {
      print "TRACE: Entering sub Notify(\$\$)\n";
      print "TRACE: Parameters:\n";
      print "TRACE:    \$DistList = $DistList\n";
      print "TRACE:    \$Result   = $Subj\n";
      print "TRACE:    \$Msg      = $Msg \n";
   }

   if ($Trace eq 'true') {
      print "TRACE: \$DistList=$DistList\n";
   }

   # Set the subject line for Email Notification
   if (($OperType eq 'database') or ($OperType eq 'datafile') or ($OperType eq 'tablespace')) {
      $Subject = $CmdName . ' : ' . uc($TagLevel) . ' : ' . uc($OperType) . ' BACKUP ' . ' : ' . $Result . ' : ' . $TargetSid;
   } else {
      if (($OperType eq 'fra') or ($OperType eq 'arch')) {
         $Subject = $CmdName . ' : ' . uc($OperType) . ' BACKUP ' . ' : ' . $Result . ' : ' . $TargetSid;
      } else {
         if ((uc($OperType) eq 'VALIDATE_RESTORE') or (uc($OperType) eq 'VALIDATE_BACKUP')) {
            $Subject = $CmdName . ' : ' . uc($OperType) . '-' . uc($DevType) . ' : ' . $Result . ' : ' . $TargetSid;
         } else {
            $Subject = $CmdName . ' : ' . uc($OperType) . ' : ' . $Result . ' : ' . $TargetSid;
         }
      }
   }

   if (-T $Msg) {
      if ($^O eq 'aix') {
         $MailOut = `mail -s "$Subject" "$DistList" <$Msg`;
         $rc = $rc + $?;
      } else {
         $MailOut = `mail -s "$Subject" <$Msg "$DistList"`;
         $rc = $rc + $?;
      }
      unlink $MsgFile if (-T $MsgFile);
   }

   if ($rc) {
      print "---------------------------------\n";
      print " Mail Exit Code = $rc\n";
      print "\Mail Output    = $MailOut\n";
      print "---------------------------------\n";
   }

   if ($Trace eq 'true') {
      print "TRACE: Exiting sub Notify(\$\$)\n";
      print "TRACE: Returning:\n";
      print "TRACE:    \$rc      = $rc\n";
      print "TRACE:    \$MailOut = $MailOut\n";
   }
   return $rc, $MailOut;
}
# ------------------------------------------------------------------------
# End Notify()
# ------------------------------------------------------------------------


# Sub ImportRmanLog($)
# Desc: Prints the Rman logfile to stdout (which tee'd to the Dixie log).
# Args: $0 is the file to print (expecting the Rman log file).
# Retn: $rc = result code from the 'open $logfile' call, (0 = good open).
# ------------------------------------------------------------------------
sub ImportRmanLog($) {
   my $RmanLog = shift;

   if ($Trace eq 'true') {
      print "TRACE: Entering sub ImportRmanLog(\$)\n";
      print "TRACE: Parameters:\n";
      print "TRACE:    \$RmanLog = $RmanLog\n";
   }

   open (RMAN_LOG, "<", $RmanLog) or do {
      PrintError("Cannot Open Log File for read: $RmanLog\n");
      if ($Trace eq 'true') {
         print "TRACE: Exiting sub ImportRmanLog(\$)\n";
         print "TRACE: Returning: 1\n";
      }
      return 1;
   };

   my @AllLines  = <RMAN_LOG>;
   chomp(@AllLines);

   foreach $Line (@AllLines) {
      print "   RMAN: $Line\n";
   }

   close RMAN_LOG;
   unlink $RmanLog;
}
# ------------------------------------------------------------------------
# End ImportRmanLog()
# ------------------------------------------------------------------------


# Sub : LoadOptions($)
# Desc: Parse and load the configuration file.
# Args: 1=Configuration file name.
# Retn: <none>
# ------------------------------------------------------------------------
sub LoadOptions($) {
   my $ConfigFile = shift;
   my $rc         = 0;
   my $Line       = '';
   my $FilePos    = -2;

   if ($Trace eq 'true') {
      print "TRACE: Entering sub LoadOptions(\$)\n";
      print "TRACE: Parameters:\n";
      print "TRACE:    \$ConfigFile = $ConfigFile\n";
   }

   if ((-f $ConfigFile ) and (-r $ConfigFile)) {
      open(CFG_FILE, "<", $ConfigFile);
      $FilePos = tell(CFG_FILE);
   } else {
        $rc = 1;
   }

   if (($rc == 0) and ($FilePos == 0)) {
      while ($Line = <CFG_FILE>) {
         chomp($Line);
         next if $Line =~ /^\s*$/;                       # skip blank lines
         next if $Line =~ /^#/;                          # skip commented lines

         my $loc    = index($Line, '=');
         my $cfgKey = substr($Line, 0, $loc - 1);
         my $cfgVal = substr($Line, $loc + 1);
         $cfgKey    = uc($cfgKey);                       # force all values to uppercase...

         TrimString($cfgKey);
         TrimString($cfgVal);

         $cfgHash{$cfgKey} = $cfgVal if ($cfgKey);
      }

      # I want some parameters to always be lowercase so...
      # ------------------------------------------------------
      $cfgHash{BACKUP_ARCHLOGS         } = lc($cfgHash{BACKUP_ARCHLOGS         }) if (defined $cfgHash{BACKUP_ARCHLOGS         });
      $cfgHash{BACKUP_CONTROLFILE      } = lc($cfgHash{BACKUP_CONTROLFILE      }) if (defined $cfgHash{BACKUP_CONTROLFILE      });
      $cfgHash{BACKUP_DEVICE           } = lc($cfgHash{BACKUP_DEVICE           }) if (defined $cfgHash{BACKUP_DEVICE           });
      $cfgHash{BACKUP_TYPE             } = lc($cfgHash{BACKUP_TYPE             }) if (defined $cfgHash{BACKUP_TYPE             });
      $cfgHash{COMPRESSION_OPTIMIZATION} = lc($cfgHash{COMPRESSION_OPTIMIZATION}) if (defined $cfgHash{COMPRESSION_OPTIMIZATION});
      $cfgHash{COPY                    } = lc($cfgHash{COPY                    }) if (defined $cfgHash{COPY                    });
      $cfgHash{CUMULATIVE              } = lc($cfgHash{CUMULATIVE              }) if (defined $cfgHash{CUMULATIVE              });
      $cfgHash{DEBUG                   } = lc($cfgHash{DEBUG                   }) if (defined $cfgHash{DEBUG                   });
      $cfgHash{DELETE_ARCHLOGS         } = lc($cfgHash{DELETE_ARCHLOGS         }) if (defined $cfgHash{DELETE_ARCHLOGS         });
      $cfgHash{DELETE_DELAY            } = lc($cfgHash{DELETE_DELAY            }) if (defined $cfgHash{DELETE_DELAY            });
      $cfgHash{DELETE_OBSOLETE         } = lc($cfgHash{DELETE_OBSOLETE         }) if (defined $cfgHash{DELETE_OBSOLETE         });
      $cfgHash{FORCE                   } = lc($cfgHash{FORCE                   }) if (defined $cfgHash{FORCE                   });
      $cfgHash{GENERATE                } = lc($cfgHash{GENERATE                }) if (defined $cfgHash{GENERATE                });
      $cfgHash{INCREMENTAL_LEVEL       } = lc($cfgHash{INCREMENTAL_LEVEL       }) if (defined $cfgHash{INCREMENTAL_LEVEL       });
      $cfgHash{KEEP_NOLOGS             } = lc($cfgHash{KEEP_NOLOGS             }) if (defined $cfgHash{KEEP_NOLOGS             });
      $cfgHash{NO_CHECKSUM             } = lc($cfgHash{NO_CHECKSUM             }) if (defined $cfgHash{NO_CHECKSUM             });
      $cfgHash{NO_EXCLUDE              } = lc($cfgHash{NO_EXCLUDE              }) if (defined $cfgHash{NO_EXCLUDE              });
      $cfgHash{NOTIFY                  } = lc($cfgHash{NOTIFY                  }) if (defined $cfgHash{NOTIFY                  });
      $cfgHash{SHOW                    } = lc($cfgHash{SHOW                    }) if (defined $cfgHash{SHOW                    });
      $cfgHash{SKIP                    } = lc($cfgHash{SKIP                    }) if (defined $cfgHash{SKIP                    });

      if ($Trace eq 'true') {
         # Dump the configuration hash
         # ----------------------------
         foreach $key (sort (keys %cfgHash)) {
            printf "TRACE: %-30s = %-20s\n", $key, $cfgHash{$key};
         }
      }
   } else {
      # Open failed.
      $rc = 1;
   }

   if ($Trace eq 'true') {
      print "TRACE: Exiting sub LoadOptions()\n";
      print "TRACE: Returning: $rc\n";
   }
   return $rc;
}
# ------------------------------------------------------------------------
# End LoadOptions()
# ------------------------------------------------------------------------


# Sub : CheckInstState($)
# Desc: Check the state of the database.
# Args: <none>
# Retn: <none>
# ------------------------------------------------------------------------
sub CheckInstState() {
   $DbState = GetInstState($SysConnStr);
   if (($DbState ne 'MOUNTED') and ($DbState ne 'OPEN')) {
      print "   -Database must be mounted or open to perform a backup. Current database state:  $DbState\n";
      $MainRC ++;
   }
}
# ------------------------------------------------------------------------
# End CheckInstState()
# ------------------------------------------------------------------------

# Sub : CheckFeatureCompatibility($)
# Desc: Check for incompatibilities between Rman features specified.
# Args: <none>
# Retn: <none> (exit with return code=1 if incompatibility found)
# ------------------------------------------------------------------------
sub CheckFeatureCompatibility() {
   if (($OperType ne 'datafile') and ($Skip ne '')) {
      PrintError("Skip option is only valid for datafile backup type (for example: -type datafile\n-datafiles 1,2,3). Backup type specified: $OperType");
      exit 1;
   }

   if (($OperType eq 'datafile') and ($DbfList eq '')) {
      PrintError("A datafile list is required for backup type of 'datafile' (for example: -datafiles\n1,2,3 on the command line or datafiles = 1,2,3 in config/par file).");
      exit 1;
   }

   if (($Copy eq 'true') and ($ComprLevel ne '')) {
      PrintError("Copy and ComprLevel (compression level) options cannot be used together");
      exit 1;
   }

   if (($MaxDuration ne '') and ($PlusArchlogs eq 'true')) {
      PrintError("DURATION with BACKUP PLUS ARCHIVELOG is not yet implemented in RMAN.");
      exit 1;
   }

   if (($OperType eq 'fra') and ($BackupDevice ne 'SBT')) {
      PrintError("Recovery Area Backups can only go to an SBT (tape) device.");
      exit 1;
   }

   if (($DeleteLogs eq 'true') and ($ArchLogs ne 'true')) {
      PrintError("DeleteLogs (delete_archlogs) option may only be used with ArchLogs\n(backup_archlogs) option");
      exit 1;
   }

   if (($DeleteDelay) and (not $DeleteLogs)) {
      PrintError("The -deletedelay option must be used with the -deletelogs option.");
      exit 1;
   }

   if (($Cumulative eq 'true') and (($IncrLevel eq '0') or ($IncrLevel eq 'full'))) {
      PrintError("Cumulative option may only be used with Level 1 incremental \nbackups. See\n\"-level\" option");
      exit 1;
   }

   if (($Cumulative eq 'true') and (($OperType ne 'database') and ($OperType ne 'datafile') and ($OperType ne 'tablespace'))) {
      PrintError("Cumulative (cumulative) option may only be used with database, datafile and tablespace backups");
      exit 1;
   }

   if ($OperType ne 'database' and $OperType ne 'datafile' and $OperType ne 'tablespace') {
      undef $IncrLevel;
   }

   if ($OperType eq '' ) {
      if ($ExternalScript ne '') {
         PrintError("Backup type must be specified on the command line with -type if -script option\nspecified");
         exit 1;
      }
   }

   if ($SectionSize ne '' and $MaxPieceSize ne '') {
      PrintError("The -sectionsize (SECTION_SIZE) option may not be used with -maxpiecesize\n(MAX_PIECE_SIZE) option.");
      exit(1);
   }

   if ($SectionSize ne '' and $Copy eq 'true') {
      PrintError("The -sectionsize (SECTION_SIZE) option may not be used with -copy\n(COPY) option.");
      exit(1);
   }

   if (($IncrLevel == 0 or $IncrLevel == 1) and ($Copy eq 'true')) {
      PrintError("The -level (INCREMENTAL_LEVEL) option may not be used with -copy\n(COPY) option.");
      exit(1);
   }

   if ($KeepNoLogs eq 'true') {
      if (not $KeepDays) {
         PrintError("KeepNoLogs option must be used with the KeepDays (keep_days) option");
         exit 1;
      }
      if ($IncrLevel ne 'full') {
         PrintError("KeepNoLogs option cannot be used with incremental backup");
         exit 1;
      }
   }

   if (($SbtLibrary ne '') and ($BackupDevice ne 'SBT')) {
      PrintError("SbtLibrary (sbt_library) option may only be used with device type SBT");
      exit 1;
   }

   if (($OperType eq 'register') and ((not $Generate) or (not $Show))) {
      PrintError("Databases may only be registered interactively.\nUse 'show' option to display REGISTER DATABASE syntax.");
      exit 1;
   }

   if ($ArchCopies and ($PlusArchlogs eq 'false' and $ArchLogs eq 'false')) {
      PrintError("The -archcopies option must be used with the -archlogs or -plusarchlogs option.");
      exit 1;
   }

   if ($PlusArchlogs eq 'true' and $ArchLogs eq 'true') {
      PrintError("The -plusarchlogs and -archlogs options may not be used together.");
      exit 1;
   }

   if ($Generate eq 'true') {
      if ($CheckSyntax eq 'true') {
         PrintError("The -generate and -checksyntax options may not be used together.");
         exit 1;
      }
      if ($Debug eq 'true') {
         PrintError("The -generate and -debug options may not be used together.");
         exit 1;
      }
   }

   if ($Show eq 'true') {
      if ($CheckSyntax eq 'true') {
         PrintError("The -show and -checksyntax options may not be used together.");
         exit 1;
      }
      if ($Debug eq 'true') {
         PrintError("The -show and -debug options may not be used together.");
         exit 1;
      }
   }
}
# ------------------------------------------------------------------------
# End CheckFeatureCompatibility()
# ------------------------------------------------------------------------

# Pkg : Multiple
# Sub : TIEHANDLE
# Desc: Tee's print and printf output to stdout and a file.
# Args: <none>
# Retn: <none>
# ------------------------------------------------------------------------
package Multiple;
sub TIEHANDLE {
   my $self=[@_];bless $self
}

sub PRINT {
   my $self=shift;
   print $_ @_ for @$self
}

sub PRINTF {
   my $self=shift;
   printf $_ @_ for @$self
}
package main;
# ------------------------------------------------------------------------
# End Multiple
# ------------------------------------------------------------------------


# Sub : GetPassword()
# Desc: Retrieve and decrypt password from the Password file.
# Args: 1:ORACLE_SID, 2:Db Username
# Retn: 1:password
# ------------------------------------------------------------------------
sub GetPassword($$) {
   my $DbName = shift;
   my $DbUser = shift;

   if ($Trace eq 'true') {
      print "TRACE: Entering sub GetPassword(\$\$)\n";
      print "TRACE: Parameters:\n";
      print "TRACE:   \$DbName = $DbName \n";
      print "TRACE:   \$DbUser = $DbUser\n";
   }

   if ($Trace eq 'true') {
      print "TRACE: SERVICE:$DbName USER:$DbUser\n";
   }

   if ( not ( -T $PassFile ) && ( -r $PassFile ) ) {      # File must be text and readable to continue...
      print "Password file is not readable or is not plain text\n";
      if ($Trace eq 'true') {
         print "TRACE: Exiting sub GetPassword()\n";
         print "TRACE: Returning: null\n";
      }
      return '';
   } else {
      open(PASSWORD_FILE, "<", $PassFile) or die "Can't open PASSWORD_FILE for read: $PassFile\n";
      while (my $Line = <PASSWORD_FILE>) {
         chomp($Line);

         # Skip blank and commented lines.
         # ---------------------------------
         if ( $Line =~ m/^$DbName\.*/ ) {
            if ($Trace eq 'true') {
               print "TRACE: Password Line: $Line\n";
            }
            (my $pwDbname, my $pwUsername, my $pwUserpass) = split(':', $Line);
            # Remove leading/trailing spaces from dbname, username, and password.
            # ---------------------------------------------------------------------
            $pwDbname   =~ s/^\s+//;
            $pwDbname   =~ s/\s+$//;
            $pwUsername =~ s/^\s+//;
            $pwUsername =~ s/\s+$//;
            $pwUserpass =~ s/^\s+//;
            $pwUserpass =~ s/\s+$//;

            if ( ( $pwDbname eq $DbName ) and ( $pwUsername eq $DbUser ) and ( $pwUserpass ne '' ) ) {
               # Decrypt the password. Remove this line of not using encrypted passwords.
               # ------------------------------------------------------------------------
               $pwUserpass = decode_base64($pwUserpass);

               if ($Trace eq 'true') {
                  printf "TRACE: Password lookup results:\n";
                  printf "TRACE: ------------------------------\n";
                  printf "TRACE: Database  = %s\n", $pwDbname;
                  printf "TRACE: User Name = %s\n", $pwUsername;
                  printf "TRACE: Password  = %s\n", $pwUserpass;
               }
               if ($Trace eq 'true') {
                  print "TRACE: Exiting sub GetPassword()\n";
                  print "TRACE: Returning: \$pwUserpass = $pwUserpass\n";
               }
               # Return the decrypted password.
               # --------------------------------
               return $pwUserpass;
            } else {
               if ( $pwDbname   ) { undef $pwDbname  };
               if ( $pwUsername ) { undef $pwUsername};
               if ( $pwUserpass ) { undef $pwUserpass};
            }
         }
      }
      if ($Trace eq 'true') {
         print "TRACE: Exiting sub GetPassword()\n";
         print "TRACE: Returning: null\n";
      }
      # Password lookup failed.
      # ---------------------------
      return '';
   }
   if ($Trace eq 'true') {
      print "TRACE: Exiting sub GetPassword()\n";
      print "TRACE: Returning: null\n";
   }
   # Passsord lookup failed.
   # ---------------------------
   return '';
}
# ------------------------------------------------------------------------
# End GetPassword()
# ------------------------------------------------------------------------


# Sub : LoadScript($$)
# Desc: Load an Rman Script file.
# Args: 1: Script file name. 2: If true then comments will be stripped.
# Retn: 1: Contents of script file.
# ------------------------------------------------------------------------
sub LoadScript($$) {
   my $ScriptFilename = shift;
   my $FileContents   = '';

   if ($Trace eq 'true') {
      print "TRACE: Entering sub LoadScript(\$)\n";
      print "TRACE: Parameters:\n";
      print "TRACE:    \$ScriptFilename = $ScriptFilename\n";
   }

   # Locate the script file.
   # --------------------------
   if ((not (-f $ScriptFilename) and (-r $ScriptFilename))) {
      PrintWarning("Cannot open script file for read:" . $ScriptFilename);
   } else {
      if (! open(SCRIPT, "<$ScriptFilename")) {
         PrintWarning("Unable to open script file for read: $ScriptFilename\n");
         return 1;
      } else {
         while (my $Line = <SCRIPT>) {
            chomp($Line);
            $FileContents .= "$Line\n";
         }
        close(SCRIPT);
      }
      if ($Trace eq 'true') {
         foreach my $Line (split("\n", $FileContents)){
            print "TRACE: $Line\n";
         }
         print "TRACE: Exiting sub LoadScript(\$)\n";
      }
   }
   return $FileContents;
}
# ------------------------------------------------------------------------
# End LoadScript
# ------------------------------------------------------------------------

# ------------------------------------------------------------------------
# End Function Declarations
# ------------------------------------------------------------------------
