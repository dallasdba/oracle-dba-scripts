#!/usr/bin/env python

#--------------------------------------------------------------------------------------------------#
# Name: dbu (for Oracle)                                                                           #
# Auth: Randy Johnson                                                                              #
# Desc: Db Backup Utility for Oracle. Performs database backup tasks using Recovery Manager.       #
#                                                                                                  #
# Requirements:                                                                                    #
# - The database must be open read-write or read-only or the backup fails and the program exits.   #
# - Oracle thick client including SQL*Plus (sqlplus) and Recovery Manager (rman).                  #
#                                                                                                  #
# Wish List:                                                                                       #
# - Add "TO DESTINATION" feature.                                                                  #
# - Fix 00245, 00000, "control file backup failed in Oracle RAC might not be on shared storage.    #
#   // *Cause:  Failed to create a control file backup because some process                        #
#   //          signaled an error during backup creation. This is likely caused                    #
#   //          by the backup target (i.e., RMAN snapshot controlfile) being on                    #
#   //          a local file system so it could not be accessed by other instances.                #
#                                                                                                  #
# Date       Ver. Who              Change Description                                              #
# ---------- ---- ---------------- -------------------------------------------------------------   #
# 03/28/2022 1.00 Randy Johnson    First commit.                                                   #
# 03/29/2022 1.01                  Fixed 'reportschema' where it should be 'report_schema'.        #
# 03/30/2022 1.02                  Fixed get_password() where password is not returned when        #
#                                   decrypt = False. Improved messaging in get_db_state().         #
# 03/31/2022 1.03                  Disable Rman error checking when -debug used.                   #
# 04/04/2022 1.04                  Changed deletelogs parameter to deletearchlogs for clarity.     #
#                                  Fixed 'configure snapshot controlfile ...'.                     #
#                                  Fixed 'configure channel ...'.                                  #
#                                  For generate option, moved the prompt up to top of execution.   #
#                                  Fixed skip option. Now skip ... on each line.                   #
#                                  Fixed bug in validate_options() that caused invalid format.     #
# 04/05/2022 1.05                  Improved tracing in run_sqlplus().                              #
#                                  Removed get_inst_count() and renamed get_svc_count() to         #
#                                   get_inst_count(). Renamed svc_count to inst_count.             #
#--------------------------------------------------------------------------------------------------#

# --------------------------------------
# ---- Import Python Modules -----------
# --------------------------------------
from __future__   import print_function
#---
import sys
#---
from argparse     import ArgumentParser
from argparse     import RawDescriptionHelpFormatter
from datetime     import datetime
from math         import floor
from math         import log
from math         import pow
from os           import access
from os           import environ
from os           import getpid
from os           import listdir
from os           import makedirs
from os           import unlink
from os.path      import abspath
from os.path      import basename
from os.path      import isdir
from os.path      import isfile
from os.path      import join  as pathjoin
from os.path      import split as pathsplit
from os           import R_OK  as ReadOk
from os           import X_OK  as ExecOk
from re           import compile as regex_compile
from re           import match
from re           import search
from re           import sub
from re           import MULTILINE
from socket       import gethostname
from subprocess   import PIPE
from subprocess   import Popen
from subprocess   import STDOUT
from sys          import argv
from sys          import exit
from sys          import version_info

# Imports that are conditional on Python version.
# ------------------------------------------------
python_version = version_info[0] + (version_info[1] * .1)
if (python_version >= 3.2):
  from base64 import b64decode
  from configparser import ConfigParser as SafeConfigParser
elif (python_version >= 3.0):
  from configparser import SafeConfigParser
  from base64       import b64decode
else:
  from ConfigParser import SafeConfigParser

# Set min/max compatible Python versions.
# ----------------------------------------
minvers = 2.7
maxvers = 3.10

# --------------------------------------
# ---- Function / Class Definitions ----
# --------------------------------------
# --------------------------------------------------------------------------------------------------
# Name: Logger()
# Desc: Works like the Unix tee command. Everything written to stdout & stderr also get written to
#       the log file.
# --------------------------------------------------------------------------------------------------
class Logger(object):
  def __init__(self,filename):
    self.logfile  = filename
    self.terminal = sys.stdout
    self.log      = open(self.logfile, 'w')

    if python_version >= 3.0:
      self.encoding = sys.stdout.encoding
      self.flush    = sys.stdout.flush
      self.errors   = sys.stdout.errors

  def write(self, message):
    self.terminal.write(message)
    self.log.write(message)
# --------------------------------------------------------------------------------------------------
# End Logger()
# --------------------------------------------------------------------------------------------------

# --------------------------------------------------------------------------------------------------
# Name: yn()
# Desc: Takes a bool, returns string.
# Args: bool
# Retn: Yes/No/unknown
# --------------------------------------------------------------------------------------------------
def yn(b):
  if b == True:
    return 'Yes'
  elif b == False:
    return 'No'
  else:
    return 'unknown'
# --------------------------------------------------------------------------------------------------
# End yn()
# --------------------------------------------------------------------------------------------------

# --------------------------------------------------------------------------------------------------
# Name: tf()
# Desc: Takes a string, returns a boolean equivalent.
# Args: instr = string in the form of 'true/t/yes/y/false/f/no/n'
# Retn: True/False
# --------------------------------------------------------------------------------------------------
def tf(instr):
  if instr.upper() in('TRUE', 'T', 'YES', 'Y'):
    return True
  elif instr.upper() in('FALSE', 'F', 'NO', 'N'):
    return False
  else:
    return False
# --------------------------------------------------------------------------------------------------
# End tf()
# --------------------------------------------------------------------------------------------------

# --------------------------------------------------------------------------------------------------
# Def:  read_input()
# Desc: Prompts for input from the keyboard and returns values entered.
# Args: prompt - printed to the screen to prompt the user for input.
# Retn: value  - whatever is entered from the keyboard.
# --------------------------------------------------------------------------------------------------
def read_input(prompt):
  prompt = '\n{}: '.format(prompt)

  if(version_info[0] >= 3):
    return input(prompt)
  else:
    return raw_input(prompt)
# --------------------------------------------------------------------------------------------------
# End read_input()
# --------------------------------------------------------------------------------------------------

# --------------------------------------------------------------------------------------------------
# Name: string_to_bytes()
# Desc: Convert size expressed in form of 8G, 8, 8.01 to float(size_in_bytes)
# Args: size = string to convert
# Retn: size (expressed in float(bytes)). Returns 0 if error or if size=0[K|M|G|T] passed in.
# --------------------------------------------------------------------------------------------------
def string_to_bytes(size):
  if trace:
    print('TRACE:')
    print('TRACE: Begin string_to_bytes()')

  multiplier = 1

  try:
    size = size.upper()
  except:
    size = str(size).upper()

  # Determine size multiplier based on K,M,G,T
  if size[-1:] == 'Y':
    multiplier = 1024**8
    size = size[0:-1]
  elif size[-1:] == 'Z':
    multiplier = 1024**7
    size = size[0:-1]
  elif size[-1:] == 'E':
    multiplier = 1024**6
    size = size[0:-1]
  elif size[-1:] == 'P':
    multiplier = 1024**5
    size = size[0:-1]
  elif size[-1:] == 'T':
    multiplier = 1024**4
    size = size[0:-1]
  elif size[-1:] == 'G':
    multiplier = 1024**3
    size = size[0:-1]
  elif size[-1:] == 'M':
    multiplier = 1024**2
    size = size[0:-1]
  elif size[-1:] == 'K':
    multiplier = 1024
    size = size[0:-1]

  try:
    size = float(size) * multiplier
  except:
    print_message('Cannot convert: {} from type: {} to float'.format(bytes, type(bytes)), 'warning')
    size = 0.0

  if trace:
    print('TRACE:')
    print('TRACE: End string_to_bytes()')

  return size
# --------------------------------------------------------------------------------------------------
# End string_to_bytes()
# --------------------------------------------------------------------------------------------------

# --------------------------------------------------------------------------------------------------
# Name: reduce_size()
# Desc: Converts the size of a number from Bytes to string of B, KB, MB, .. Yeta Bytes
# Args: bytes = input string to reduce.
# Retn: formatted string
# --------------------------------------------------------------------------------------------------
def reduce_size(instr):
  if trace:
    print('TRACE:')
    print('TRACE: Begin reduce_size()')

  bytes = None
  mag   = (" (B)", " (KB)", " (MB)", " (GB)", " (TB)", " (PB)", " (EB)", " (ZB)", " (YB)")
  p     = 0
  i     = 0

  try:
    bytes = int(instr)
  except:
    print_message("Unable to convert value from type: {} to <class 'int'>".format(type(instr)), 'error')
    exit(1)

  if bytes < 1024:
    return '{:,}{}'.format(bytes, mag[0])
  else:
    i = int(floor(log(bytes,1024)))
    p = pow(1024,i)
    bytes = round(bytes/p,2)

  if trace:
    print('TRACE:')
    print('TRACE: End reduce_size()')

  return '{:,.2f}{}'.format(float(bytes), mag[i])
# --------------------------------------------------------------------------------------------------
# End reduce_size()
# --------------------------------------------------------------------------------------------------

# --------------------------------------------------------------------------------------------------
# Def:  parse_arguments()
# Desc: Process command line arguments (see argparse - ArgumentParser)
# Retn: args - dictionary of all arguments from the command line
#       trace - enable trace messages.
# --------------------------------------------------------------------------------------------------
def parse_arguments():
  args   = {}
  usage  = '{} -type [database|datafile|tablespace|arch|fra|register|crosscheck|...]'.format(cmd)
  usage += '\n [-servicename LABDB] [-debug] [-trace] [...]'
  usage += '\n'
  usage += '\nWhere:'
  usage += '\n  servicename : Oracle service name for the target database.'
  usage += '\n  debug       : Rman debug output'
  usage += '\n  trace       : Print trace output'
  usage += '\n  help        : Prints this message.'
  usage += '\n'
  usage += '\nExamples:'
  usage += '\n  {} -service LABDB -type database -device disk'.format(cmd)
  usage += '\n  {} -service LABDB -type database -device disk -debug'.format(cmd)
  usage += '\n  {} -service LABDB -type database -device disk -debug -trace'.format(cmd)
  usage += '\n  {} -service LABDB -type datafile -device sbt'.format(cmd)
  usage += '\n  {} -service LABDB -type tablespace -device sbt'.format(cmd)
  usage += '\n  {} -service LABDB -type crosscheck -device disk'.format(cmd)
  usage += "\n  {} -service LABDB -type fra -dev sbt -sbtlib 'ENV=(NB_ORA_CLIENT=my_host)'".format(cmd)
  usage += '\n  {} -service LABDB -type arch -device disk'.format(cmd)
  usage += '\n  {} -service LABDB -type resync'.format(cmd)
  usage += '\n  {} -service LABDB -type report_schema'.format(cmd)
  usage += '\n  {} -service LABDB -type report_obsolete -device disk'.format(cmd)
  usage += '\n  {} -service LABDB -type delete_obsolete -device sbt'.format(cmd)
  usage += '\n  {} -service LABDB -type validate_backup -device disk'.format(cmd)
  usage += '\n  {} -service LABDB -type validate_restore -device disk'.format(cmd)
  usage += '\n  {} -service LABDB -type report_need_backup'.format(cmd)
  usage += '\n  {} -service LABDB -type report_unrecoverable'.format(cmd)
  usage += '\n  {} -service LABDB -type list_expired -device sbt'.format(cmd)
  usage += '\n  {} -service LABDB -type delete_expired -device disk'.format(cmd)
  usage += '\n  {} -service LABDB -script my_backup_script.rcv'.format(cmd)
  usage += '\n'
  usage += "\nCommand Line     Config file / Parfile     Description"
  usage += "\n---------------- ------------------------- ------------------------------------------------------------"
  usage += "\narchlogs         archivelogs               Include archivelogs in backup"
  usage += "\narchcopies       archlog_copies            Number of archivelog copies."
  usage += "\ncontrolfile      controlfile               Include controlfile in backup (useful for tablespace or"
  usage += "\n                                           Datafile backups)."
  usage += "\ncatalog          catalog                   Service name of the RMAN catalog database."
  usage += "\ncatuser          catalog_user              Username for connecting to the RMAN Catalog database."
  usage += "\ncomprlevel       compression_level         Level of compression (basic, low, medium, high)."
  usage += "\ncomproptimized   compression_optimization  Optimize compression for load."
  usage += "\nconfigure        configure                 Configure static RMAN settings."
  usage += "\ncopy             copy                      Backup as copy (default is backup as backupset)."
  usage += "\ncreate           create                    Create a sample configuration file."
  usage += "\ncumulative       cumulative                Cumulative incremental backup (default differential)."
  usage += "\ndatafiles        datafiles                 Datafiles by name or by number used for -type datafile"
  usage += "\n                                           backup."
  usage += "\ndebug            debug                     Include RMAN debug information."
  usage += "\ndecrypt          decrypt                   Decrypt passwords."
  usage += "\ndeletearchlogs   delete_archivelogs        Delete archivelogs after backup (DELETE INPUT)."
  usage += "\ndeletedelay      delete_delay              Delay purge of archivelog backups (DELETE ARCHIVELOG ALL"
  usage += "\n                                           COMPLETED BEFORE 'SYSDATE-n')."
  usage += "\nobsolete         delete_obsolete           Delete obsolete backups at end of backup (DELETE force"
  usage += "\n                                           OBSOLETE)."
  usage += "\ndevice           device                    Device to use for backups (sbt, disk)."
  usage += "\ndirectory        directory                 Base directorty for backups to disk."
  usage += "\nchannels         disk_channels             Number of channels to allocate (per instance)."
  usage += "\nfilesperset      disk_files_per_set        Maximum number of datafile files per backupset."
  usage += "\npiecesize        disk_max_piece_size       Maximum size of backup pieces."
  usage += "\nsetsize          disk_max_set_size         Maximum set size for backup sets."
  usage += "\nrate             disk_streaming_rate       Maximum streaming rate per channel."
  usage += "\ndistchannels     distributed_channels      Include connect string for channel allocation (ALLOCATE"
  usage += "\n                                           CHANNEL ... CONNECT user/password@tnsname)."
  usage += "\ndistlist         distribution_list         Email addresses for notfications"
  usage += "\nforce            force                     Override static RMAN EXCLUDE ... setting."
  usage += "\nformat           format                    Format of backup pieces (for example %%d_%%U.bak)."
  usage += "\ngenerate         generate                  Generate RMAN script only (do not execute backup)."
  usage += "\nhelp             help                      Print usage."
  usage += "\nkeep             keep                      Override static RMAN retention (keep until 'sysdate+n')."
  usage += "\nldlibrarypath    ld_library_path           Set LD_LIBRARY_PATH."
  usage += "\nlevel            level                     Incremental level for incremental backups (full, 0, 1)."
  usage += "\ncorrupt          max_corrupt               Max # of corruptions permitted in a datafile before backup"
  usage += "\n                                           fails."
  usage += "\nduration         max_duration              Maximum duration for backup ()."
  usage += "\nopenfiles        max_open_files            Maximum # of open files per channel."
  usage += "\nnocatalog        no_catalog                Do not connect to the RMAN Catalog."
  usage += "\nnochecksum       no_checksum               Do not store checksum of datablocks in backup set."
  usage += "\nnoexclude        no_exclude                Ignore the static RMAN configuration setting for excluding"
  usage += "\n                                           certain tablespaces."
  usage += "\nnotify           notify                    Email notification (always, failure, off)."
  usage += "\nohome            oracle_home               ORACLE_HOME used for setting the Oracle environment."
  usage += "\noptimization     optimization              Enable backup optimization."
  usage += "\nparfile          parfile                   Name of the parameter file (if any) used for this backup"
  usage += "\n                                           type."
  usage += "\nplusarchlog      plus_archivelog           Use the PLUSARCHIVELOG method for including archivelogs in"
  usage += "\n                                           database backup."
  usage += "\nreportschema     report_schema             Add 'report schema;' to the top of the backup operation."
  usage += "\nretention        retention                 Sets static RMAN retention policy (CONFIGURE retention"
  usage += "\n                                           POLICY TO ...)."
  usage += "\nchannels         sbt_channels              Number of channels to allocate (per instance)."
  usage += "\nfilesperset      sbt_files_per_set         Maximum number of datafile files per backupset."
  usage += "\npiecesize        sbt_max_piece_size        Maximum size of backup pieces."
  usage += "\nrate             sbt_streaming_rate        Maximum streaming rate per channel."
  usage += "\nsbtlibrary       sbt_library               For tape backups, used for the parms section of ALLOCATE"
  usage += "\n                                           CHANNEL statement."
  usage += "\nscript           script                    Custom script."
  usage += "\nsetsize          {sbt}_max_set_size        Maximum set size for backup sets."
  usage += "\nsectionsize      section_size              Datafiles will be split at this size."
  usage += "\nservicename      service_name              TNS name used for connecting to the target database."
  usage += "\nshow             show                      Show RMAN script only. Do not execute backup."
  usage += "\nskip             skip                      Skip files that have certain status (any or all of readonly,"
  usage += "\n                                           offline, unavailable)."
  usage += "\ntnsadmin         tns_admin                 Set TNS_ADMIN environment variable for the backup sessions."
  usage += "\ntablespaces      tablespaces               Tablespaces by name or by number used for -type tablespace"
  usage += "\n                                           backup."
  usage += "\ntrace            trace                     Include {} program trace information in output.".format(cmd)
  usage += "\ntype             type                      Backup type (crosscheck, archivelog, database, datafile,"
  usage += "\n                                           tablespace, ...)."
  usage += "\nuser             user                      Username for connecting to the target database."
  usage += "\nversion          version                   Display {} version information.".format(cmd)
  usage += "\nwipelogs         wipe_logs                 Remove all {} log files - except for the current log.".format(cmd)

  # Parse command line arguments
  ap = ArgumentParser(formatter_class=RawDescriptionHelpFormatter, usage=usage, add_help=False)
  ap.version=banner

  # In the following section, 'p' is set so we can manage command line
  # arguments. Allows us to add more arguments after the parser is initialized.
  # ----------------------------------------------------------------------------
  p = []
  p.append( ap.add_argument('-archcopies',     '--archcopies',     dest='archlog_copies',           action='store',      default='',    type=str, metavar=''))
  p.append( ap.add_argument('-archlogs',       '--archlogs',       dest='archivelogs',              action='store_true', default=False)                      )
  p.append( ap.add_argument('-catalog',        '--catalog',        dest='catalog',                  action='store',      default='',    type=str, metavar=''))
  p.append( ap.add_argument('-catuser',        '--catuser',        dest='catalog_user',             action='store',      default='',    type=str, metavar=''))
  p.append( ap.add_argument('-channels',       '--channels',       dest='channels',                 action='store',      default='',    type=str, metavar=''))
  p.append( ap.add_argument('-comprlevel',     '--comprlevel',     dest='compression_level',        action='store',      default='',    type=str, metavar=''))
  p.append( ap.add_argument('-comproptimized', '--comproptimized', dest='compression_optimization', action='store_true', default=False)                      )
  p.append( ap.add_argument('-configure',      '--configure',      dest='configure',                action='store_true', default=False)                      )
  p.append( ap.add_argument('-controlfile',    '--controlfile',    dest='controlfile',              action='store_true', default=False)                      )
  p.append( ap.add_argument('-copy',           '--copy',           dest='copy',                     action='store_true', default=False)                      )
  p.append( ap.add_argument('-corrupt',        '--corrupt',        dest='max_corrupt',              action='store',      default='',    type=str, metavar=''))
  p.append( ap.add_argument('-create',         '--create',         dest='create_config',            action='store_true', default=False)                      )
  p.append( ap.add_argument('-cumulative',     '--cumulative',     dest='cumulative',               action='store_true', default=False)                      )
  p.append( ap.add_argument('-datafiles',      '--datafiles',      dest='datafiles',                action='store',      default='',    type=str, metavar=''))
  p.append( ap.add_argument('-debug',          '--debug',          dest='debug',                    action='store_true', default=False)                      )
  p.append( ap.add_argument('-decrypt',        '--decrypt',        dest='decrypt',                  action='store_true', default=False)                      )
  p.append( ap.add_argument('-deletedelay',    '--deletedelay',    dest='delete_delay',             action='store',      default='',    type=str, metavar=''))
  p.append( ap.add_argument('-deletearchlogs', '--deletearchlogs', dest='delete_archivelogs',       action='store_true', default=False)                      )
  p.append( ap.add_argument('-device',         '--device',         dest='device',                   action='store',      default='',    type=str, metavar=''))
  p.append( ap.add_argument('-directory',      '--directory',      dest='directory',                action='store',      default='',    type=str, metavar=''))
  p.append( ap.add_argument('-distchannels',   '--distchannels',   dest='distributed_channels',     action='store_true', default=False)                      )
  p.append( ap.add_argument('-distlist',       '--distlist',       dest='distribution_list',        action='store',      default='',    type=str, metavar=''))
  p.append( ap.add_argument('-duration',       '--duration',       dest='max_duration',             action='store',      default='',    type=str, metavar=''))
  p.append( ap.add_argument('-filesperset',    '--filesperset',    dest='files_per_set',            action='store',      default='',    type=str, metavar=''))
  p.append( ap.add_argument('-force',          '--force',          dest='force',                    action='store_true', default=False)                      )
  p.append( ap.add_argument('-format',         '--format',         dest='format',                   action='store',      default='',    type=str, )          )
  p.append( ap.add_argument('-generate',       '--generate',       dest='generate',                 action='store_true', default=False)                      )
  p.append( ap.add_argument('-help',           '--help',           dest='help',                     action='store_true')                                     )
  p.append( ap.add_argument('-keep',           '--keep',           dest='keep',                     action='store',      default='',    type=str, )          )
  p.append( ap.add_argument('-ldlibrarypath',  '--ldlibrarypath',  dest='ld_library_path',          action='store',      default='',    type=str, metavar=''))
  p.append( ap.add_argument('-level',          '--level',          dest='level',                    action='store',      default='',    type=str, metavar=''))
  p.append( ap.add_argument('-nocatalog',      '--nocatalog',      dest='no_catalog',               action='store_true', default=False)                      )
  p.append( ap.add_argument('-nochecksum',     '--nochecksum',     dest='no_checksum',              action='store_true', default=False)                      )
  p.append( ap.add_argument('-noexclude',      '--noexclude',      dest='no_exclude',               action='store_true', default=False)                      )
  p.append( ap.add_argument('-notify',         '--notify',         dest='notify',                   action='store',      default='off', type=str, metavar=''))
  p.append( ap.add_argument('-obsolete',       '--obsolete',       dest='delete_obsolete',          action='store_true', default=False)                      )
  p.append( ap.add_argument('-ohome',          '--ohome',          dest='oracle_home',              action='store',      default='',    type=str, metavar=''))
  p.append( ap.add_argument('-openfiles',      '--openfiles',      dest='max_open_files',           action='store',      default='',    type=str, metavar=''))
  p.append( ap.add_argument('-optimization',   '--optimization',   dest='optimization',             action='store_true', default=False)                      )
  p.append( ap.add_argument('-parfile',        '--parfile',        dest='parfile',                  action='store',      default='',    type=str, metavar=''))
  p.append( ap.add_argument('-piecesize',      '--piecesize',      dest='max_piece_size',           action='store',      default='',    type=str, metavar=''))
  p.append( ap.add_argument('-plusarchlogs',   '--plusarchlogs',   dest='plus_archivelog',          action='store_true', default=False)                      )
  p.append( ap.add_argument('-rate',           '--rate',           dest='streaming_rate',           action='store',      default='',    type=str, metavar=''))
  p.append( ap.add_argument('-reportschema',   '--reportschema',   dest='report_schema',            action='store_true', default=False)                      )
  p.append( ap.add_argument('-retention',      '--retention',      dest='retention',                action='store',      default='',    type=str, metavar=''))
  p.append( ap.add_argument('-sbtlib',         '--sbtlib',         dest='sbt_library',              action='store',      default='',    type=str, metavar=''))
  p.append( ap.add_argument('-script',         '--script',         dest='script',                   action='store',      default='',    type=str, metavar=''))
  p.append( ap.add_argument('-sectionsize',    '--sectionsize',    dest='section_size',             action='store',      default='',    type=str, metavar=''))
  p.append( ap.add_argument('-servicename',    '--servicename',    dest='service_name',             action='store',      default='',    type=str, metavar=''))
  p.append( ap.add_argument('-setsize',        '--setsize',        dest='max_set_size',             action='store',      default='',    type=str, metavar=''))
  p.append( ap.add_argument('-show',           '--show',           dest='show',                     action='store_true', default=False)                      )
  p.append( ap.add_argument('-skip',           '--skip',           dest='skip',                     action='store',      default='',    type=str, metavar=''))
  p.append( ap.add_argument('-tablespaces',    '--tablespaces',    dest='tablespaces',              action='store',      default='',    type=str, metavar=''))
  p.append( ap.add_argument('-tnsadmin',       '--tnsadmin',       dest='tns_admin',                action='store',      default='',    type=str, metavar=''))
  p.append( ap.add_argument('-trace',          '--trace',          dest='trace',                    action='store_true', default=False)                      )
  p.append( ap.add_argument('-type',           '--type',           dest='type',                     action='store',      default='',    type=str, metavar=''))
  p.append( ap.add_argument('-user',           '--user',           dest='user',                     action='store',      default='',    type=str, metavar=''))
  p.append( ap.add_argument('-version',        '--version',        dest='version',                  action='store_true', default=False)                      )
  p.append( ap.add_argument('-wipelogs',       '--wipelogs',       dest='wipe_logs',                action='store_true', default=False)                      )

  arguments = ap.parse_args()
  trace = arguments.trace

  if trace:
    print('TRACE: Begin parse_arguments()')

  # Display help
  # -----------------------------
  if arguments.help:
    print(usage)
    exit(0)

  osid = ''
  try:
    osid = environ['ORACLE_SID']
  except:
    pass

  if trace:
    print('TRACE:')
    if 'ORACLE_SID' in environ:
      print('TRACE: ORACLE_SID={}'.format(environ['ORACLE_SID']))
    else:
      print('TRACE: ORACLE_SID not set.')
    # print('TRACE: osid={}'.format(osid))

  # The following _actions usage is a more direct way to get the original
  # command line option but it is not supported (documented) so we're
  # using the 'p' list to store the parsed arguments whereby we can extract
  # them in a supported manner.
  # ------------------------------------------------------------------------
  # for action in ap._actions:
  #   print(action.dest, action.option_strings[0])   # <-- undocumented
  # exit(0)

  # Grab the original command line argument from the add_argument()
  # function. We'll store this along with the dest and the value.
  # We'll be using throughout the rest of the program.
  # --------------------------------------------------------------------
  for parser in p:
    args[parser.dest] = {'name' : parser.option_strings[0]}

  # We want to add the value of the arguments to the args dictionary. Then we
  # will have the argument, the stored dest, and the stored value all in one place
  # -------------------------------------------------------------------------------
  for a in sorted(vars(arguments)):
    value = getattr(arguments, a)
    args[a]['value'] = getattr(arguments, a)

  # Create a sample configuration file
  # -----------------------------------
  if arguments.create_config:
    generate_file = True
    if isfile(config_file):
      generate_file = read_input('{} already exists. Overwrite? (y/N)'.format(config_file))
      generate_file = tf(generate_file)  # set to True/False
    if generate_file:
      try:
        with open(config_file, 'w') as f:
          f.write("archivelogs                  = true")
          f.write("\narchlog_copies             = 2")
          f.write("\ncatalog                    = RCAT")
          f.write("\ncatalog_user               = rman")
          f.write("\ncompression_level          = low")
          f.write("\ncompression_optimization   = true")
          f.write("\nconfigure                  = true")
          f.write("\ncontrolfile                = true")
          f.write("\ncumulative                 = true")
          f.write("\ndecrypt                    = true")
          f.write("\ndelete_archivelogs         = true")
          f.write("\ndelete_obsolete            = true")
          f.write("\ndevice                     = disk")
          f.write("\ndirectory                  = /u01/database_backups")
          f.write("\ndisk_channels              = 8")
          f.write("\ndistributed_channels       = true")
          f.write("\ndistribution_list          = fred.flintstone@bedrock.com")
          f.write("\nformat                     = %d_%U.bak")
          f.write("\nlevel                      = 0")
          f.write("\nnotify                     = fail")
          f.write("\noptimization               = false")
          f.write("\noracle_home                = /u01/app/oracle/product/19.0.1/dbhome_1")
          f.write("\nplus_archivelog            = false")
          f.write("\nreport_schema              = true")
          f.write("\nretention                  = RECOVERY WINDOW OF 7 DAYS")
          f.write("\nsbt_channels               = 4")
          f.write("\nsbt_library                = sbt_library=libopc.so, sbt_parms=(opc_pfile=/u01/app/oracle/product/12.2.0.1/dbhome_1/dbs/opcC1X1DGCB.ora)")
          f.write("\nservice_name               = LABDB")
          f.write("\nskip                       = readonly,offline,inaccessible")
          f.write("\ntype                       = database")
          f.write("\nuser                       = sys")
          f.write("\nwipe_logs                  = true")
          f.write("\n")
          f.write("\n")
          f.write("\n# Option                    Example                Comments")
          f.write("\n# ------------------------  ---------------------  --------------------------------------------------------------------")
          f.write("\n# archlog_copies            2                      Backup archivelog all not backed up 2 times;")
          f.write("\n# archivelogs               true|false             Include archivelogs in the backup. (see also, -plusarchivelog).")
          f.write("\n# catalog                   RCAT                   Tnsname for the rman catalog (must be able to tnsping).")
          f.write("\n# catalog_user              recoman                Username for connecting to the RMAN Catalog database.")
          f.write("\n# compression_level         basic/low/medium/high  Level of compression to be appied to the backup files.")
          f.write("\n# compression_optimization  true|false             Optimze backup compression for load? (ignored on standby databases).")
          f.write("\n# configure                 true|false             Execute RMAN configuration commands as part of the RMAN operation.")
          f.write("\n# controlfile               true|false             Include controlfile in backup. Useful for datafile and tablespace backups.")
          f.write("\n# copy                      true|false             Backup as copy (default is backup as backupset).")
          f.write("\n# create                    true|false             Create a sample configuration file.")
          f.write("\n# cumulative                true|false             Default is differential for level 1 backups.")
          f.write("\n# datafiles                 1,2,3,4                Comma delimited list of datafiles to backup when used with -type.")
          f.write("\n# debug                     true|false             Run RMAN with the debug option (rman debug target ...)")
          f.write("\n# decrypt                   true|false             Decrypt passwords (when reading them from the password file.")
          f.write("\n# delete_archivelogs        true|false             Remove archivelogs after they are backed up. (backup as backupset")
          f.write("\n#                                                  archivelog all delete input).")
          f.write("\n# delete_delay              7                      Delay the deletion of backed up archive logs for n days, 'COMPLETED")
          f.write("\n#                                                  BEFORE 'SYSDATE-n').' datafile. Either file ID or FQN file names are")
          f.write("\n#                                                  permitted.")
          f.write("\n# delete_obsolete           true|false             Delete obsolete backups at end of backup (DELETE force OBSOLETE).")
          f.write("\n# device                    disk/sbt               Allocate channels for this type device. If 'tape' is specified, then")
          f.write("\n#                                                  it is automaticadlly reset to sbt.")
          f.write("\n# directory                 /database_backups      If device type disk, this is the base directory for backup.")
          f.write("\n# disk_channels             8                      Number of channels to allocate (per instance).")
          f.write("\n# disk_files_per_set        5                      Maximum files per set for database, datafile, tablespace, archivelog")
          f.write("\n#                                                  backups.")
          f.write("\n# disk_max_piece_size       2g                     Maximum size of a backup piece. Usefull for filesystems with 2G limit.")
          f.write("\n# disk_max_set_size                                Maximum size of a backup set.")
          f.write("\n# disk_streaming_rate       20M                    Maximum streaming rate per channel.")
          f.write("\n# distributed_channels      true|false             Allocate channels across all viable instances CHANNEL ... CONNECT")
          f.write("\n#                                                  user/password@tnsname).")
          f.write("\n# distribution_list         fred@bedrock.com       Comma separated list of email addresses for notification emails.")
          f.write("\n# force                     true|false             Rman will ignore backup optimization option setting.")
          f.write("\n# format                    Backup_%d_%U           Format of backup piece file names. File names must be unique. Typical")
          f.write("\n#                                                  settings include: %d_%u_%p_%c.")
          f.write("\n# generate                  true|false             Generate rman script only. Do not execute.")
          f.write("\n# help                                             Print usage.")
          f.write("\n# keep                      90                     Number of days to keep a backup set. This is used to override the")
          f.write("\n#                                                  normal retention policy.")
          f.write("\n# ld_library_path           /u02/network/admin     Sets the LD_LIBRARY_PATH environment variable required by some vendors.")
          f.write("\n# level                     0|1|full               Sets the incremental level of the backup.")
          f.write("\n# max_duration              5:30                   Maximum duration for backups. Backup will terminate at this limit")
          f.write("\n# max_corrupt               2000                   Max # of corruptions permitted in a datafile before backup fails.")
          f.write("\n#                                                  even if not finished. Duration is specified in HH:MM format but can")
          f.write("\n#                                                  be any number of hours:minutes (999999:9999999 is valid).")
          f.write("\n# no_catalog                                       Do not connect to the RMAN Catalog.")
          f.write("\n# no_checksum               true|false             Do not store checksum of datablocks in backup set.")
          f.write("\n# no_exclude                true|false             Rman will ignore the configuration setting for excluding")
          f.write("\n#                                                  tablespaces, CONFIGURE EXCLUDE FOR TABLESPACE tbs1, tbs2...")
          f.write("\n# notify                    failure/always/off     Send email notification. Off is default.")
          f.write("\n# oracle_home               /u01/app/oracle/...    ORACLE_HOME is set to this value for configuring your rman session.")
          f.write("\n# max_open_files            30                     Maximum # of open files per channel.")
          f.write("\n# optimization              true|false             Enable backup optimization.")
          f.write("\n# parfile                                          Name of the parameter file (if any) used for this backup operation.")
          f.write("\n# plus_archivelog           true|false             Adds backup of archived redo logs to the database backup.")
          f.write("\n#                                                  You may use this instead of the -archlogs option. When archivelogs")
          f.write("\n#                                                  are stored in the FRA this is the easiest way to automatically age")
          f.write("\n#                                                  them out. Make sure to use BACKUP OPTIMIZATION (RMAN Configure")
          f.write("\n#                                                  command) to keep from backing up archivelogs over and over again.")
          f.write("\n# report_schema             true|false             Add 'report schema;' to the top of the backup operation.")
          f.write("\n# retention                 redundancy 1           Used with the configure option to set retention of backups. Valid")
          f.write("\n#                                                  options are:")
          f.write("\n#                                                  1) none -- configure retention policy to none;")
          f.write("\n#                                                  2) redundancy nnn -- configure retention policy to redundancy 1;")
          f.write("\n#                                                  3) recovery window of nnn days -- configure retention policy to")
          f.write("\n#                                                     recovery window of 7 days;")
          f.write("\n#                                                   Also used with the delete_obsolete as follows:")
          f.write("\n#                                                    Resulting RMAN command: 'delete force noprompt obsolete redundancy 1'.")
          f.write("\n#                                                    device type disk;'")
          f.write("\n#                                                    Resulting RMAN command: 'delete force noprompt obsolete recovery'.")
          f.write("\n#                                                    window of 7 days device type disk;'")
          f.write("\n# sbt_channels              8                      Channels to allocate. This is per instance if you specify.")
          f.write("\n#                                                  distributed_channels = true (-distchan on command line).")
          f.write("\n# sbt_files_per_set         5                      Maximum files per set for database, datafile, tablespace, arch")
          f.write("\n#                                                  backups.")
          f.write("\n# sbt_library               {see help below}       Used for backing up to SBT media. Settings required for RMAN to talk")
          f.write("\n#                                                  to your media manager.")
          f.write("\n# sbt_max_piece_size        2g                     Maximum size of a backup piece.")
          f.write("\n# sbt_max_set_size          100G                   Maximum size of a backup set. Usefull for tape size limitations.")
          f.write("\n# sbt_streaming_rate        20M                    Controls the max throughput of backup operations. Usefull for throttling")
          f.write("\n#                                                  I/O on busy systems or during peak periods of the day.")
          f.write("\n# script                    /scripts/backup.rcv    Fully qualified name of external RMAN script to run.")
          f.write("\n# section_size              20g                    Datafiles will be split at this size. Not compatible with the -copy")
          f.write("\n#                                                  option. Values allowed include nn...nnnn[{k|m|g}]. For example,")
          f.write("\n#                                                  -sectionsize 250G.")
          f.write("\n# service_name              rman_backup_svc        Tnsname for connecting to the target database.")
          f.write("\n# show                      true|false             If true do not execute, just show resulting rman commands.")
          f.write("\n# skip                      readonly               Skip files that are readonly, offline, or inaccessible (comma delimited")
          f.write("\n#                                                  list).")
          f.write("\n# tablespaces               SYSTEM,SYSAUX          Comma delimited list of tablespaces to back when used with type=tablespace.")
          f.write("\n# tns_admin                 /my_tns_direcroty      Set TNS_ADMIN environment variable for the backup sessions.")
          f.write("\n# type                      arch                   Backup the archived redologs.")
          f.write("\n# type                      crosscheck             Perform a crosscheck of backups.")
          f.write("\n# type                      database               Backup the full database.")
          f.write("\n# type                      datafile               Backup specific datafiles only (see datafiles option).")
          f.write("\n# type                      delete_expired         Delete expired backups.")
          f.write("\n# type                      delete_obsolete        Delete obsolete backups.")
          f.write("\n# type                      fra                    Backup the Recovery Area.")
          f.write("\n# type                      list_expired           Report expired backups.")
          f.write("\n# type                      register               Register database with Catalog.")
          f.write("\n# type                      report_need_backup     Report files in need of a fresh backup.")
          f.write("\n# type                      report_schema          Report all files in the database.")
          f.write("\n# type                      report_obsolete        Report obsolete backups.")
          f.write("\n# type                      report_unrecoverable   Report files in which nologging types have occured since the last backup.")
          f.write("\n# type                      resync                 Resync with the catalog.")
          f.write("\n# type                      tablespace             Backup specific tablesaces only, (see -type tablespace option).")
          f.write("\n# type                      validate_backup        Perform a BACKUP CHECK LOGICAL VALIDATE.")
          f.write("\n# type                      validate_restore       Perform a RESTORE DATABASE VALIDATE CHECK LOGICAL.")
          f.write("\n# trace                                            Include {} program trace information in output.".format(cmd))
          f.write("\n# user                                             Username for connecting to the target database.")
          f.write("\n# version                                          Display {} version information.".format(cmd))
          f.write("\n# wipe_logs                 true|false             Remove all {} log files - except for the current log.".format(cmd))
          f.write("\n# ")
          f.write("\n#-------------------------------------------------------------------------------------------------------------------------------")
          f.write("\n#")
          f.write("\n# Examples of sbt_library")
          f.write("\n# -------------------------")
          f.write("\n# sbt_library = oracle.disksbt")
          f.write("\n# sbt_library = ENV=(NB_ORA_SCHED=daily_full, NB_ORA_CLIENT=vxp101-m3bk, NB_ORA_POLICY=TEST-DB-ORACLE_AGENT-UNCOMPRESSED)")
          f.write("\n# sbt_library = SBT_LIBRARY=libopc.so, SBT_PARMS=(OPC_PFILE=/u01/app/oracle/product/12.2.0.1/dbhome_1/dbs/opcC1ETDGCB.ora)")
      except:
        print_message("Unable to open configuration file for write: {}".format(config_file), 'error')
        exit(1)
      exit(0)
    else:
      exit(0)

  # Display version information
  # -----------------------------
  if arguments.version:
     print('{}: Release {} - {}, {}'.format(cmd_long, vsn, dev_state, vsn_date))
     exit(0)

  if trace:
    print('TRACE:')
    print('TRACE: End parse_arguments()')

  return args, trace
# --------------------------------------------------------------------------------------------------
# End parse_arguments()
# --------------------------------------------------------------------------------------------------

# --------------------------------------------------------------------------------------------------
# Name: Options()
# Desc: Class for merging/validating/configuring all application options. Each option will be stored
#       as a member variable.
# --------------------------------------------------------------------------------------------------
class Options(object):
  def __init__(self, args):
    if trace:
      print('TRACE:')
      print('TRACE: Begin Options.__init__()')

    self.args                      = args
    self.cfgopts                   = {}
    self.opts                      = {}
    self.paropts                   = {}

    self.archlog_copies            = ''
    self.archivelogs               = False
    self.controlfile               = False
    self.cat_password              = ''
    self.catalog_user              = ''
    self.catalog                   = ''
    self.channels                  = ''
    self.compression_level         = ''
    self.compression_optimization  = False
    self.configure                 = False
    self.copy                      = False
    self.create_config             = False
    self.cumulative                = False
    self.datafiles                 = ''
    self.debug                     = False
    self.decrypt                   = False
    self.delete_archivelogs        = False
    self.delete_delay              = ''
    self.delete_obsolete           = False
    self.device                    = ''
    self.directory                 = ''
    self.distributed_channels      = False
    self.distribution_list         = ''
    self.script                    = ''
    self.files_per_set             = ''
    self.force                     = False
    self.format                    = ''
    self.generate                  = False
    self.help                      = ''
    self.home                      = ''
    self.keep                      = ''
    self.ld_library_path           = ''
    self.level                     = ''
    self.max_corrupt               = ''
    self.max_duration              = ''
    self.max_open_files            = ''
    self.max_piece_size            = ''
    self.max_set_size              = ''
    self.no_catalog                = False
    self.no_checksum               = False
    self.no_exclude                = False
    self.notify                    = 'off'
    self.type                      = ''
    self.oracle_home               = ''
    self.oracle_sid                = ''
    self.optimization              = False
    self.parfile                   = self.args['parfile']['value']
    self.plus_archivelog           = False
    self.report_schema             = False
    self.retention                 = ''
    self.sbt_library               = ''
    self.section_size              = ''
    self.service_name              = ''
    self.show                      = False
    self.skip                      = ''
    self.streaming_rate            = ''
    self.tablespaces               = ''
    self.tns_admin                 = ''
    self.trace                     = self.args['trace'  ]['value']
    self.user                      = ''
    self.version                   = ''
    self.wipe_logs                 = False

    # these are not offered on the command line or config/parm files
    # but we want to include them here since they are globally used.
    # --------------------------------------------------------------
    self.db_name                   = ''
    self.db_unique_name            = ''
    self.dbid                      = ''
    self.db_open_mode              = ''
    self.prim_db_unique_name       = ''
    self.db_role                   = ''
    self.db_so_stat                = ''
    self.db_reco_dest              = ''
    self.db_reco_size              = ''
    self.cluster_db                = ''

    self.hostname                  = gethostname()
    self.instances                 = []
    self.password                  = ''
    self.inst_count                = 0
    self.user                      = ''
    self.cluster_db                = ''
    self.dbid                      = ''
    self.db_name                   = ''
    self.db_open_mode              = ''
    self.db_reco_dest              = ''
    self.db_reco_size              = ''
    self.db_role                   = ''
    self.db_so_stat                = ''
    self.db_unique_name            = ''
    self.prim_db_unique_name       = ''

    self.types = [
      'arch',
      'crosscheck',
      'database',
      'datafile',
      'delete_expired',
      'delete_obsolete',
      'fra',
      'list_expired',
      'register',
      'report_need_backup',
      'report_schema',
      'report_obsolete',
      'report_unrecoverable',
      'resync',
      'tablespace',
      'validate_backup',
      'validate_restore']

    self.cfgopts = self.load_options(config_file)
    if self.parfile:
      self.paropts = self.load_options(self.parfile)

    self.rc, self.msg = self.merge()
    if self.rc:
      print_message(self.msg, 'error')
      exit(self.rc)

    if trace:
      print('TRACE:')
      print('TRACE: End Options.__init__()')
  # --------------------------------------------------------------------------------------------------
  # End __init__()
  # --------------------------------------------------------------------------------------------------

  # --------------------------------------------------------------------------------------------------
  # Name: load_options()
  # Desc: Parse and load the configuration file, and parfile (if any).
  # Args: infile = Configuration file name or parameter file name
  # Retn: options = dictionary of options loaded
  # --------------------------------------------------------------------------------------------------
  def load_options(self, infile):
    if self.trace:
      print('TRACE:')
      print('TRACE: Begin Options.load_options({})'.format(infile))

    self.infile  = infile
    self.options = {}

    self.additional_opts = [
     'disk_channels',
     'disk_files_per_set',
     'disk_max_corrupt',
     'disk_max_duration',
     'disk_max_open_files',
     'disk_max_piece_size',
     'disk_max_set_size',
     'disk_streaming_rate',
     'sbt_channels',
     'sbt_files_per_set',
     'sbt_library',
     'sbt_max_corrupt',
     'sbt_max_duration',
     'sbt_max_open_files',
     'sbt_max_piece_size',
     'sbt_max_set_size',
     'sbt_streaming_rate']

    # Load the config file.
    # ----------------------
    try:
      with open(self.infile, 'r') as self.f:
        self.contents = self.f.readlines()
      self.contents = [ self.line.split('#')[0].strip() for self.line in self.contents ]   # remove comments (everything to the right of '#')
      self.contents = [ self.line for self.line in self.contents if self.line]             # remove blank lines
    except:
      print('Cannot open file for read: {}'.format(self.infile))
      exit(1)

    # Load parameters into options dictionary...
    # Here is where we decide which key=val pairs from the config or par files may be loaded.
    # if value is not null and key is in the program's arguments list -or- in the additional
    # options list (used to include special options like sbt_max_corrupt and disk_max_corrupt
    # into the complete set of options).
    # -----------------------------------------------------------------------------------------
    for self.line in self.contents:
      self.pos = self.line.find('=')
      self.key = self.line[0:self.pos].strip().lower()
      self.val = self.line[self.pos + 1:].strip()
      if (self.key in args) or (self.key in self.additional_opts) and self.val:
        self.options[self.key.lower()] = self.val

    if self.trace:
      print('TRACE:')
      print('TRACE: End Options.load_options({})'.format(self.infile))
    return self.options
  # --------------------------------------------------------------------------------------------------
  # End load_options()
  # --------------------------------------------------------------------------------------------------

  # --------------------------------------------------------------------------------------------------
  # Name: merge()
  # Desc: merge options from command line, config file and par file
  # Retn: <none>
  # --------------------------------------------------------------------------------------------------
  def merge(self):
    if self.trace:
      print('TRACE:')
      print('TRACE: Begin Options.merge()')

    self.lower   = []
    self.boolean = []
    self.int     = []

    self.int.append('archlog_copies')
    # ---
    self.int.append('channels')
    self.int.append('disk_channels')
    self.int.append('sbt_channels')
    # ---
    self.int.append('files_per_set')
    self.int.append('disk_files_per_set')
    self.int.append('sbt_files_per_set')
    # ---
    self.int.append('keep')
    self.int.append('max_corrupt')
    self.int.append('max_open_files')

    self.lower.append('device')
    self.lower.append('level')
    self.lower.append('notify')
    self.lower.append('retention')
    self.lower.append('type')

    self.boolean.append('archivelogs')
    self.boolean.append('compression_optimization')
    self.boolean.append('configure')
    self.boolean.append('controlfile')
    self.boolean.append('copy')
    self.boolean.append('cumulative')
    self.boolean.append('debug')
    self.boolean.append('decrypt')
    self.boolean.append('delete_archivelogs')
    self.boolean.append('delete_obsolete')
    self.boolean.append('distributed_channels')
    self.boolean.append('force')
    self.boolean.append('generate')
    self.boolean.append('no_checksum')
    self.boolean.append('no_exclude')
    self.boolean.append('optimization')
    self.boolean.append('plus_archivelog')
    self.boolean.append('report_schema')
    self.boolean.append('show')
    self.boolean.append('trace')
    self.boolean.append('wipe_logs')

    # set device type here...
    # -----------------------
    try:
      self.device = self.cfgopts['device'].lower()
      # self.device = self.device.lower()
    except:
      pass
    try:
      self.device = self.paropts['device'].lower()
    except:
      pass
    try:
      self.device = self.args['device']['value'].lower()
    except:
      pass

    if self.device == 'tape':
      self.device = 'sbt'
    elif not self.device:
      self.device = 'disk'
    elif self.device not in ('disk','sbt'):
      self.msg = 'Invalid device type: {}'.format(self.device)
      return 1, self.msg

    if self.trace:
      print('TRACE:')
      print('TRACE: Config File Options')
      print('TRACE: ------------------------- -----------------------------------------------------------------')
      for self.key in sorted(self.cfgopts):
        self.val = self.cfgopts[self.key]
        print('TRACE: {:<25s} {}'.format(self.key, self.val))

    # Load configuration file options into the opts dictionary
    # ---------------------------------------------------------
    for self.key in sorted(self.cfgopts):
      self.val = self.cfgopts[self.key]
      if self.key in self.boolean:
        self.val = tf(self.val)
      elif self.key in self.lower:
        self.val = self.val.lower()

      # map disk_{} and sbt_{} options
      # -------------------------------
      if self.key == self.device + '_channels':
        self.opts['channels'] = self.val
      elif self.key == self.device + '_files_per_set':
        self.opts['files_per_set' ] = self.val
      elif self.key == self.device + '_max_piece_size':
        self.opts['max_piece_size'] = self.val
      elif self.key == self.device + '_max_set_size':
        self.opts['max_set_size'] = self.val
      elif self.key == self.device + '_streaming_rate':
        self.opts['streaming_rate'] = self.val
      else:
        self.opts[self.key.lower()] = self.val

    if self.trace:
      print('TRACE:')
      print('TRACE: Parameter File Options')
      print('TRACE: ------------------------- -----------------------------------------------------------------')
      for self.key in sorted(self.paropts):
        self.val = self.paropts[self.key]
        print('TRACE: {:<25s} {}'.format(self.key, self.val))

    # Load parameter file options into the opts dictionary
    # -----------------------------------------------------
    for self.key in sorted(self.paropts):
      self.val = self.paropts[self.key]
      if self.key in self.boolean:
        self.val = tf(self.val)
      elif self.key in self.lower:
        self.val = self.val.lower()

      # map disk_{} and sbt_{} options
      # -------------------------------
      if self.key == self.device + '_channels':
        self.opts['channels'] = self.val
      elif self.key == self.device + '_files_per_set':
        self.opts['files_per_set' ] = self.val
      elif self.key == self.device + '_max_piece_size':
        self.opts['max_piece_size'] = self.val
      elif self.key == self.device + '_max_set_size':
        self.opts['max_set_size'] = self.val
      elif self.key == self.device + '_streaming_rate':
        self.opts['streaming_rate'] = self.val
      else:
        self.opts[self.key.lower()] = self.val

    if self.trace:
      print('TRACE:')
      print('TRACE: Command Line Options')
      print('TRACE: ------------------------- -----------------------------------------------------------------')
      for self.key in sorted(self.args):
        if self.args[self.key]['value']:
          print('TRACE: {:<25s} {}'.format(self.key, self.args[self.key]['value']))

    # Load command line options into the self.opts dictionary
    # --------------------------------------------------------
    for self.key in sorted(self.args):
      if self.args[self.key]['value']:
        self.opts[self.key.lower()] = self.args[self.key]['value']

    # Convert distribution_list from str to list
    # -------------------------------------------
    try:
      self.opts['distribution_list'] = [ x.strip() for x in self.opts['distribution_list'].split(',') ]
    except:
      self.opts['distribution_list'] = []

    # Convert datafiles from str to list
    # -----------------------------------
    try:
      self.opts['datafiles'] = [ x.strip() for x in self.opts['datafiles'].split(',') ]
      self.opts['datafiles'] = sorted(list(set(self.opts['datafiles'])))
    except:
      self.opts['datafiles'] = []

    # Convert tablespaces from str to list
    # -------------------------------------
    try:
      self.opts['tablespaces'] = [ x.strip() for x in self.opts['tablespaces'].split(',') ]
      self.opts['tablespaces'] = sorted(list(set(self.opts['tablespaces'])))
    except:
      self.opts['tablespaces'] = []

    # Convert skip from str to list
    # ------------------------------
    try:
      self.opts['skip'] = [ x.strip() for x in self.opts['skip'].split(',') ]
    except:
      self.opts['skip'] = []

    # Convert type of certain options to integer
    # -------------------------------------------
    for self.key in self.opts:
      self.val = self.opts[self.key]
      if self.key in self.int:
        self.val = string_to_bytes(self.val)
        try:
          self.opts[self.key] = int(self.val)
        except:
          print_message('Cannot convert string to integer. Option:{}, Value:{}'.format(self.key, self.opts[self.key]), 'error')
          exit(1)

    if self.trace:
      print('TRACE:')
      print('TRACE: Merged Options')
      print('TRACE: ------------------------- -----------------------------------------------------------------')
      for self.key in sorted(self.opts):
        print('TRACE: {:<25s} {}'.format(self.key, self.opts[self.key]))

    if 'archivelogs'              in self.opts: self.archivelogs              = self.opts['archivelogs']
    if 'archlog_copies'           in self.opts: self.archlog_copies           = self.opts['archlog_copies']
    if 'catalog'                  in self.opts: self.catalog                  = self.opts['catalog']
    if 'catalog_user'             in self.opts: self.catalog_user             = self.opts['catalog_user']
    if 'channels'                 in self.opts: self.channels                 = self.opts['channels']
    if 'compression_level'        in self.opts: self.compression_level        = self.opts['compression_level']
    if 'compression_optimization' in self.opts: self.compression_optimization = self.opts['compression_optimization']
    if 'configure'                in self.opts: self.configure                = self.opts['configure']
    if 'controlfile'              in self.opts: self.controlfile              = self.opts['controlfile']
    if 'copy'                     in self.opts: self.copy                     = self.opts['copy']
    if 'create_config'            in self.opts: self.create_config            = self.opts['create_config']
    if 'cumulative'               in self.opts: self.cumulative               = self.opts['cumulative']
    if 'datafiles'                in self.opts: self.datafiles                = self.opts['datafiles']
    if 'debug'                    in self.opts: self.debug                    = self.opts['debug']
    if 'decrypt'                  in self.opts: self.decrypt                  = self.opts['decrypt']
    if 'delete_archivelogs'       in self.opts: self.delete_archivelogs       = self.opts['delete_archivelogs']
    if 'delete_delay'             in self.opts: self.delete_delay             = self.opts['delete_delay']
    if 'delete_obsolete'          in self.opts: self.delete_obsolete          = self.opts['delete_obsolete']
    if 'device'                   in self.opts: self.device                   = self.opts['device']
    if 'directory'                in self.opts: self.directory                = self.opts['directory']
    if 'distributed_channels'     in self.opts: self.distributed_channels     = self.opts['distributed_channels']
    if 'distribution_list'        in self.opts: self.distribution_list        = self.opts['distribution_list']
    if 'files_per_set'            in self.opts: self.files_per_set            = self.opts['files_per_set']
    if 'force'                    in self.opts: self.force                    = self.opts['force']
    if 'format'                   in self.opts: self.format                   = self.opts['format']
    if 'generate'                 in self.opts: self.generate                 = self.opts['generate']
    if 'help'                     in self.opts: self.help                     = self.opts['help']
    if 'keep'                     in self.opts: self.keep                     = self.opts['keep']
    if 'ld_library_path'          in self.opts: self.ld_library_path          = self.opts['ld_library_path']
    if 'level'                    in self.opts: self.level                    = self.opts['level']
    if 'max_corrupt'              in self.opts: self.max_corrupt              = self.opts['max_corrupt']
    if 'max_duration'             in self.opts: self.max_duration             = self.opts['max_duration']
    if 'max_open_files'           in self.opts: self.max_open_files           = self.opts['max_open_files']
    if 'max_piece_size'           in self.opts: self.max_piece_size           = self.opts['max_piece_size']
    if 'max_set_size'             in self.opts: self.max_set_size             = self.opts['max_set_size']
    if 'no_catalog'               in self.opts: self.no_catalog               = self.opts['no_catalog']
    if 'no_checksum'              in self.opts: self.no_checksum              = self.opts['no_checksum']
    if 'no_exclude'               in self.opts: self.no_exclude               = self.opts['no_exclude']
    if 'notify'                   in self.opts: self.notify                   = self.opts['notify']
    if 'optimization'             in self.opts: self.optimization             = self.opts['optimization']
    if 'oracle_home'              in self.opts: self.oracle_home              = self.opts['oracle_home']
    if 'parfile'                  in self.opts: self.parfile                  = self.opts['parfile']
    if 'plus_archivelog'          in self.opts: self.plus_archivelog          = self.opts['plus_archivelog']
    if 'report_schema'            in self.opts: self.report_schema            = self.opts['report_schema']
    if 'retention'                in self.opts: self.retention                = self.opts['retention']
    if 'sbt_library'              in self.opts: self.sbt_library              = self.opts['sbt_library']
    if 'script'                   in self.opts: self.script                   = self.opts['script']
    if 'section_size'             in self.opts: self.section_size             = self.opts['section_size']
    if 'service_name'             in self.opts: self.service_name             = self.opts['service_name']
    if 'show'                     in self.opts: self.show                     = self.opts['show']
    if 'skip'                     in self.opts: self.skip                     = self.opts['skip']
    if 'streaming_rate'           in self.opts: self.streaming_rate           = self.opts['streaming_rate']
    if 'tns_admin'                in self.opts: self.tns_admin                = self.opts['tns_admin']
    if 'tablespaces'              in self.opts: self.tablespaces              = self.opts['tablespaces']
    if 'trace'                    in self.opts: self.trace                    = self.opts['trace']
    if 'type'                     in self.opts: self.type                     = self.opts['type']
    if 'user'                     in self.opts: self.user                     = self.opts['user']
    if 'version'                  in self.opts: self.version                  = self.opts['version']
    if 'wipe_logs'                in self.opts: self.wipe_logs                = self.opts['wipe_logs']

    # finalize initializing opts.oracle_home
    if self.oracle_home:
      environ['ORACLE_HOME'] = self.oracle_home
    elif 'ORACLE_HOME' in environ:
      self.oracle_home = environ['ORACLE_HOME']
    elif 'ORACLE_SID' in environ:                  # try to find the ORACLE_HOME by looking up the ORACLE_SID in the oratab file...
      self.oracle_sid = environ['ORACLE_SID']
      self.contents = ''
      for self.oratab in oratab_loc:
        try:
          with open(self.oratab, 'r') as self.f:
            self.contents = self.f.readlines()
            self.contents = [ self.line.split('#')[0].strip() for self.line in self.contents ]  # remove comments (everything to the right of '#')
            self.contents = [ self.line for self.line in self.contents if self.line]            # remove blank lines
          break
        except:
          continue
      for self.line in self.contents:
        self.count = self.line.count(':')
        if self.count >= 1:
          if self.line.split(':')[0] == self.oracle_sid:
            self.candidate = self.line.split(':')[1]
            if isdir(self.candidate) and isfile(pathjoin(self.candidate, 'bin', 'rman')):
              self.oracle_home = self.candidate
              environ['ORACLE_HOME'] = self.oracle_home
              break
    if self.oracle_home:
      if not isdir(self.oracle_home):
        self.msg = 'Invalid ORACLE_HOME: {}'.format(self.oracle_home)
        return 1, self.msg
      else:
        if not access(self.oracle_home, ReadOk) and not access(self.oracle_home, ExecOk):
          self.msg = 'Check permissions on ORACLE_HOME: {}'.format(self.oracle_home)
          return 1, self.msg
    if 'ORACLE_HOME' not in environ:
      if not self.oracle_sid:
        self.msg = 'Unable to determine ORACLE_HOME. No ORACLE_SID specified.'
      else:
        self.msg = 'Unable to determine ORACLE_HOME. Check ORACLE_SID and oratab file.'
      return 1, self.msg

    if not self.type:
      self.type = 'database'
    elif self.type not in self.types:
      msg = 'The type ({}) option must be one of:'.format(self.args['type']['name'])
      msg += '\n  - ' + '\n  - '.join(sorted(self.types))
      msg += '\n\nYou specified: {}'.format(self.type)
      print_message(msg, 'error')
      exit(1)

    # Set the long description
    # -------------------------
    self.description = ''
    if self.script:
      self.description = 'Run an external RMAN script.'
    else:
      if self.type:
        if self.type == 'database':
          if self.level == 'full':
            self.description = 'Full Online Database Backup'
          else:
            self.description = 'Incremental Online Database Backup'
        elif self.type == 'datafile':
          if self.level == 'full':
            self.description = 'Datafile Backup'
          else:
            self.description  = 'Incremental Datafile Backup'
        elif self.type == 'tablespace':
          if self.level == 'full':
            self.description = 'Tablespace Backup'
          else:
            self.description = 'Incremental Tablespace Backup'
        if self.copy:
          self.description += ' as Copy'
        else:
          self.description += ' as Backupset'
        if self.type == 'crosscheck':
          self.description = 'Verify Backups Exist on Backup Media'
        elif self.type == 'fra':
          self.description = 'Backup Fast Recovery Area'
        elif self.type == 'arch':
          self.description = 'Backup Archived Redologs'
        elif self.type == 'resync':
          self.description = 'Resync Controlfile with Recovery Catalog'
        elif self.type == 'register':
          self.description = 'Register Database to Recovery Catalog'
        elif self.type == 'delete_expired':
          self.description = 'Crosscheck and Delete Expired Backup Sets'
        elif self.type == 'delete_obsolete':
          self.description = 'Delete Obsolete Backup Sets'
          self.delete_obsolete = True
        elif self.type == 'validate_backup':
          self.description = 'Dry Run Backup - Validate Integrity of Database'
        elif self.type == 'validate_restore':
          self.description = 'Dry Run Restore - Validate Integrity of Most Recent Backup'
        elif self.type == 'report_need_backup':
          self.description = 'Datafiles Requiring Backup According to Retention Policy'
        elif self.type == 'report_unrecoverable':
          self.description  = 'Report Backups Needed Due To Nologging Operations'
        elif self.type == 'report_obsolete':
          self.description = 'Report Backupsets No Longer Needed for Recovery'
        elif self.type == 'report_schema':
          self.description = 'Report all files that make up the database.'
        elif self.type == 'list_expired':
          self.description = 'Report Backupsets Not Found on Backup Media'

    if self.trace:
      print('TRACE:')
      print('TRACE: End Options.merge()')

    return 0, ''
# --------------------------------------------------------------------------------------------------
# End Options()
# --------------------------------------------------------------------------------------------------

# --------------------------------------------------------------------------------------------------
# Name: Sqlplus
# Desc: Runs a query in sqlplus and parses it into a table (list of lists).
#       other functionality like formulating row count and other useful
#       stuff one would expect in a class like this.
# --------------------------------------------------------------------------------------------------
class Sqlplus:
  # --------------------------------------------------------------------------------------------------
  # Name: __init__()
  # Desc: initialize the class variables
  # Args: sql = SQL statement
  #       colsep = column separator we will inject intop the results so we can parse it.
  # Retn: <none>
  # --------------------------------------------------------------------------------------------------
  def __init__(self, tgt_connstr, sql='', colsep='~'):
    if trace:
      print('TRACE:')
      print('TRACE: Begin Sqlplus.__init__({}, {}, {})'.format(tgt_connstr, sql, colsep))

    self.table         = []
    self.row_count     = 0
    self.error_stack   = []
    self.rc            = 0
    self.stdout        = ''
    self.colsep        = colsep
    self.sql           = sql.rstrip() + ';'
    self.facilities    = {}
    self.sqlplus       = ''
    self.ignore_errors = ['ERROR:','RMAN-00571','RMAN-00569','RMAN-00558','RMAN-04008','ORA-28011']

    self.rc, self.msg  = self.set_env()
    if self.rc:
      print_message(self.msg, 'error')
      exit(self.rc)

    if trace:
      print('TRACE:')
      print('TRACE: End Sqlplus.__init__({}, {}, {})'.format(tgt_connstr, sql, colsep))
  # --------------------------------------------------------------------------------------------------
  # End __init__()
  # --------------------------------------------------------------------------------------------------

  # --------------------------------------------------------------------------------------------------
  # Name: set_env()
  # Desc: Configures the environment for sqlplus execution
  # Args: <none>
  # Retn: 1 = return code from sqlplus session
  #       2 = error message
  # --------------------------------------------------------------------------------------------------
  def set_env(self):
    if trace:
      print('TRACE:')
      print('TRACE: Begin Sqlplus.set_env()')

    self.sqlplus = ''
    self.sqlplus_candidates = (
     pathjoin(environ['ORACLE_HOME'], 'bin', 'sqlplus'),
     pathjoin(environ['ORACLE_HOME'], 'sqlplus')
    )

    if opts.tns_admin:
      if isdir(opts.tns_admin):
        environ['TNS_ADMIN'] = opts.tns_admin
      else:
        self.msg = 'Directory for TNS_ADMIN not found: {}'.format(opts.tns_admin)
        return 1, self.msg

    for self.sqlplus_candidate in self.sqlplus_candidates:
      if isfile(self.sqlplus_candidate):
        if access(self.sqlplus_candidate, ReadOk) and access(self.sqlplus_candidate, ExecOk):
          self.sqlplus = self.sqlplus_candidate
          break
    if not self.sqlplus:
      return 1, 'Unable to identify valid sqlplus executable.'

    if not opts.ld_library_path:
      opts.ld_library_path = pathjoin(environ['ORACLE_HOME'], 'lib')
    if not isdir(opts.ld_library_path):
      self.msg = 'Directory for LD_LIBRARY_PATH not found: {}'.format(opts.ld_library_path)
      return 1, self.msg
    elif 'LD_LIBRARY_PATH' not in environ:
      environ['LD_LIBRARY_PATH'] = opts.ld_library_path
    else:
      environ['LD_LIBRARY_PATH'] = '{}:{}'.format(opts.ld_library_path, environ['LD_LIBRARY_PATH'])

    self.facilities_file = pathjoin(opts.oracle_home, 'lib', 'facility.lis')
    if not isfile(self.facilities_file):
      self.facilities_file = pathjoin(opts.oracle_home, 'facility.lis')
      if not isfile(self.facilities_file):
        self.msg = 'Facilities file not found: {}'.format(self.facilities_file)
        self.facilities_file = ''

    self.contents = ''
    if self.facilities_file:
      try:
        with open(self.facilities_file, 'r') as self.f:
          self.contents = self.f.readlines()
        self.contents = [ self.line.split('#')[0].strip() for self.line in self.contents ]   # remove comments (everything to the right of '#')
        self.contents = [ self.line for self.line in self.contents if self.line]             # remove blank lines
      except:
        self.msg = 'Cannot open facilities file for read: {}'.format(self.facilities_file)
        return 1, self.msg
      for self.line in self.contents:
        if self.line.count(':') == 3:   # ignore lines that do not contain 3 ':' characters
          self.facility, self.component, self.rename, self.description = self.line.split(':')
          if self.facility:
            self.facilities[self.facility.strip()] = {
             'component'   : self.component.strip(),
             'rename'      : self.rename.strip(),
             'description' : self.description.strip()
            }

    if trace:
      # print('TRACE:')
      print('TRACE: End Sqlplus.set_env()')

    return 0, ''
  # --------------------------------------------------------------------------------------------------
  # End set_env()
  # --------------------------------------------------------------------------------------------------

  # --------------------------------------------------------------------------------------------------
  # Name: execute_sql()
  # Desc: Executes sql statements in sqlplus and captures and parses the output
  # Args: sql = sql statements to execute.
  # Retn: rc = sqlplus return code
  #       stdout = stdout + stderr produced by sqlplus
  # --------------------------------------------------------------------------------------------------
  def execute_sql(self, sql=''):
    if trace:
      print('TRACE:')
      print('TRACE: Begin Sqlplus.execute_sql()')

    self.sql = sql
    self.table = []
    self.rc, self.stdout, self.error_stack = self.run_sqlplus()

    # if self.rc == 0:
    # Create a two dimentional list (tabular result set) from standard out.
    for self.row in self.stdout.strip().split('\n'):
      self.row = self.row.strip()
      if self.row:
        self.err_cnt = 0
        for self.err in self.ignore_errors:
          if self.err in self.row:
            self.err_cnt += 1
        if self.err_cnt == 0:
          self.columns = self.row.split(self.colsep)
          self.table.append(self.columns)
          self.row_count += 1

    if trace:
      print('TRACE:')
      print('TRACE: End Sqlplus.execute_sql())')

    return self.rc, self.stdout
  # --------------------------------------------------------------------------------------------------
  # End execute_sql()
  # --------------------------------------------------------------------------------------------------

  # --------------------------------------------------------------------------------------------------
  # Name: lookup_error()
  # Desc: This function works like the Oracle script 'oraerr'. It looks up errors like 'ORA-01219' in
  #       the Oracle messages files and returns something like the following ...
  #       ------------------------------------------------------------------------------
  #       01219, 00000, 'database not open: queries allowed on fixed tables/views only'
  #       // *Cause:  A query was issued against an object not recognized as a fixed
  #       //          table or fixed view before the database has been opened.
  #       // *Action: Re-phrase the query to include only fixed objects, or open the
  #       //          database.
  #       ------------------------------------------------------------------------------
  # Args: error = error code in the form of PREFIX-NNNNN
  # Retn: rc = sqlplus return code
  #       message_list = error message in list format.
  # --------------------------------------------------------------------------------------------------
  def lookup_error(self, error):
    if trace:
      print('TRACE:')
      print('TRACE: Begin Sqlplus.lookup_error({})'.format(self.error))

    self.message_list  = []
    self.header_found  = False

    try:
      self.facility, self.error_code = self.error.lower().split('-')
    except:
      self.rc = 1
      print('\nInvalid error code.')
      return self.rc, []

    if not self.facility in self.facilities.keys():
      self.rc = 1
      print('\nInvalid facility:', self.facility)
      return self.rc, []
    else:
      self.messages_file = pathjoin(opts.oracle_home, self.facilities[self.facility]['component'], 'mesg', self.facility + 'us.msg')

    self.msg_file_contents = ''
    try:
      with open(self.messages_file, 'r') as self.mf:
        self.msg_file_contents = self.mf.readlines()
    except:
      self.rc = 1
      print('\nCannot open Messages file: ' + self.messages_file + ' for read.')
      return self.rc, []

    for self.line in self.msg_file_contents:
      if self.header_found:
        self.match_obj = match(r'//,*', self.line)
        if self.match_obj:
          self.message_list.append(self.line.strip())
        else:
          self.rc = 1
          return self.rc, self.message_list
      else:
        self.match_obj = match('[0]*' + self.error_code + ',', self.line)
        if self.match_obj:
            self.error_code = self.match_obj.group()
            self.error_code = self.error_code[0:self.error_code.find(',')]
            self.message_list.append(self.line.strip())
            self.header_found = True
    if len(self.message_list) == 0:
      # If error code could not be found let's trim off leading 0's and try again...
      # -----------------------------------------------------------------------------
      self.error_code = str(int(self.error_code))
      for self.line in self.msg_file_contents:
        if self.header_found:
            self.match_obj = match(r'//,*', self.line)
            if self.match_obj:
              self.message_list.append(self.line.strip())
            else:
              return self.rc, self.message_list
        else:
          self.match_obj = match('[0]*' + self.error_code + ',', self.line)
          if self.match_obj:
              self.error_code = self.match_obj.group()
              self.error_code = self.error_code[0:self.error_code.find(',')]
              self.message_list.append(self.line.strip())
              self.header_found = True

    if len(self.message_list) == 0:
      print('error not found  : ' + self.error_code)
      print('Msg file         : ' + self.messages_file)

    if trace:
      print('TRACE:')
      print('TRACE: Begin Sqlplus.lookup_error({})'.format(error))

    return self.rc, self.message_list
  # --------------------------------------------------------------------------------------------------
  # End lookup_error()
  # --------------------------------------------------------------------------------------------------

  # --------------------------------------------------------------------------------------------------
  # Name: print_error()
  # Args: <none>
  # Desc: Prints errors returned by sqlplus
  # --------------------------------------------------------------------------------------------------
  def print_error(self):
    if trace:
      print('TRACE:')
      print('TRACE: Begin Sqlplus.print_error())')

    if not opts.show:
      print('\n-- Stdout ----------------------------------------------------------------------')
      print(self.stdout)
      print('--------------------------------------------------------------------------------')

    # Print Explanation for error...
    if errlkp:
      for self.error in self.error_stack:
        self.rc, self.explain_list = self.lookup_error(self.error)
        if len(self.explain_list) > 0:
          print('\n-- Explanation -----------------------------------------------------------------')
          print('Error: {}\n'.format(self.error))
          for self.line in self.explain_list:
            print(self.line)
          print('--------------------------------------------------------------------------------')

    if trace:
      print('TRACE:')
      print('TRACE: Begin Sqlplus.print_error({})')

    return
  # --------------------------------------------------------------------------------------------------
  # End print_error
  # --------------------------------------------------------------------------------------------------

  # --------------------------------------------------------------------------------------------------
  # Name: run_sqlplus()
  # Desc: Call sqlplus and execute SQL statement(s)
  # Args: <none>
  # Retn: rc = sqlplus return code
  #       stdout =
  #       error_stack = error messages in list format.
  # --------------------------------------------------------------------------------------------------
  def run_sqlplus(self):
    if trace:
      print('TRACE:')
      print('TRACE: Begin Sqlplus.run_sqlplus()')

    self.error_stack = []
    self.stdout      = ''
    self.header      = ''
    self.rc          = 0

    self.header += 'btitle              off\n'
    self.header += 'repfooter           off\n'
    self.header += 'repheader           off\n'
    self.header += 'ttitle              off\n'
    self.header += 'set appinfo         off\n'
    self.header += 'set arraysize       500\n'
    self.header += 'set autocommit      off\n'
    self.header += 'set autoprint       off\n'
    self.header += 'set autorecovery    off\n'
    self.header += 'set autotrace       off\n'
    self.header += 'set blockterminator \'.\'\n'
    self.header += 'set cmdsep          off\n'
    self.header += 'set colsep          \' \'\n'
    self.header += 'set concat          \'.\'\n'
    self.header += 'set copycommit      0\n'
    self.header += 'set copytypecheck   on\n'
    self.header += 'set define          \'&\'\n'
    self.header += 'set describe        depth 1 linenum off indent on\n'
    self.header += 'set document        off\n'
    self.header += 'set echo            off\n'
    self.header += 'set embedded        off\n'
    self.header += 'set escape          off\n'
    self.header += 'set escchar         off\n'
    self.header += 'set feedback        off\n'
    self.header += 'set flush           on\n'
    self.header += 'set heading         off\n'
    self.header += 'set headsep         \'|\'\n'
    self.header += 'set linesize        32767\n'
    self.header += 'set loboffset       1\n'
    self.header += 'set logsource       \'\'\n'
    self.header += 'set long            10000000\n'
    self.header += 'set longchunksize   10000000\n'
    self.header += 'set markup html     off \n'
    self.header += 'set newpage         1\n'
    self.header += 'set null            \'\'\n'
    self.header += 'set numformat       \'\'\n'
    self.header += 'set numwidth        15\n'
    self.header += 'set pagesize        0\n'
    self.header += 'set pause           off\n'
    self.header += 'set pno             0\n'
    self.header += 'set recsep          wrap\n'
    self.header += 'set recsepchar      \' \'\n'
    self.header += 'set serveroutput    on size unlimited\n'
    self.header += 'set shiftinout      invisible\n'
    self.header += 'set showmode        off\n'
    self.header += 'set space           1\n'
    self.header += 'set sqlblanklines   off\n'
    self.header += 'set sqlcase         mixed\n'
    self.header += 'set sqlcontinue     \'> \'\n'
    self.header += 'set sqlnumber       on\n'
    self.header += 'set sqlprefix       \'#\'\n'
    self.header += 'set sqlterminator   \';\'\n'
    self.header += 'set suffix          sql\n'
    self.header += 'set tab             off\n'
    self.header += 'set termout         on\n'
    self.header += 'set time            off\n'
    self.header += 'set timing          off\n'
    self.header += 'set trimout         on\n'
    self.header += 'set trimspool       on\n'
    self.header += 'set underline       \'-\'\n'
    self.header += 'set verify          off\n'
    self.header += 'set wrap            on\n'
    self.header += '\n'

    self.sql = self.header + self.sql
    if self.connstr.upper().startswith('SYS/'):
      self.connstr += ' as sysdba'

    if opts.trace:
      print('TRACE:')
      print('TRACE: {}'.format([self.sqlplus, '-S', '-L', self.connstr]))

    self.proc = Popen([self.sqlplus, '-S', '-L', self.connstr], stdin=PIPE, stdout=PIPE, stderr=STDOUT, \
     shell=False, universal_newlines=True, close_fds=True)

    # Execute the SQL
    self.proc.stdin.write(self.sql)

    # Fetch the output
    self.stdout, self.junk = self.proc.communicate()
    self.stdout = self.stdout.strip()

    # check stdout for errors like RMAN-00569, ORA-01219, ...
    # -------------------------------------------------------
    self.error_stack = []
    self.pattern = regex_compile(r'(?:\n)?(?:\s)?([A-Za-z0-9]+-\d+): (?:.*)', MULTILINE)
    self.iterate = self.pattern.finditer(self.stdout)
    for self.error in self.iterate:
      if self.error.groups()[0] not in self.ignore_errors:
        self.rc = 1
        self.error_stack.append(self.error.groups()[0])

    if trace:
      print('TRACE:')
      print('TRACE: End Sqlplus.run_sqlplus()')

    return self.rc, self.stdout, self.error_stack
  # --------------------------------------------------------------------------------------------------
  # End run_sqlplus()
  # --------------------------------------------------------------------------------------------------

  # --------------------------------------------------------------------------------------------------
  # Name: get_db_state()
  # Desc: Get the current state of the database (down, mounted, open)
  # Args: connstr = Database connect string
  # Retn: rc = return code from sqlplus session
  #       1 = OFFLINE, STARTED, MOUNTED, OPEN, UNKNOWN
  # --------------------------------------------------------------------------------------------------
  def get_db_state(self, connstr):
    if trace:
      print('TRACE:')
      print('TRACE: Begin Sqlplus.get_db_state({})'.format(connstr))

    self.connstr   = connstr
    self.sql       = "SELECT " + sql_header + "'STATUS' || " + colsep + "|| UPPER(status) FROM v$instance;"
    self.rc        = 1
    self.db_status = 'UNKNOWN'

    self.rc, self.stdout = self.execute_sql(self.sql)
    if self.rc:
      self.print_error()
      print_message('Cannot determine database state.', 'error')
      exit(self.rc)

    for self.row in self.table:
      if (self.row[0] == 'STATUS') and (self.row[1] in ('STARTED','MOUNTED','OPEN')):
        self.rc = 0
        self.db_status = self.row[1]
        break

    if trace:
      print('TRACE:')
      print('TRACE: End get_db_state(rc = {}, db_status = {})'.format(self.rc, self.db_status))

    return self.rc, self.db_status
  # --------------------------------------------------------------------------------------------------
  # End get_db_state()
  # --------------------------------------------------------------------------------------------------

  # --------------------------------------------------------------------------------------------------
  # Name: get_inst_count()
  # Desc: Get the number of running instances advertising the target service
  #       name.
  # Args: connstr = Connect string
  #       service_name = database service name
  # Retn: 1: # of instances advertising the service name (active instances).
  # ------------------------------------------------------------------------
  def get_inst_count(self, connstr, service_name):
    if trace:
      print('TRACE:')
      print('TRACE: Begin Sqlplus.get_inst_count({}, {})'.format(connstr, service_name))

    self.connstr      = connstr
    self.service_name = service_name
    self.count        = 0
    self.sql          = "SELECT " + sql_header
    self.sql         += "\n       'COUNT' || " + colsep + "|| count(*)"
    self.sql         += "\n  FROM gv$active_services s"
    self.sql         += "\n     , gv$instance        i"
    self.sql         += "\n WHERE s.inst_id = i.inst_id"
    self.sql         += "\n   AND UPPER(s.name) = '{}'".format(self.service_name.upper())
    self.sql         += "\n   AND i.status in ('MOUNTED','OPEN');"

    self.rc, self.stdout = self.execute_sql(self.sql)
    if self.rc:
      self.print_error()
      exit(self.rc)

    if self.rc:
      print_message('Unable to determine number of instances for service name: {}'.format(self.service_name), 'error')
      exit(1)
    else:
      for self.row in self.table:
        if self.row[0] == 'COUNT':
          try:
            self.count = int(self.row[1])
            break
          except:
            rc = 1
            self.msg  = 'Unexpected results from sqlplus.'
            self.msg += '\n\nSQL statement:\n{}'.format(self.sql)
            self.msg += '\n---\nValue returned: {}'.format(self.stdout)
            print_message(self.msg, 'error')

    if trace:
      print('TRACE:')
      print('TRACE: End Sqlplus.get_inst_count({}, {})'.format(connstr, service_name))

    return(self.rc, self.count)
  # ------------------------------------------------------------------------
  # End get_inst_count()
  # ------------------------------------------------------------------------

  # ------------------------------------------------------------------------
  # Name: get_db_version()
  # Desc: Determine the Oracle RDBMS version
  # Args: connstr = Database connect string
  # Retn: 1 = Return Code (rc != 0 indicates a failure).
  #       2 = version (ie. 12.2, 18.0, 19.2, ...)
  # ------------------------------------------------------------------------
  def get_db_version(self, connstr):
    if trace:
      print('TRACE:')
      print('TRACE: Begin Sqlplus.get_db_version({})'.format(connstr))

    self.connstr  = connstr
    self.db_vsn   = ''
    self.sql      = "SELECT " + sql_header
    self.sql     += "\n       'BANNER' ||" + colsep + "|| banner"
    self.sql     += "\n  FROM v$version"
    self.sql     += "\n WHERE banner LIKE 'Oracle%';"

    self.rc, self.stdout = self.execute_sql(self.sql)
    if self.rc:
      self.print_error()
      exit(self.rc)

    if self.rc:
      self.msg = 'Unable to determine Oracle version.\n\n'
      self.msg += self.stdout.replace('\n\n', '\n')
      print_message(self.msg, 'caution')
    else:
      for self.row in self.table:
        if self.row[0] == 'BANNER':
          self.found = match(r'Oracle.*Release ([\d]+\.[\d]+)(\.[\d]+\.[\d]+\.[\d]+)?.*', self.row[1])
          if self.found:
            self.db_vsn = self.found.groups()[0]
          break

    if trace:
      print('TRACE: Returning: rc = {}, db_vsn = {}'.format(self.rc, self.db_vsn))
      print('TRACE: End get_db_version()\n')

    return self.rc, self.db_vsn
  # ------------------------------------------------------------------------
  # End get_db_version()
  # ------------------------------------------------------------------------

  # --------------------------------------------------------------------------------------------------
  # Name: get_db_info()
  # Desc: Get information about the the database from v$database
  # Args: connstr = Database connect string
  # Retn: rc = return code
  #       info = Dictionary of: db_name, db_unique_name, open_mode, db_role, switchover_status
  # --------------------------------------------------------------------------------------------------
  def get_db_info(self, connstr):
    if trace:
      print('TRACE:')
      print('TRACE: Begin Sqlplus.get_db_info({})'.format(connstr))

    self.connstr = connstr
    self.info    = {}

    self.sql  = "SELECT " + sql_header + "\n       'DB_NAME'"                + " || " + colsep + " || name                          \n  FROM v$database;\n\n"
    self.sql += "SELECT " + sql_header + "\n       'DB_UNIQUE_NAME'"         + " || " + colsep + " || db_unique_name                \n  FROM v$database;\n\n"
    self.sql += "SELECT " + sql_header + "\n       'DBID'"                   + " || " + colsep + " || dbid                          \n  FROM v$database;\n\n"
    self.sql += "SELECT " + sql_header + "\n       'OPEN_MODE'"              + " || " + colsep + " || UPPER(open_mode)              \n  FROM v$database;\n\n"
    self.sql += "SELECT " + sql_header + "\n       'PRIMARY_DB_UNIQUE_NAME'" + " || " + colsep + " || UPPER(primary_db_unique_name) \n  FROM v$database;\n\n"
    self.sql += "SELECT " + sql_header + "\n       'DATABASE_ROLE'"          + " || " + colsep + " || UPPER(database_role)          \n  FROM v$database;\n\n"
    self.sql += "SELECT " + sql_header + "\n       'SWITCHOVER_STATUS'"      + " || " + colsep + " || UPPER(switchover_status)      \n  FROM v$database;\n\n"
    self.sql += "SELECT " + sql_header + "\n       'RECOVERY_DEST'"          + " || " + colsep + " || value                         \n  FROM v$parameter\n WHERE UPPER(name) = 'DB_RECOVERY_FILE_DEST';\n\n"
    self.sql += "SELECT " + sql_header + "\n       'RECOVERY_SIZE'"          + " || " + colsep + " || value                         \n  FROM v$parameter\n WHERE UPPER(name) = 'DB_RECOVERY_FILE_DEST_SIZE';\n\n"
    self.sql += "SELECT " + sql_header + "\n       'CLUSTER_DATABASE'"       + " || " + colsep + " || parallel                      \n  FROM v$instance;\n\n"
    self.sql += "SELECT " + sql_header + "\n       'DB_HOSTNAME'"            + " || " + colsep + " || host_name                     \n  FROM v$instance;\n\n"
    self.sql = self.sql.strip()

    if trace:
       print('TRACE:')
       for self.s in self.sql.split('\n'):
         print('TRACE: {}'.format(self.s))

    self.rc, self.stdout = self.execute_sql(self.sql)
    if self.rc:
      self.print_error()
      exit(self.rc)

    for self.row in self.table:
      self.key, self.value = self.row
      self.info[self.key]  = self.value

    if trace:
       print('TRACE:')
       print('TRACE: Returning:')
       for self.key in self.info:
         print('TRACE:   {:<25} : {}'.format(self.key, self.info[self.key]))
       print('TRACE:')
       print('TRACE: End get_db_info()')

    return(self.rc, self.info)
  # --------------------------------------------------------------------------------------------------
  # End get_db_info()
  # --------------------------------------------------------------------------------------------------
# --------------------------------------------------------------------------------------------------
# End Sqlplus()
# --------------------------------------------------------------------------------------------------

# --------------------------------------------------------------------------------------------------
# Name: Rman
# Desc: Runs rman commands.
# Args: RCV, string, containing rman commands or run block to execute.
#       err_check, True/False determines whether or not to check output for errors.
#       connstr, used for connecting to the database
# Retn: If err_check=True then return:
#          rc (return code, integer, 0=no errors)
#          Output (string, stdout+stderr)
#          ErrorList (list, error stack)
#       If err_check=False then return Stdout only
# --------------------------------------------------------------------------------------------------
class Rman:
  # --------------------------------------------------------------------------------------------------
  # Name: __init__()
  # Desc: initialize the class variables
  # Args: rcv = RMAN commands
  # Retn: <none>
  # --------------------------------------------------------------------------------------------------
  def __init__(self, rcv=''):
    if trace:
      print('TRACE:')
      print('TRACE: Begin Rman.__init__({})'.format(rcv))

    self.error_stack  = []
    self.rc           = 0
    self.stdout       = ''
    self.rcv          = rcv
    self.facilities   = {}
    self.now          = datetime.now().strftime('%m/%d/%Y %H:%M')
    self.rman         = ''
    self.configlist   = []
    self.header       = '#------------------------------------------------------------------------------'
    self.header      += '\n# Name        : {}'.format(cmd)
    self.header      += '\n# Description : {}'.format(opts.description)
    self.header      += '\n# Source      : Generated by {} {}'.format(cmd, self.now)
    self.header      += '\n# Usage       : rman cmdfile <script> [log=<logfile> [append]] [DEBUG]'
    self.header      += '\n#------------------------------------------------------------------------------\n'
    self.header      += '\nconnect target {}'.format(opts.tgt_connstr)

    if opts.cat_connstr:
      self.header += '\nconnect catalog {}'.format(opts.cat_connstr)

    if opts.configure:
      if opts.db_state not in ('MOUNTED','OPEN'):
        self.msg  = 'The database must be MOUNTED or OPEN in order to make configuration changes.'
        self.msg += '\nSkipping RMAN configuration commands.'
        print_message(self.msg, 'note');
      else:
        self.header += "\n"
        self.header += "\n# Configure RMAN"
        self.header += "\n#----------------------------------------------------------"

        # For Data Guard Primary databases only.
        # ---------------------------------------
        if opts.db_role == 'PRIMARY':
          # self.configlist.append("configure archivelog deletion policy to applied on standby;")
          if opts.retention:
            self.configlist.append("configure retention policy to {};".format(opts.retention))
          if opts.compression_level:
            self.tmp = "configure compression algorithm '{}' as of release 'default' optimize for load".format(opts.compression_level.upper())
            if opts.compression_optimization:
              self.tmp += " true;"
            else:
              self.tmp += " false;"
            self.configlist.append(self.tmp)
            del self.tmp

        # For both Primary and Standby Databases.
        # ----------------------------------------
        self.configlist.append("configure default device type to disk;")
        self.configlist.append("configure maxsetsize to unlimited;")
        self.configlist.append("configure rman output to keep for 90 days;")

        if opts.archlog_copies:
          self.configlist.append("configure archivelog deletion policy to backed up {} times to device type {};".format(opts.archlog_copies, opts.device))
          self.configlist.append("configure archivelog backup copies for device type {} to {};".format(opts.device, opts.archlog_copies))

        # Configure backup optimization
        # ------------------------------
        self.tmp = "configure backup optimization"
        if opts.optimization:
          self.tmp += " on;"
        else:
          self.tmp += " off;"
        self.configlist.append(self.tmp)

        self.tmp = "configure device type {} parallelism {} backup type to".format(opts.device, opts.channels)
        if opts.compression_level:
          self.tmp += " compressed"
        if opts.copy:
          self.tmp += " copy;"
        else:
          self.tmp += " backupset;"
        self.configlist.append(self.tmp)

        # Configure Channels
        # --------------------
        self.tmp         = "configure channel device type {}".format(opts.device)
        if opts.distributed_channels and opts.inst_count > 1:
          self.tmp    += " connect {}".format(opts.tgt_connstr)
        if opts.max_open_files:
          self.tmp    += "\n maxopenfiles {}".format(opts.max_open_files)
        if opts.max_piece_size:
          self.tmp    += "\n maxpiecesize {}".format(opts.max_piece_size)
        if opts.streaming_rate:
          self.tmp    += "\n rate {}".format(opts.streaming_rate)
        if opts.format:
          self.tmp      += "\n format {}".format(opts.format)
        elif opts.device == 'disk':
          self.tmp      += "\n format '{}'".format(opts.db_reco_dest)
        self.tmp        += ";"
        self.configlist.append(self.tmp)

        # Configure autobackup and snapshot controlfile names
        # --------------------------------------------------------
        self.configlist.append("configure controlfile autobackup on;")
        if opts.db_unique_name and opts.db_reco_dest:
          self.configlist.append("configure controlfile autobackup format for device type {} to '{}';".format(opts.device, opts.db_reco_dest))
          self.configlist.append("configure snapshot controlfile name to '{}/{}/snapcf_{}.f';".format(opts.db_reco_dest, opts.db_unique_name, opts.db_unique_name.lower()))
        else:
          self.configlist.append("configure controlfile autobackup format for device type {} to '%f';")
          self.configlist.append("configure snapshot controlfile name clear;")

        self.header     += '\n' + '\n'.join(sorted(self.configlist))

    if opts.type not in ('resync','register','list_expired'):
      self.channels = 0
      if opts.db_role == 'PRIMARY' and opts.report_schema:
        self.header     += '\n\nreport schema;'

    # Set the Oracle execution environment.
    # --------------------------------------
    self.rc, self.msg  = self.set_env()
    if self.rc:
      print_message(self.msg, 'error')
      exit(self.rc)

    if trace:
      print('TRACE:')
      print('TRACE: End Rman.__init__({})'.format(rcv))
  # --------------------------------------------------------------------------------------------------
  # End __init__()
  # --------------------------------------------------------------------------------------------------

  # --------------------------------------------------------------------------------------------------
  # Name: print_rcv()
  # Desc: print the contents of self.rcv (rman script)
  # Args: <none>
  # Retn: <none>
  # --------------------------------------------------------------------------------------------------
  def print_rcv(self):
    if trace:
      print('TRACE:')
      print('TRACE: Begin Rman.print_rcv()')

    self.tag     = 'rman script'
    self.tlen    = len(self.tag)+5
    self.leader  = '\n{} {} {}'.format('-'*3, self.tag.title(), '-'*(100-self.tlen))
    self.trailer = '{} {} {}'.format('-'*(100-self.tlen), self.tag.title(), '-'*3)

    print(self.leader)
    if len(self.rcv) > 0:
      for self.line in self.rcv.split('\n'):
        self.line = self.line.replace(opts.tgt_connstr,  opts.masked_tgt_connstr)
        self.line = self.line.replace(opts.tgt_connstr,  opts.masked_tgt_connstr)
        print(self.line)
    else:
      print('TRACE:')
    print(self.trailer)

    if trace:
      print('TRACE:')
      print('TRACE: End Rman.print_rcv()')
  # --------------------------------------------------------------------------------------------------
  # End print_rcv()
  # --------------------------------------------------------------------------------------------------

  # --------------------------------------------------------------------------------------------------
  # Name: execute_rcv()
  # Desc: Executes statements in RMAN and captures and parses the output
  # Args: rcv = string of rman commands to run
  # Retn: rc = rman return code
  #       stdout = stdout + stderr produced by rman
  # --------------------------------------------------------------------------------------------------
  def execute_rcv(self, rcv=''):
    if trace:
      print('TRACE:')
      print('TRACE: Begin Rman.execute_rcv({})'.format(rcv))

    if rcv:
      self.rcv = rcv
    self.rc, self.stdout, self.error_stack = self.run_rman()

    if trace:
      print('TRACE:')
      print('TRACE: Begin Rman.execute_rcv({})'.format(rcv))

    return self.rc, self.stdout
  # --------------------------------------------------------------------------------------------------
  # End execute_rcv()
  # --------------------------------------------------------------------------------------------------

  # --------------------------------------------------------------------------------------------------
  # Name: set_env()
  # Desc: Configures the environment for rman execution
  # Args: <none>
  # Retn: 1 = return code from rman session
  #       2 = error message
  # --------------------------------------------------------------------------------------------------
  def set_env(self):
    if trace:
      print('TRACE:')
      print('TRACE: Begin Rman.set_env()')

    self.rman = ''
    self.rman_candidates = (
     pathjoin(environ['ORACLE_HOME'], 'bin', 'rman'),
     pathjoin(environ['ORACLE_HOME'], 'rman')
    )

    if opts.tns_admin:
      if isdir(opts.tns_admin):
        environ['TNS_ADMIN'] = opts.tns_admin
      else:
        self.msg = 'Directory for TNS_ADMIN not found: {}'.format(opts.tns_admin)
        return 1, self.msg

    for self.rman_candidate in self.rman_candidates:
      if isfile(self.rman_candidate):
        if access(self.rman_candidate, ReadOk) and access(self.rman_candidate, ExecOk):
          self.rman = self.rman_candidate
          break
    if not self.rman:
      return 1, 'Unable to identify valid rman executable.'

    opts.ldlib = pathjoin(opts.oracle_home, 'lib')
    if not isdir(opts.ldlib):
      self.msg = 'Directory for LD_LIBRARY_PATH not found: {}'.format(opts.ldlib)
      return 1, self.msg
    elif 'LD_LIBRARY_PATH' not in environ:
      environ['LD_LIBRARY_PATH'] = opts.ldlib
    else:
      environ['LD_LIBRARY_PATH'] = '{}:{}'.format(opts.ldlib, environ['LD_LIBRARY_PATH'])

    self.facilities_file = pathjoin(opts.oracle_home, 'lib', 'facility.lis')
    if not isfile(self.facilities_file):
      self.facilities_file = pathjoin(opts.oracle_home, 'facility.lis')
      if not isfile(self.facilities_file):
        self.msg = 'Facilities file not found: {}'.format(self.facilities_file)
        self.facilities_file = ''

    self.contents = ''
    if self.facilities_file:
      try:
        with open(self.facilities_file, 'r') as self.f:
          self.contents = self.f.readlines()
        self.contents = [ self.line.split('#')[0].strip() for self.line in self.contents ]   # remove comments (everything to the right of '#')
        self.contents = [ self.line for self.line in self.contents if self.line]             # remove blank lines
      except:
        self.msg = 'Cannot open facilities file for read: {}'.format(self.facilities_file)
        return 1, self.msg
      for self.line in self.contents:
        if self.line.count(':') == 3:   # ignore lines that do not contain 3 ':' characters
          self.facility, self.component, self.rename, self.description = self.line.split(':')
          if self.facility:
            self.facilities[self.facility.strip()] = {
             'component'   : self.component.strip(),
             'rename'      : self.rename.strip(),
             'description' : self.description.strip()
            }

    if trace:
      print('TRACE:')
      print('TRACE: End Rman.set_env()')

    return 0, ''
  # --------------------------------------------------------------------------------------------------
  # End set_env()
  # --------------------------------------------------------------------------------------------------

  # --------------------------------------------------------------------------------------------------
  # Name: lookup_error()
  # Desc: This function works like the Oracle script 'oraerr'. It looks up errors like 'ORA-01219' in
  #       the Oracle messages files and returns something like the following ...
  #       ------------------------------------------------------------------------------
  #       01219, 00000, 'database not open: queries allowed on fixed tables/views only'
  #       // *Cause:  A query was issued against an object not recognized as a fixed
  #       //          table or fixed view before the database has been opened.
  #       // *Action: Re-phrase the query to include only fixed objects, or open the
  #       //          database.
  #       ------------------------------------------------------------------------------
  # Args: error = error to lookup in the format: PREFIX-NNNNN
  # Retn: rc = rman return code
  #       message_list = error message in list format.
  # --------------------------------------------------------------------------------------------------
  def lookup_error(self, error):
    if trace:
      print('TRACE:')
      print('TRACE: Begin Rman.lookup_error({})'.format(error))

    self.message_list  = []
    self.header_found  = False

    try:
      self.facility, self.error_code = self.error.lower().split('-')
    except:
      self.rc = 1
      print('\nInvalid error code: {}'.format(self.error_code))
      return self.rc, []

    if not self.facility in self.facilities.keys():
      self.rc = 1
      print('\nInvalid facility: {}'.format(self.facility))
      return self.rc, []
    else:
      self.messages_file = pathjoin(opts.oracle_home, self.facilities[self.facility]['component'], 'mesg', self.facility + 'us.msg')

    self.msg_file_contents = ''
    try:
      with open(self.messages_file, 'r') as self.mf:
        self.msg_file_contents = self.mf.readlines()
    except:
      self.rc = 1
      print('\nCannot open Messages file for read: {}'.format(self.messages_file))
      return self.rc, []

    for self.line in self.msg_file_contents:
      if self.header_found:
        self.match_obj = match(r'//,*', self.line)
        if self.match_obj:
          self.message_list.append(self.line.strip())
        else:
          self.rc = 1
          return self.rc, self.message_list
      else:
        self.match_obj = match('[0]*' + self.error_code + ',', self.line)
        if self.match_obj:
            self.error_code = self.match_obj.group()
            self.error_code = self.error_code[0:self.error_code.find(',')]
            self.message_list.append(self.line.strip())
            self.header_found = True
    if len(self.message_list) == 0:
      # If error code could not be found let's trim off leading 0's and try again...
      self.error_code = str(int(self.error_code))
      for self.line in self.msg_file_contents:
        if self.header_found:
            self.match_obj = match(r'//,*', self.line)
            if self.match_obj:
              self.message_list.append(self.line.strip())
            else:
              return self.rc, self.message_list
        else:
          self.match_obj = match('[0]*' + self.error_code + ',', self.line)
          if self.match_obj:
              self.error_code = self.match_obj.group()
              self.error_code = self.error_code[0:self.error_code.find(',')]
              self.message_list.append(self.line.strip())
              self.header_found = True

    if len(self.message_list) == 0:
      print('error not found  : {}'.format(self.error_code))
      print('Msg file         : {}'.format(self.messages_file))

    if trace:
      print('TRACE:')
      print('TRACE: Begin Rman.lookup_error({})'.format(error))

    return self.rc, self.message_list
  # --------------------------------------------------------------------------------------------------
  # End lookup_error()
  # --------------------------------------------------------------------------------------------------

  # --------------------------------------------------------------------------------------------------
  # Name: print_error()
  # Desc: Prints expanded error messages returned by rman
  # Args: <none>
  # Retn: <none>
  # --------------------------------------------------------------------------------------------------
  def print_error(self):
    if trace:
      print('TRACE:')
      print('TRACE: Begin Rman.print_error()')

    self.msg = ''
    for self.error in self.error_stack:
      if self.error not in self.msg:
        self.rc, self.explain_list = self.lookup_error(self.error)
        if len(self.explain_list) > 0:
          self.msg += 'Error: {}\n'.format(self.error)
          for self.line in self.explain_list:
            self.msg += '{}\n'.format(self.line)
        self.msg += '\n'

    if self.msg:
      print_message(self.msg.strip(), 'error detail')

    if trace:
      print('TRACE:')
      print('TRACE: End Rman.print_error()')

    return
  # --------------------------------------------------------------------------------------------------
  # End print_error()
  # --------------------------------------------------------------------------------------------------

  # --------------------------------------------------------------------------------------------------
  # Name: run_rman()
  # Desc: Call rman and execute SQL statement(s)
  # Args: <none>
  # Retn: rc = rman return code
  #       stdout =
  #       error_stack = error messages in list format.
  # --------------------------------------------------------------------------------------------------
  def run_rman(self):
    if trace:
      print('TRACE:')
      print('TRACE: Begin Rman.run_rman()')

    # RMAN Errors that will be disregarded.
    self.ignore_errors = ['ERROR:','RMAN-00571','RMAN-00569','RMAN-00558','RMAN-04008','ORA-28011']

    print('')
    print('--- rman script ------------------------------------------------------------------------------------')
    print(self.rcv.rstrip())
    print('------------------------------------------------------------------------------------ rman script ---')
    print('')

    if opts.debug:
      self.proc = Popen([self.rman, 'debug'], stdin=PIPE, stdout=PIPE, stderr=STDOUT, shell=False, universal_newlines=True)
    else:
      self.proc = Popen([self.rman], stdin=PIPE, stdout=PIPE, stderr=STDOUT, shell=False, universal_newlines=True)

    # Execute the SQL
    self.proc.stdin.write(self.rcv)
    self.proc.stdin.close()    # flushes stdin buffer.

    # Poll process.stdout to show stdout live
    print('')
    print('--- rman output ------------------------------------------------------------------------------------', end='')
    self.stdout = ''
    self.previous_line = ''
    while True:
      self.line = self.proc.stdout.readline()

      # remove lines that look like this: "RMAN> 2> 3> 4> 5> 6> 7> 8> 9> 10> 11>"
      self.line = sub(r'^RMAN> (\d+> *)*', '', self.line)

      # remove lines that look like this: "RMAN>"
      self.line = sub(r'^RMAN>?(\s+)$', '', self.line)

      # capture the return code and exit the loop when RMAN exits
      if self.proc.poll() != None:
        self.rc = self.proc.returncode
        break

      # print RMAN stdout/stderr...
      # ----------------------------
      if self.previous_line != self.line:
        self.stdout += sub(r'([\r\n]+.?)+', r'\n', self.line)             # convert \r\n to \n
        print('{}'.format(sub(r'([\n]+.?)+', r'\n', self.line)), end='')
      self.previous_line = self.line
    self.rc = self.proc.poll()
    print('------------------------------------------------------------------------------------ rman output ---')

    # check stdout for errors like RMAN-00569, ORA-01219, ...
    # -------------------------------------------------------
    if not opts.debug:
      self.error_stack = []
      self.stdout      = self.stdout.strip()
      self.pattern     = regex_compile(r'(?:\n)?(?:\s)?([A-Za-z0-9]+-\d+): (?:.*)', MULTILINE)

      for self.facility in sorted([ key.upper() for key in list(self.facilities) ]):
        self.iterate = self.pattern.finditer(self.stdout)
        for self.error in self.iterate:
          if self.error.groups()[0] not in self.ignore_errors:
            self.rc = 1
            self.error_stack.append(self.error.groups()[0])

    if trace:
      print('TRACE:')
      print('TRACE: End Rman.run_rman()')

    return self.rc, self.stdout, self.error_stack
  # --------------------------------------------------------------------------------------------------
  # End run_rman()
  # --------------------------------------------------------------------------------------------------

  # --------------------------------------------------------------------------------------------------
  # Name: gen_register_database()
  # Desc: Generate rman commands and save them to self.rcv.
  # Args: <none>
  # Retn: <none>
  # --------------------------------------------------------------------------------------------------
  def gen_register_database(self):
    if trace:
      print('TRACE:')
      print('TRACE: Begin Rman.gen_register_database()')

    self.rcv         = self.header
    self.rcv        += "\n"

    self.rcv        += "\n# --------------------------------------------------------------"
    self.rcv        += "\n# Register Database with Recovery Catalog"
    self.rcv        += "\n# --------------------------------------------------------------"
    self.rcv        += "\nset command id to 'RMAN:REGISTER DATABASE';"
    self.rcv        += "\n"

    self.rcv        += "\n# ------------------------------"
    self.rcv        += "\n# Perform Operation(s)"
    self.rcv        += "\n# ------------------------------"
    self.rcv        += "\nregister database;"

    if trace:
      print('TRACE:')
      print('TRACE: Begin Rman.gen_register_database()')
  # --------------------------------------------------------------------------------------------------
  # End gen_register_database()
  # --------------------------------------------------------------------------------------------------

  # --------------------------------------------------------------------------------------------------
  # Name: gen_crosscheck()
  # Desc: Generate rman commands and save them to self.rcv.
  # Args: <none>
  # Retn: <none>
  # --------------------------------------------------------------------------------------------------
  def gen_crosscheck(self):
    if trace:
      print('TRACE:')
      print('TRACE: Begin Rman.gen_crosscheck()')

    self.rcv         = self.header
    self.rcv        += "\n"
    self.rcv        += "\n# --------------------------------------------------------------"
    self.rcv        += "\n# Crosscheck Backups"
    self.rcv        += "\n# --------------------------------------------------------------"
    self.rcv        += "\nset command id to 'RMAN:CROSSCHECK';"
    self.rcv        += "\n"
    self.rcv        += "\nrun {"
    self.rcv        += "\n  # Allocate Channel(s)"
    self.rcv        += "\n  # --------------------------------"
    for self.i in range(1, opts.channels+1):
      if opts.distributed_channels and opts.inst_count > 1:
        self.rcv    += "\n  allocate channel {}{:<2} device type {} connect {}".format(opts.device, self.i, opts.device, opts.tgt_connstr)
      else:
        self.rcv    += "\n  allocate channel {}{:<2} device type {}".format(opts.device, self.i, opts.device)
      if opts.format:
        self.rcv    += "\n   format {}".format(opts.format)
      self.rcv      += ";"
    self.rcv        += "\n"

    self.rcv        += "\n  # --------------------------------"
    self.rcv        += "\n  # Perform Operation(s)"
    self.rcv        += "\n  # --------------------------------"
    self.rcv        += "\n  crosscheck backupset device type {};".format(opts.device)
    self.rcv        += "\n  crosscheck backup device type {};".format(opts.device)
    self.rcv        += "\n  crosscheck archivelog all device type {};".format(opts.device)
    # self.rcv        += "\n  crosscheck copy device type {};".format(opts.device)
    self.rcv        += "\n"
    self.rcv        += "\n  # Release Channel(s)"
    self.rcv        += "\n  # --------------------------------"
    for self.i in range(1, opts.channels+1):
     self.rcv       += "\n  release channel {}{};".format(opts.device, self.i)
    self.rcv        += "\n}"

    if trace:
      print('TRACE:')
      print('TRACE: End Rman.gen_crosscheck()')
  # --------------------------------------------------------------------------------------------------
  # End gen_crosscheck()
  # --------------------------------------------------------------------------------------------------

  # --------------------------------------------------------------------------------------------------
  # Name: gen_delete_expired()
  # Desc: Generate rman commands and save them to self.rcv.
  # Args: <none>
  # Retn: <none>
  # --------------------------------------------------------------------------------------------------
  def gen_delete_expired(self):
    if trace:
      print('TRACE:')
      print('TRACE: Begin Rman.gen_delete_expired()')

    # Only add the file header if the script is blank.
    # This allows us to combine archivelog backups
    # with a database backups in the same script.
    # --------------------------------------------------
    if not self.rcv:
      self.rcv       = self.header
    self.rcv        += "\n"
    self.rcv        += "\n# Delete Expired"
    self.rcv        += "\n# --------------------------------------------------------------"
    self.rcv        += "\nset command id to 'RMAN:DELETE EXPIRED';"
    self.rcv        += "\n"
    self.rcv        += "\n# Allocate Channel(s)"
    self.rcv        += "\n# ------------------------------"
    if opts.distributed_channels and opts.inst_count > 1:
      self.rcv      += "\nallocate channel for maintenance device type {} connect {};".format(opts.device, opts.tgt_connstr)
    else:
      self.rcv      += "\nallocate channel for maintenance device type {};".format(opts.device)
    self.rcv        += "\n"
    self.rcv        += "\n# ------------------------------"
    self.rcv        += "\n# Perform Operation(s)"
    self.rcv        += "\n# ------------------------------"
    self.rcv        += "\ncrosscheck backupset device type {};".format(opts.device)
    self.rcv        += "\ndelete force noprompt expired backupset device type {};".format(opts.device)
    self.rcv        += "\n"
    self.rcv        += "\ncrosscheck backup device type {};".format(opts.device)
    self.rcv        += "\ndelete force noprompt expired backup device type {};".format(opts.device)
    self.rcv        += "\n"
    self.rcv        += "\ncrosscheck copy device type {};".format(opts.device)
    self.rcv        += "\ndelete force noprompt expired copy device type {};".format(opts.device)
    self.rcv        += "\n"
    self.rcv        += "\ncrosscheck archivelog all device type {};".format(opts.device)
    self.rcv        += "\ndelete force noprompt expired archivelog all device type {};".format(opts.device)

    if trace:
      print('TRACE:')
      print('TRACE: End Rman.gen_delete_expired()')
  # --------------------------------------------------------------------------------------------------
  # End gen_delete_expired()
  # --------------------------------------------------------------------------------------------------

  # --------------------------------------------------------------------------------------------------
  # Name: gen_delete_obsolete()
  # Desc: Generate rman commands and save them to self.rcv.
  # Args: <none>
  # Retn: <none>
  # --------------------------------------------------------------------------------------------------
  def gen_delete_obsolete(self):
    if trace:
      print('TRACE:')
      print('TRACE: Begin Rman.gen_delete_obsolete()')

    if not self.rcv:
      self.rcv       = self.header
    self.rcv        += "\n"
    self.rcv        += "\n# --------------------------------------------------------------"
    self.rcv        += "\n# Delete Obsolete"
    self.rcv        += "\n# --------------------------------------------------------------"
    self.rcv        += "\nset command id to 'RMAN:DELETE OBSOLETE';"
    self.rcv        += "\n"
    if opts.distributed_channels:
      self.rcv      += "\nallocate channel for maintenance device type {} connect {};".format(opts.device, opts.tgt_connstr)
    else:
      self.rcv      += "\nallocate channel for maintenance device type {};".format(opts.device)
    if not self.rcv:
      self.rcv      += "\n"
      self.rcv      += "\n# --------------------------------"
      self.rcv      += "\n# Perform Operation(s)"
      self.rcv      += "\n# --------------------------------"
    if opts.retention:
      self.rcv      += "\ndelete force noprompt obsolete {} device type {};".format(opts.retention, opts.device)
    else:
      self.rcv      += "\ndelete force noprompt obsolete device type {};".format(opts.device)
    if opts.delete_archivelogs and opts.delete_delay:
      self.rcv      += "\ndelete archivelog all completed before \'trunc(sysdate-{})\';\n".format(opts.delete_delay)

    if trace:
      print('TRACE:')
      print('TRACE: End Rman.gen_delete_obsolete()')
  # --------------------------------------------------------------------------------------------------
  # End gen_delete_obsolete()
  # --------------------------------------------------------------------------------------------------

  # --------------------------------------------------------------------------------------------------
  # Name: gen_list_expired()
  # Desc: Generate rman commands and save them to self.rcv.
  # Args: <none>
  # Retn: <none>
  # --------------------------------------------------------------------------------------------------
  def gen_list_expired(self):
    if trace:
      print('TRACE:')
      print('TRACE: Begin Rman.gen_list_expired()')

    self.rcv         = self.header
    self.rcv        += "\n"
    self.rcv        += "\n# --------------------------------------------------------------"
    self.rcv        += "\n# Report backupsets for which backup files";
    self.rcv        += "\n# can no longer found on backup media.";
    self.rcv        += "\n# --------------------------------------------------------------"
    self.rcv        += "\nset command id to 'RMAN:LIST EXPIRED';"
    self.rcv        += "\n"
    self.rcv        += "\n  # --------------------------------"
    self.rcv        += "\n  # Perform Operation(s)"
    self.rcv        += "\n  # --------------------------------"
    self.rcv        += "\nlist expired backup device type {};".format(opts.device)
    self.rcv        += "\nlist expired backupset device type {};".format(opts.device)
    self.rcv        += "\nlist expired copy;"
    self.rcv        += "\nlist expired archivelog all;"

    if trace:
      print('TRACE:')
      print('TRACE: End Rman.gen_list_expired()')
  # ------------------------------------------------------------------------
  # End gen_list_expired()
  # ------------------------------------------------------------------------

  # ------------------------------------------------------------------------
  # Name: gen_report_need_backup()
  # Desc: Generate rman commands and save them to self.rcv.
  # Args: <none>
  # Retn: <none>
  # ------------------------------------------------------------------------
  def gen_report_need_backup(self):
    if trace:
      print('TRACE:')
      print('TRACE: Begin Rman.gen_report_need_backup()')

    self.rcv         = self.header
    self.rcv        += "\n"
    self.rcv        += "\n# --------------------------------------------------------------"
    self.rcv        += "\n# Files that need a fresh backup"
    self.rcv        += "\n# --------------------------------------------------------------"
    self.rcv        += "\nset command id to 'RMAN:REPORT NEED BACKUP';"
    self.rcv        += "\n"
    self.rcv        += "\nrun {"
    self.rcv        += "\n  # Allocate Channel(s)"
    self.rcv        += "\n  # --------------------------------"
    for self.i in range(1, opts.channels+1):
      if opts.distributed_channels and opts.inst_count > 1:
        self.rcv    += "\n  allocate channel {}{:<2} device type {} connect {}".format(opts.device, self.i, opts.device, opts.tgt_connstr)
      else:
        self.rcv    += "\n  allocate channel {}{:<2} device type {}".format(opts.device, self.i, opts.device)
      if opts.format:
        self.rcv    += "\n   format {}".format(opts.format)
      self.rcv      += ";"
    self.rcv        += "\n"

    self.rcv        += "\n  # --------------------------------"
    self.rcv        += "\n  # Perform Operation(s)"
    self.rcv        += "\n  # --------------------------------"
    self.rcv        += "\n  report need backup device type {};".format(opts.device)
    self.rcv        += "\n"
    self.rcv        += "\n  # Release Channel(s)"
    self.rcv        += "\n  # --------------------------------"
    for self.i in range(1, opts.channels+1):
     self.rcv       += "\n  release channel {}{};".format(opts.device, self.i)
    self.rcv        += "\n}"

    if trace:
      print('TRACE:')
      print('TRACE: End Rman.gen_report_need_backup()')
  # ------------------------------------------------------------------------
  # End gen_report_need_backup()
  # ------------------------------------------------------------------------

  # ------------------------------------------------------------------------
  # Name: gen_report_unrecoverable()
  # Desc: Generate rman commands and save them to self.rcv.
  # Args: <none>
  # Retn: <none>
  # ------------------------------------------------------------------------
  def gen_report_unrecoverable(self):
    if trace:
      print('TRACE:')
      print('TRACE: Begin Rman.gen_report_unrecoverable()')

    self.rcv         = self.header
    self.rcv        += "\n"
    self.rcv        += "\n# --------------------------------------------------------------"
    self.rcv        += "\n# Files that need a fresh backup"
    self.rcv        += "\n# --------------------------------------------------------------"
    self.rcv        += "\nset command id to 'RMAN:REPORT UNRECOVERABLE';"
    self.rcv        += "\n"
    self.rcv        += "\nrun {"
    self.rcv        += "\n  # Allocate Channel(s)"
    self.rcv        += "\n  # --------------------------------"
    for self.i in range(1, opts.channels+1):
      if opts.distributed_channels and opts.inst_count > 1:
        self.rcv    += "\n  allocate channel {}{:<2} device type {} connect {}".format(opts.device, self.i, opts.device, opts.tgt_connstr)
      else:
        self.rcv    += "\n  allocate channel {}{:<2} device type {}".format(opts.device, self.i, opts.device)
      if opts.format:
        self.rcv    += "\n   format {}".format(opts.format)
      self.rcv      += ";"
    self.rcv      += "\n"

    self.rcv        += "\n  # --------------------------------"
    self.rcv        += "\n  # Perform Operation(s)"
    self.rcv        += "\n  # --------------------------------"
    self.rcv        += "\n  report unrecoverable device type {};".format(opts.device)
    self.rcv        += "\n"
    self.rcv        += "\n  # Release Channel(s)"
    self.rcv        += "\n  # --------------------------------"
    for self.i in range(1, opts.channels+1):
     self.rcv       += "\n  release channel {}{};".format(opts.device, self.i)
    self.rcv        += "\n}"

    if trace:
      print('TRACE:')
      print('TRACE: End Rman.gen_report_unrecoverable()')
  # ------------------------------------------------------------------------
  # End gen_report_unrecoverable()
  # ------------------------------------------------------------------------

  # ------------------------------------------------------------------------
  # Name: gen_report_obsolete()
  # Desc: Generate rman commands and save them to self.rcv.
  # Args: <none>
  # Retn: <none>
  # ------------------------------------------------------------------------
  def gen_report_obsolete(self):
    if trace:
      print('TRACE:')
      print('TRACE: Begin Rman.gen_report_obsolete()')

    self.rcv         = self.header
    self.rcv        += "\n"
    self.rcv        += "\n# --------------------------------------------------------------"
    self.rcv        += "\n# Report backups no longer needed according to retention policy"
    self.rcv        += "\n# --------------------------------------------------------------"
    self.rcv        += "\nset command id to 'RMAN:REPORT OBSOLETE';"
    self.rcv        += "\n"
    self.rcv        += "\nrun {"
    self.rcv        += "\n  # Allocate Channel(s)"
    self.rcv        += "\n  # --------------------------------"
    for self.i in range(1, opts.channels+1):
      if opts.distributed_channels and opts.inst_count > 1:
        self.rcv    += "\n  allocate channel {}{:<2} device type {} connect {}".format(opts.device, self.i, opts.device, opts.tgt_connstr)
      else:
        self.rcv    += "\n  allocate channel {}{:<2} device type {}".format(opts.device, self.i, opts.device)
      if opts.format:
        self.rcv    += "\n   format {}".format(opts.format)
      self.rcv      += ";"
    self.rcv      += "\n"

    self.rcv        += "\n  # Perform Operation(s)"
    self.rcv        += "\n  # --------------------------------"
    self.rcv        += "\n  report obsolete device type {};".format(opts.device)
    self.rcv        += "\n"
    self.rcv        += "\n  # Release Channel(s)"
    self.rcv        += "\n  # --------------------------------"
    for self.i in range(1, opts.channels+1):
     self.rcv       += "\n  release channel {}{};".format(opts.device, self.i)
    self.rcv        += "\n}"

    if trace:
      print('TRACE:')
      print('TRACE: End Rman.gen_report_obsolete()')
  # ------------------------------------------------------------------------
  # End gen_report_obsolete()
  # ------------------------------------------------------------------------


  # ------------------------------------------------------------------------
  # Name: gen_report_schema()
  # Desc: Generate rman commands and save them to self.rcv.
  # Args: <none>
  # Retn: <none>
  # ------------------------------------------------------------------------
  def gen_report_schema(self):
    if trace:
      print('TRACE:')
      print('TRACE: Begin Rman.gen_report_schema()')

    self.rcv         = self.header
    self.rcv        += "\n"
    self.rcv        += "\n# --------------------------------------------------------------"
    self.rcv        += "\n# Report backups no longer needed according to retention policy"
    self.rcv        += "\n# --------------------------------------------------------------"
    self.rcv        += "\nset command id to 'RMAN:REPORT SCHEMA';"
    self.rcv        += "\n"
    self.rcv        += "\n  # Perform Operation(s)"
    self.rcv        += "\n  # --------------------------------"
    self.rcv        += "\n  report schema;"

    if trace:
      print('TRACE:')
      print('TRACE: End Rman.gen_report_schema()')
  # ------------------------------------------------------------------------
  # End gen_report_schema()
  # ------------------------------------------------------------------------

  # ------------------------------------------------------------------------
  # Name: gen_resync()
  # Desc: Generate rman commands and save them to self.rcv.
  # Args: <none>
  # Retn: <none>
  # ------------------------------------------------------------------------
  def gen_resync(self):
    if trace:
      print('TRACE:')
      print('TRACE: Begin Rman.gen_resync()')

    self.rcv         = self.header
    self.rcv        += "\n"
    self.rcv        += "\n# -------------------------------------------------"
    self.rcv        += "\n# Resync Catalog"
    self.rcv        += "\n# -------------------------------------------------"
    self.rcv        += "\nset command id to 'RMAN:RESYNC CATALOG';"
    self.rcv        += "\n"
    self.rcv        += "\n# Perform Operation(s)"
    self.rcv        += "\n# ------------------------------"
    self.rcv        += "\nresync catalog;"

    if trace:
      print('TRACE:')
      print('TRACE: Begin Rman.gen_resync()')
  # ------------------------------------------------------------------------
  # End gen_resync()
  # ------------------------------------------------------------------------

  # ------------------------------------------------------------------------
  # Name: gen_validate_backup()
  # Desc: Generate rman commands and save them to self.rcv.
  # Args: <none>
  # Retn: <none>
  # ------------------------------------------------------------------------
  def gen_validate_backup(self):
    if trace:
      print('TRACE:')
      print('TRACE: Begin Rman.gen_validate_backup()')

    self.rcv         = self.header
    self.rcv        += "\n"
    self.rcv        += "\n# -------------------------------------------------"
    self.rcv        += "\n# Backup Database Validate Check Logical"
    self.rcv        += "\n# -------------------------------------------------"
    self.rcv        += "\nset command id to 'RMAN:VALIDATE DATABASE';"
    self.rcv        += "\n"
    self.rcv        += "\nrun {"
    self.rcv        += "\n  # Allocate Channel(s)"
    self.rcv        += "\n  # --------------------------------"
    for self.i in range(1, opts.channels+1):
      if opts.distributed_channels and opts.inst_count > 1:
        self.rcv    += "\n  allocate channel {}{:<2} device type {} connect {}".format(opts.device, self.i, opts.device, opts.tgt_connstr)
      else:
        self.rcv    += "\n  allocate channel {}{:<2} device type {}".format(opts.device, self.i, opts.device)
      if opts.format:
        self.rcv    += "\n   format {}".format(opts.format)
      self.rcv      += ";"
    self.rcv        += "\n"

    self.rcv        += "\n  # Perform Operation(s)"
    self.rcv        += "\n  # --------------------------------"
    self.rcv        += "\n  backup check logical validate"
    for self.skip in opts.skip:
      self.skip     +=  " skip {}".format(self.skip)
    self.rcv        +=  " database;"
    self.rcv        += "\n"
    self.rcv        += "\n  # Release Channel(s)"
    self.rcv        += "\n  # --------------------------------"
    for self.i in range(1, opts.channels+1):
     self.rcv       += "\n  release channel {}{};".format(opts.device, self.i)
    self.rcv        += "\n}"

    if trace:
      print('TRACE:')
      print('TRACE: End Rman.gen_validate_backup()')

  # ------------------------------------------------------------------------
  # End gen_validate_backup()
  # ------------------------------------------------------------------------

  # ------------------------------------------------------------------------
  # Name: gen_validate_restore()
  # Desc: Generate rman commands and save them to self.rcv.
  # Args: <none>
  # Retn: <none>
  # ------------------------------------------------------------------------
  def gen_validate_restore(self):
    if trace:
      print('TRACE:')
      print('TRACE: Begin Rman.gen_validate_restore()')

    self.rcv         = self.header
    self.rcv        += "\n"
    self.rcv        += "\n# -------------------------------------------------"
    self.rcv        += "\n# Restore Database Validate Check Logical"
    self.rcv        += "\n# -------------------------------------------------"
    self.rcv        += "\nset command id to 'RMAN:VALIDATE RESTORE';"
    self.rcv        += "\n"
    self.rcv        += "\nrun {"
    self.rcv        += "\n  # Allocate Channel(s)"
    self.rcv        += "\n  # --------------------------------"
    for self.i in range(1, opts.channels+1):
      if opts.distributed_channels and opts.inst_count > 1:
        self.rcv    += "\n  allocate channel {}{:<2} device type {} connect {}".format(opts.device, self.i, opts.device, opts.tgt_connstr)
      else:
        self.rcv    += "\n  allocate channel {}{:<2} device type {}".format(opts.device, self.i, opts.device)
      if opts.format:
        self.rcv    += "\n   format {}".format(opts.format)
      self.rcv      += ";"
    self.rcv        += "\n"

    self.rcv        += "\n  # Perform Operation(s)"
    self.rcv        += "\n  # --------------------------------"
    self.rcv        += "\n  restore database validate check logical;"
    self.rcv        += "\n"
    self.rcv        += "\n  # Release Channel(s)"
    self.rcv        += "\n  # --------------------------------"
    for self.i in range(1, opts.channels+1):
     self.rcv       += "\n  release channel {}{};".format(opts.device, self.i)
    self.rcv        += "\n}"

    if trace:
      print('TRACE:')
      print('TRACE: End Rman.gen_validate_restore()')
  # ------------------------------------------------------------------------
  # End gen_validate_restore()
  # ------------------------------------------------------------------------

  # ------------------------------------------------------------------------
  # Name: gen_archivelogs()
  # Desc: Generate rman commands and save them to self.rcv.
  # Args: <none>
  # Retn: <none>
  # ------------------------------------------------------------------------
  def gen_archivelogs(self):
    if trace:
      print('TRACE:')
      print('TRACE: Begin Rman.gen_archivelogs()')

    # Only add the file header if the script is blank.
    # This allows us to combine archivelog backups
    # with a database backups in the same script.
    # --------------------------------------------------
    if not self.rcv:
      self.rcv       = self.header
    self.rcv        += "\n"
    self.rcv        += "\n# -------------------------------------------------"
    self.rcv        += "\n# Backup Archivelogs"
    self.rcv        += "\n# -------------------------------------------------"
    self.rcv        += "\nset command id to 'RMAN:BACKUP ARCHIVELOGS';"
    self.rcv        += "\n"
    if opts.compression_level:
      self.rcv      += "\n# Set Compression Level"
      self.rcv      += "\n# ----------------------------------"
      self.rcv      += "\nset compression algorithm '{}' as of release 'DEFAULT'".format(opts.compression_level.upper())
      if opts.compression_optimization:
        self.rcv    += " optimize for load TRUE;\n"
      else:
        self.rcv    += " optimize for load FALSE;\n"
    self.rcv        += "\nrun {"
    self.rcv        += "\n  # Allocate Channel(s)"
    self.rcv        += "\n  # --------------------------------"
    for self.i in range(1, opts.channels+1):
      if opts.distributed_channels and opts.inst_count > 1:
        self.rcv    += "\n  allocate channel {}{:<2} device type {} connect {}".format(opts.device, self.i, opts.device, opts.tgt_connstr)
      else:
        self.rcv    += "\n  allocate channel {}{:<2} device type {}".format(opts.device, self.i, opts.device)
      if opts.max_open_files:
        self.rcv    += "\n   maxopenfiles {}".format(opts.max_open_files)
      if opts.max_piece_size:
        self.rcv    += "\n   maxpiecesize {}".format(opts.max_piece_size)
      if opts.streaming_rate:
        self.rcv    += "\n   rate {}".format(opts.streaming_rate)
      if opts.format:
        self.rcv    += "\n   format {}".format(opts.format)
      self.rcv      += ";"
    self.rcv        += "\n"

    # if opts.db_state == 'OPEN' and opts.db_role == 'PRIMARY':
    if opts.db_role == 'PRIMARY':
      self.rcv      += "\n  # Flush online redologs to disk."
      self.rcv      += "\n  # --------------------------------"
      self.rcv      += "\n  SQL 'alter system archive log current';"
      self.rcv      += "\n"

    self.rcv        += "\n  # Perform Operation(s)"
    self.rcv        += "\n  # --------------------------------"
    if opts.copy:
      self.rcv      += "\n  backup as copy"
    else:
      if opts.compression_level:
        self.rcv    += "\n  backup as compressed backupset"
      else:
        self.rcv    += "\n  backup as backupset"
      if opts.max_duration:
        self.rcv    += "\n   duration {} partial".format(opts.max_duration)
      if opts.cumulative:
        self.rcv    += "\n   cumulative"
      if opts.max_set_size:
        self.rcv    += "\n   maxsetsize {}".format(opts.max_set_size)
      if opts.files_per_set:
        self.rcv    += "\n   filesperset {}".format(opts.files_per_set)
      if opts.keep:
        self.rcv    += "\n   keep until time 'sysdate + {}'".format(opts.keep)
    if opts.no_checksum:
      self.rcv      += "\n   nochecksum"
    if opts.archlog_copies:
      self.rcv      += "\n   archivelog all not backed up {} times".format(opts.archlog_copies)
    else:
      self.rcv      += "\n   archivelog all"
    if opts.delete_archivelogs and not opts.delete_delay:
      self.rcv      += "\n   delete input"
    self.rcv        += ";"
    self.rcv        += "\n"
    self.rcv        += "\n  # Release Channel(s)"
    self.rcv        += "\n  # --------------------------------"
    for self.i in range(1, opts.channels+1):
     self.rcv       += "\n  release channel {}{};".format(opts.device, self.i)
    self.rcv        += "\n}"

    if trace:
      print('TRACE:')
      print('TRACE: End Rman.gen_archivelogs()')
  # ------------------------------------------------------------------------
  # End gen_archivelogs()
  # ------------------------------------------------------------------------

  # ------------------------------------------------------------------------
  # Name: gen_backup_database()
  # Desc: Generate rman commands and save them to self.rcv.
  # Args: <none>
  # Retn: <none>
  # ------------------------------------------------------------------------
  def gen_backup_database(self):
    if trace:
      print('TRACE:')
      print('TRACE: Begin Rman.gen_backup_database()')

    if not self.rcv:
      self.rcv       = self.header
      self.rcv      += "\n"
    self.rcv        += "\n# -------------------------------------------------"
    self.rcv        += "\n# Backup {}".format(opts.type.title())
    self.rcv        += "\n# -------------------------------------------------"
    self.rcv        += "\nset command id to 'RMAN:BACKUP {}';".format(opts.type.upper())
    self.rcv        += "\n"
    if opts.compression_level:
      self.rcv      += "\n# Set Compression Level"
      self.rcv      += "\n# ----------------------------------"
      self.rcv      += "\nset compression algorithm '{}' as of release 'DEFAULT'".format(opts.compression_level.upper())
      if opts.compression_optimization:
        self.rcv    += " optimize for load TRUE;\n"
      else:
        self.rcv    += " optimize for load FALSE;\n"

    self.rcv        += "\nrun {"
    self.rcv        += "\n  # Allocate Channel(s)"
    self.rcv        += "\n  # --------------------------------"
    for self.i in range(1, opts.channels+1):
      if opts.distributed_channels and opts.inst_count > 1:
        self.rcv    += "\n  allocate channel {}{:<2} device type {} connect {}".format(opts.device, self.i, opts.device, opts.tgt_connstr)
      else:
        self.rcv    += "\n  allocate channel {}{:<2} device type {}".format(opts.device, self.i, opts.device)
      if opts.max_open_files:
        self.rcv    += "\n   maxopenfiles {}".format(opts.max_open_files)
      if opts.max_piece_size:
        self.rcv    += "\n   maxpiecesize {}".format(opts.max_piece_size)
      if opts.streaming_rate:
        self.rcv    += "\n   rate {}".format(opts.streaming_rate)
      if opts.format:
        self.rcv    += "\n   format {}".format(opts.format)
      self.rcv      += ";"
    self.rcv        += "\n"

    self.rcv        += "\n  # Perform Operation(s)"
    self.rcv        += "\n  # --------------------------------"
    self.rcv        += "\n  backup"
    if opts.level in ('0', '1'):
      self.rcv      += " incremental level {}".format(opts.level)
    else:
      self.rcv      += " {}".format(opts.level)
    if opts.copy:
      self.rcv      += " as copy"
    else:
      if opts.compression_level:
        self.rcv    += " as compressed backupset"
      else:
        self.rcv    += " as backupset"
    if opts.max_duration:
      self.rcv      += "\n   duration {} partial".format(opts.max_duration)
    if opts.cumulative:
      self.rcv      += "\n   cumulative"
    if opts.max_set_size:
      self.rcv      += "\n   maxsetsize {}".format(opts.max_set_size)
    if opts.files_per_set:
      self.rcv      += "\n   filesperset {}".format(opts.files_per_set)
    if opts.no_checksum:
      self.rcv      += "\n   nochecksum"
    if opts.skip:
      self.rcv      += "\n   skip {}".format('\n   skip '.join(opts.skip))
    if opts.type == 'database':
      self.rcv      += "\n   database"
    elif opts.type == 'datafile':
      self.rcv      += "\n   datafile {}".format(','.join(opts.datafiles))
    elif opts.type == 'tablespace':
      self.rcv      += "\n   tablespace {}".format(','.join(opts.tablespaces))
    if opts.force:
      self.rcv      += "\n   force"
    if opts.no_exclude:
      self.rcv      += "\n   noexclude"
    if opts.keep:
      self.rcv      += "\n   keep until time 'sysdate + {}' logs".format(opts.keep)
    if opts.controlfile:
      self.rcv      += "\n   include current controlfile"
    if opts.plus_archivelog:
      self.rcv      += "\n   plus archivelog"
    self.rcv        += ";"
    self.rcv        += "\n"
    self.rcv        += "\n  # Release Channel(s)"
    self.rcv        += "\n  # --------------------------------"
    for self.i in range(1, opts.channels+1):
     self.rcv       += "\n  release channel {}{};".format(opts.device, self.i)
    self.rcv        += "\n}"

    if trace:
      print('TRACE:')
      print('TRACE: End Rman.gen_backup_database()')
  # ------------------------------------------------------------------------
  # End gen_backup_database()
  # ------------------------------------------------------------------------

  # ------------------------------------------------------------------------
  # Name: gen_backup_fra()
  # Desc: Generate rman commands and save them to self.rcv.
  # Args: <none>
  # Retn: <none>
  # ------------------------------------------------------------------------
  def gen_backup_fra(self):
    if trace:
      print('TRACE:')
      print('TRACE: Begin Rman.gen_backup_fra()')

    self.rcv         = self.header
    self.rcv        += "\n"
    self.rcv        += "\n# -------------------------------------------------"
    self.rcv        += "\n# Backup {}".format(opts.type.title())
    self.rcv        += "\n# -------------------------------------------------"
    self.rcv        += "\nset command id to 'RMAN:BACKUP {}';".format(opts.type.upper())
    self.rcv        += "\n"
    if opts.compression_level:
      self.rcv      += "\n"
      self.rcv      += "\n# Set Compression Level"
      self.rcv      += "\n# ----------------------------------"
      self.rcv      += "\nset compression algorithm '{}' as of release 'DEFAULT'".format(opts.compression_level.upper())
      if opts.compression_optimization:
        self.rcv    += " optimize for load TRUE;\n"
      else:
        self.rcv    += " optimize for load FALSE;\n"
    self.rcv        += "\n"
    self.rcv        += "run {"
    self.rcv        += "\n  # Allocate Channel(s)"
    self.rcv        += "\n  # --------------------------------"
    for self.i in range(1, opts.channels+1):
      if opts.distributed_channels and opts.inst_count > 1:
        self.rcv    += "\n  allocate channel {}{:<2} device type {} connect {}".format(opts.device, self.i, opts.device, opts.tgt_connstr)
      else:
        self.rcv    += "\n  allocate channel {}{:<2} device type {}".format(opts.device, self.i, opts.device)
      if opts.max_open_files:
        self.rcv    += "\n   maxopenfiles {}".format(opts.max_open_files)
      if opts.max_piece_size:
        self.rcv    += "\n   maxpiecesize {}".format(opts.max_piece_size)
      if opts.streaming_rate:
        self.rcv    += "\n   rate {}".format(opts.streaming_rate)
      if opts.format:
        self.rcv    += "\n   format {}".format(opts.format)
      self.rcv      += ";"
    self.rcv      += "\n"

    self.rcv        += "\n  # Perform Operation(s)"
    self.rcv        += "\n  # --------------------------------"
    self.rcv        += "\n  backup recovery area;"
    self.rcv        += "\n"
    self.rcv        += "\n  # Release Channel(s)"
    self.rcv        += "\n  # --------------------------------"
    for self.i in range(1, opts.channels+1):
     self.rcv       += "\n  release channel {}{};".format(opts.device, self.i)
    self.rcv        += "\n}"

    if trace:
      print('TRACE:')
      print('TRACE: End Rman.gen_backup_fra()')
  # ------------------------------------------------------------------------
  # End gen_backup_fra()
  # ------------------------------------------------------------------------
# --------------------------------------------------------------------------------------------------
# End Rman
# --------------------------------------------------------------------------------------------------

# --------------------------------------------------------------------------------------------------
# Function: get_password()
# Desc    : Retrieve database password from the password file.
# Args    : db_unique_name, database username
# Retn    : If success then returns password. If not return blank.
# --------------------------------------------------------------------------------------------------
def get_password(name, user, decrypt, pwd_file):
  if trace:
    print('TRACE:')
    print('TRACE: Begin get_password({}, {}, {}, {})'.format(name, user, decrypt, pwd_file))
    print('TRACE: Parameters:')
    print('TRACE:   name         = {}'.format(name))
    print('TRACE:   user         = {}'.format(user))
    print('TRACE:   decrypt      = {}'.format(decrypt))
    print('TRACE:   pwd_file     = {}'.format(pwd_file))
    print('TRACE:')

  passwd_passwd = ''
  passwd_name   = ''
  passwd_user   = ''
  passwd        = ''

  try:
    with open(pwd_file, 'r') as f:
      contents = f.readlines()
    contents = [ line.strip() for line in contents if line]   # remove blank lines
  except:
    print('\nCannot open password file for read:', pwd_file)

  if trace:
    print('TRACE: password file contents: {}'.format(pwd_file))
    print('TRACE: ----------------------------------------------------------------------')
    for line in contents:
      print('TRACE: {}'.format(line))

  if trace:
    print('TRACE:')
    print('TRACE: Parsing password file...')
    print('TRACE: ----------------------------------------------------------------------')
  for line in contents:
    if line.count(':') == 2:                 # ignore lines that do not contain 2 colon's (:).
      (passwd_name, passwd_user, passwd_passwd) = line.split(':')
      if trace:
        print('TRACE: name={:<15s} user={:<15s} password={:<15s}'.format(passwd_name, passwd_user, passwd_passwd))
      if (passwd_name == name) and (passwd_user.upper() == user.upper()) and passwd_passwd:
        if trace:
          print('TRACE:')
          print('TRACE: Password Found!!!')
        if decrypt:
          try :
            if python_version >= 3.0:
              passwd = b64decode(passwd_passwd.encode('utf-8')).decode('utf-8')
            else:
              passwd = passwd_passwd.decode('base64','strict')
          except :
            print('\n  Are you sure the password was properly')
            print('  encoded? Check it with epw and try again.')
            exit(1)
        else:
          passwd = passwd_passwd
          break
  if trace:
    if not passwd:
      print('TRACE:')
      print('TRACE: password Not Found!!!')
    print('TRACE: End get_password({}, {}, {}, {})'.format(name, user, decrypt, pwd_file))

  return(passwd)
# --------------------------------------------------------------------------------------------------
# End get_password()
# --------------------------------------------------------------------------------------------------

# --------------------------------------------------------------------------------------------------
# Name: print_message()
# Desc: print a formatted message
# Args: msg - the error message to be printed
#       tag - the message tag
# Retn: <none>
# --------------------------------------------------------------------------------------------------
def print_message(msg, tag=''):
  if tag:
    tlen = len(tag) + 5
    leader  = '\n{} {} {}'.format('-'*3, tag.title(), '-'*(100-tlen))
    trailer = '{} {} {}'.format('-'*(100-tlen), tag.title(), '-'*3)
  else:
    leader = '\n{}'.format('-'*100)
    trailer = '{}\n'.format('-'*100)
  print(leader)
  if not len(msg) > 0:
    print('TRACE:')
  else:
    if len(msg.split('\n')) > 1:
      print('\n'.join(msg.split('\n')))
    else:
      print('{}'.format(msg))
  print(trailer)
#--------------------------------------------------------------------------------------------------
# End print_message()
# --------------------------------------------------------------------------------------------------

# --------------------------------------------------------------------------------------------------
# Name: validate_options()
# Desc: Check for incompatibilities between Rman features specified.
# Args: <none>
# Retn: <none> (exit with return code=1 if incompatibility found)
# --------------------------------------------------------------------------------------------------
def validate_options():
  if trace:
    print('TRACE:')
    print('TRACE: Begin validate_options()')
    print('TRACE:')

  levels = []
  levels.append('0')
  levels.append('1')
  levels.append('full')

  channel_required = []
  channel_required.append('arch')
  channel_required.append('crosscheck')
  channel_required.append('delete_expired')
  channel_required.append('database')
  channel_required.append('datafile')
  channel_required.append('fra')
  channel_required.append('tablespace')
  channel_required.append('validate_backup')
  channel_required.append('validate_restore')
  channel_required.append('report_unrecoverable')

  skips = []
  skips.append('inaccessible')
  skips.append('offline')
  skips.append('readonly')

  compression_levels = []
  compression_levels.append('basic')
  compression_levels.append('low')
  compression_levels.append('medium')
  compression_levels.append('high')

  if opts.script:
    # Disable any options that don't apply when -script option used.
    # -----------------------------------------------------------------
    opts.archlog_copies           = 0
    opts.archivelogs              = False
    opts.type                     = ''
    opts.catalog                  = ''
    opts.catalog_user             = ''
    opts.channels                 = 0
    opts.compression_level        = ''
    opts.compression_optimization = ''
    opts.configure                = False
    opts.controlfile              = False
    opts.copy                     = False
    opts.cumulative               = False
    opts.datafiles                = ''
    opts.delete_archivelogs       = False
    opts.delete_delay             = 0
    opts.delete_obsolete          = False
    opts.device                   = ''
    opts.distributed_channels     = False
    opts.distribution_list        = ''
    opts.max_duration             = 0
    opts.files_per_set            = 0
    opts.force                    = False
    opts.format                   = ''
    opts.generate                 = False
    opts.keep                     = 0
    opts.level                    = ''
    opts.max_corrupt              = 0
    opts.max_open_files           = 0
    opts.max_piece_size           = 0
    opts.max_set_size             = 0
    opts.no_catalog               = False
    opts.no_checksum              = False
    opts.no_exclude               = False
    opts.directory                = ''
    opts.parfile                  = ''
    opts.plus_archivelog          = False
    opts.retention                = ''
    opts.sbt_library              = ''
    opts.section_size             = 0
    opts.show                     = False
    opts.oracle_home              = ''
    opts.oracle_sid               = ''
    opts.skip                     = ''
    opts.streaming_rate           = 0
    opts.tablespaces              = ''
    opts.service_name             = ''
    opts.user                     = ''

  if opts.notify.lower() not in ('always', 'failure', 'off'):
    print_message("Invalid value for notify option: {}\n Valid values: always, failure, off".format(opts.notify), 'error')
    exit(1)

  if not opts.script:
    if not opts.service_name:
      print_message('Service_name ({}) is required.'.format(opts.args['service_name']['name']), 'error')
      exit(1)

    if not opts.user:
      print_message('User ({}) is required.'.format(opts.args['user']['name'], 'error'))
      exit(1)

    if opts.catalog_user.upper() == 'SYS':
      print_message("Invalid username for catalog user ({}).".format(opts.args['catalog_user']['name']), 'error')
      exit(1)

    if not opts.user:
      print_message("User name ({}) is required for connecting to the database.".format(opts.args['user']['name']), 'error')
      exit(1)

    if not opts.service_name:
      print_message("Service name ({}) is required for connecting to the database.".format(opts.args['service_name']['name']), 'error')
      exit(1)

    if opts.type == 'resync':
      if not opts.catalog:
        print_message("Catalog ({}) is required for resync types.".format(opts.args['catalog']['name']), 'error')
        exit(1)
      if not opts.catalog_user:
        print_message("Catalog username ({}) is required for resync types.".format(opts.args['catalog_user']['name']), 'error')
        exit(1)
      if not opts.cat_password:
        print_message("Catalog password ({}) is required for resync types.".format(opts.args['cat_password']['name']), 'error')
        exit(1)

    if opts.type in channel_required or opts.configure:
      if opts.directory:
        opts.directory = pathjoin(opts.directory, '[DBNAME]')

      # If this is a backup to disk
      # -----------------------------
      if opts.device == 'disk':
        opts.sbt_library = ''
        if trace:
          print("TRACE: opts.sbt_library set to: ''")

        if opts.directory and opts.format:
          opts.format = "'{}'".format(pathjoin(opts.directory, opts.format))
          if trace:
            print("TRACE: opts.format set to: '{}'".format(opts.format))
        elif opts.directory and not opts.format:
          if opts.type in ('database', 'datafile', 'tablespace', 'arch'):
            opts.directory = ''
            if trace:
              print("TRACE: opts.directory set to: ''")
              print("TRACE: opts.format set to ''")
            msg  = "The directory ({}) option was not set and this is a backup to device disk. We will assume".format(opts.args['directory']['name'], opts.args['device']['name'])
            msg += '\nthis is a backup to the Fast Recovery Area (FRA). This warning message can be supressed with'
            msg += '\ndirectory ({}) option or not specifying the -format ({}) option.'.format(opts.args['directory']['name'],opts.args['format']['name'])
            print_message(msg, 'note')
        elif opts.format and not opts.directory:
          opts.format = ''
          if trace:
            print("TRACE: opts.format set to '{}'".format(opts.format))
          print_message("Resetting format option to null for backup to Fast Recovery Area (FRA).", 'note')
      elif opts.device == 'sbt':
        if opts.type in ('database', 'datafile', 'tablespace', 'arch', 'fra'):
          if not opts.sbt_library:
            print_message('No value specified for sbt_library {}, defaulting to oracle.disksbt.'.format(opts.args['sbt_library']['name']), 'note')
            opts.sbt_library = 'oracle.disksbt'
            if trace:
              print('TRACE: opts.sbt_library set to: {}'.format(opts.sbt_library))

          if opts.sbt_library == 'oracle.disksbt':
            if not opts.format:
              msg  = 'The format option was not specified for device ({}) type SBT. Format string may be set with'.format(opts.args['device']['name'], opts.args['format']['name'])
              msg += "\nthe format ({}) option. Defaulting to: '%d-%U'.".format(opts.args['format']['name'])
              print_message(msg, 'note')
              opts.format = "'%d-%U'"
            if opts.directory:
              opts.format = "'{}' parms='SBT_LIBRARY={},ENV=(BACKUP_DIR={})'".format(opts.format, opts.sbt_library, opts.directory)
            else:
              msg  = "The directory ({}) option was not specified. A backup directory is required when SBT Library is set to 'oracle.disksbt'.".format(opts.args['directory']['name'])
              msg += '\nDirectory may be set with the directory ({}) option.'.format(opts.args['directory']['name'])
              print_message(msg, 'error')
              exit(1)
          else:
            opts.format = "'{}' parms='{}'".format(opts.format, opts.sbt_library)

          if opts.sbt_library == 'oracle.disksbt':
            msg  = 'The oracle.disksbt tape library emulates backup to a tape library but instead of writing to tape, it'
            msg += '\nwrites to a file system direcotry. This should be used for testing purposes only. Do not rely on it'
            msg += '\nfor production database backups. Recovery using this device is not supported by Oracle Corp.'
            print_message(msg, 'caution')

          if trace:
            print('TRACE: opts.format set to: {}'.format(opts.format))

    # Validate number of channels
    # ----------------------------
    if not opts.channels:
      opts.channels = 1

    # Validate report_schema option ...
    # ---------------------------------
    if (opts.report_schema and opts.db_role) and opts.db_role != 'PRIMARY':
      print_message("The report schema ({}) option: 'report_schema' cannot be used unless the database role\nis: 'PRIMARY'.".format(opts.args['report_schema']['name']), 'caution')
      exit(1)

    # Validate plus_archivelog option ...
    # ------------------------------------
    if opts.db_role and (opts.db_role != 'PRIMARY' and opts.plus_archivelog and opts.type in ('database','datafile','tablespace')):
      print_message("The plus_archivelog ({}) option cannot be used unless the database role is: 'PRIMARY'.".format(opts.args['plus_archivelog']['name']), 'caution')
      exit(1)

    # Validate skip option ...
    # --------------------------
    if opts.skip:
      for s in opts.skip:
        if s not in skips:
          msg = 'The skip ({}) option must be a comma delimited list of any or all of the following:'.format(opts.args['skip']['name'])
          for _ in skips :
            msg += '\n  - {}'.format(_)
          msg += '\n\nYou specified: {}'.format(opts.skip)
          print_message(msg, 'caution')

    # Validate Compression level
    # ------------------------------
    if opts.compression_level:
      if opts.compression_level not in compression_levels:
        msg  = 'The compression_level ({}) option must be one of:'.format(opts.args['compression_level']['name'])
        for _ in compression_levels:
          msg += '\n  - {}'.format(_)
        msg += '\n\nYou specified: {}'.format(opts.compression_level)
        print_message(msg, 'error')
        exit(1)

    # Validate duration option...
    # -----------------------------
    if opts.max_duration:
      if opts.max_duration.count(':') != 1:
        msg  = 'The max_duration ({}) option must be in the form of hh:mm.'.format(opts.args['max_duration']['name'])
        msg += '\nYou specified: {}'.format(opts.max_duration)
        print_message(msg, 'error')
        exit(1)
      else:
        (hh, mm) = opts.max_duration.split(':')
        if not hh.isdigit():
          print_message('Invalid hours in max_duration ({}). Max Duration specified: {}'.format(opts.args['max_duration']['name']), 'error')
          exit(1)
        if not mm.isdigit():
          print_message('Invalid minutes in max_duration ({}). Duration\nspecified: {}'.format(opts.args['max_duration']['name']), 'error')
          exit(1)

    # Validate incremental level option...
    # -------------------------------------
    if not opts.level:
      opts.level = 'full'
    elif opts.level not in levels:
      msg  = 'Invalid level ({}) specified: {}. level must be one of: {}'.format(opts.args['level']['name'], opts.level, ', '.join(levels))
      print_message(msg, 'error')
      exit(1)

    # Validate skip option...
    # -------------------------
    if opts.skip and opts.type != 'datafile':
      msg  = 'The skip option ({}) is only valid for datafile backups.'.format(opts.args['skip']['name'])
      msg += '\n\nExample:'
      msg += '\n{} -type datafile {} offline,readonly'.format(cmd, opts.args['skip']['name'])
      msg += '\n\nYou specified backup type: {}'.format(opts.type)
      print_message(msg, 'error')
      exit(1)

    # Validate backup type option...
    # --------------------------------
    if opts.type == 'datafile' and not opts.datafiles:
      msg  = 'When performing a datafile backup a datafile list is required.'
      msg += '\n\nExample:'
      msg += '\n {} {} datafile -datafiles 1,2,3'.format(cmd, opts.args['type']['name'])
      print_message(msg, 'error')
      exit(1)

    # Validate copy option...
    # -------------------------
    if opts.copy:
      if opts.max_set_size:
        msg  = 'The copy ({}) and maximum set size ({}) options cannot be used together.'.format(opts.args['copy']['name'], opts.args['max_set_size']['name'])
        print_message(msg, 'error')
        exit(1)
      if opts.compression_level:
        msg  = 'The copy ({}) and compression level ({}) options cannot be used together.'.format(opts.args['copy']['name'], opts.args['compression_level']['name'])
        print_message(msg, 'error')
        exit(1)

    # Validate max duration option...
    # For handling: RMAN-03003: command not implemented yet: DURATION with BACKUP PLUS ARCHIVELOG
    # ---------------------------------
    if opts.max_duration and opts.plus_archivelog:
      print_message('Max Duration {} and plus_archivelog ({}) not yet implemented in RMAN.'.format(opts.args['max_duration']['name'], opts.args['plus_archivelog']['name']), 'error')
      exit(1)

    # Validate backup FRA option...
    # -------------------------------
    if opts.type == 'fra' and opts.device != 'sbt':
      msg  = 'The Fast Recovery Area can only be backed up to tape.'
      msg += '\nYou specified: {} {} {} {}'.format(opts.args['type']['name'], opts.type, opts.args['device']['name'], opts.device)
      msg += '\n\nExample:'
      msg += '\n {} {} fra {} sbt'.format(cmd, opts.args['type']['name'], opts.args['device']['name'])
      print_message(msg, 'error')
      exit(1)

    # Validate delete archivelog option...
    # --------------------------------------
    if opts.delete_archivelogs and not opts.archivelogs:
      msg  = 'The archivelogs ({}) option is required when using the delete_archivelogs ({})'.format(opts.args['archivelogs']['name'], opts.args['delete_archivelogs']['name'])
      msg += '\noption.'
      print_message(msg, 'error')
      exit(1)

    if opts.delete_delay and not opts.delete_archivelogs:
      msg  = 'The delete_archivelogs ({}) option is required when using the delete_delay ({})'.format(opts.args['delete_archivelogs']['name'], opts.args['delete_delay']['name'])
      msg += '\noption.'
      msg += '\n\nYou specified:'
      msg += '\n {:<32}{:<10}'.format('delete_delay (' + opts.args['delete_delay']['name'] + ')'             , ' = ' + str(opts.delete_delay))
      msg += '\n {:<32}{:<10}'.format('delete_archivelogs (' + opts.args['delete_archivelogs']['name'] + ')' , ' = ' + str(opts.delete_archivelogs))
      msg += '\n\nExample:'
      msg += '\n {} {} {} {}'.format(cmd, opts.args['delete_delay']['name'], opts.delete_delay, opts.args['delete_archivelogs']['name'])
      print_message(msg)
      exit(1)

    # Validate incremental/differential cumulative option...
    # --------------------------------------------------------
    if opts.cumulative and (opts.type not in('database','datafile','tablespace')):
      msg  = 'The cumulative ({}) option may only be used with a type ({}) of database, datafile,'.format(opts.args['cumulative']['name'], opts.args['type']['name'])
      msg += '\nor tablespace.'
      msg += '\n\nExample:'
      msg += '\n {} {} {} database'.format(cmd, opts.args['cumulative']['name'], opts.args['type']['name'])
      msg += '\n {} {} {} datafile 1,2,3'.format(cmd, opts.args['cumulative']['name'], opts.args['type']['name'])
      msg += '\n {} {} {} datafile +DATA/LABDB/DATAFILE/USERS.DBF'.format(cmd, opts.args['cumulative']['name'], opts.args['type']['name'])
      msg += '\n {} {} {} tablespace 1,2,3'.format(cmd, opts.args['cumulative']['name'], opts.args['type']['name'])
      msg += '\n {} {} {} tablespace system,sysaux,users'.format(cmd, opts.args['cumulative']['name'], opts.args['type']['name'])
      print_message(msg, 'error')
      exit(1)

    if opts.cumulative and (opts.level in ('0','full')):
      msg  = 'The cumulative ({}) option may not be used with incremental level 0 or full backups.'.format(opts.args['cumulative']['name'])
      msg += '\n\nExample:'
      msg += '\n{} {} 1 {}'.format(cmd, opts.args['level']['name'], opts.args['cumulative']['name'])
      print_message(msg, 'error')
      exit(1)

    # Validate backup type option...
    # --------------------------------
    if not opts.type:
      if not opts.script:
        msg  = 'The type ({}) was not specified. Assuming type = database.'.format(opts.args['type']['name'])
        print_message(msg, 'note')
        opts.type = 'full'

    if opts.type not in ('database','datafile','tablespace'):
       opts.level = ''

    # Validate section size option...
    # ---------------------------------
    if opts.section_size and opts.max_piece_size:
      msg  = 'The section_size ({}) option may not be used with max_piece_size ({})'.format(opts.args['section_size']['name'], opts.args['max_piece_size']['name'])
      msg += '\n\nYou specified:'
      msg += '\n  {:<32}{:<10}'.format('section_size (' + opts.args['section_size']['name'] + ')'             , ' = ' + str(opts.section_size))
      msg += '\n  {:<32}{:<10}'.format('max_piece_size (' + opts.args['max_piece_size']['name'] + ')' , ' = ' + str(opts.max_piece_size))
      print_message(msg, 'error')
      exit(1)

    if opts.section_size and opts.copy:
      msg  = 'The section_size ({}) option may not be used with copy ({})'.format(opts.args['section_size']['name'], opts.args['copy']['name'])
      msg += '\n\nYou specified:'
      msg += '\n  {:<32}{:<10}'.format('section_size (' + opts.args['section_size']['name'] + ')'             , ' = ' + str(opts.section_size))
      msg += '\n  {:<32}{:<10}'.format('copy (' + opts.args['copy']['name'] + ')' , ' = ' + str(opts.copy))
      print_message(msg, 'error')
      exit(1)

    if opts.files_per_set and opts.copy:
      msg  = 'The files_per_set ({}) option may not be used with copy ({})'.format(opts.args['files_per_set']['name'], opts.args['copy']['name'])
      msg += '\n\nYou specified:'
      msg += '\n  {:<32}{:<10}'.format('files_per_set (' + opts.args['files_per_set']['name'] + ')'             , ' = ' + str(opts.files_per_set))
      msg += '\n  {:<32}{:<10}'.format('copy (' + opts.args['copy']['name'] + ')' , ' = ' + str(opts.copy))
      print_message(msg, 'error')
      exit(1)

    # Validate incremental level option...
    # -------------------------------------
    if opts.level in ('0','1') and opts.copy:
      msg  = "Option level = 0|1 ({} 0|1) may not be used with the copy ({}) option. Try 'full'.".format(opts.args['level']['name'], opts.args['copy']['name'])
      print_message(msg, 'error')
      exit(1)

    # Validate archlog_copies option...
    # ---------------------------------
    if opts.archlog_copies and (not opts.plus_archivelog and not opts.archivelogs):
      msg  = 'The archivelogs ({}) option or plus_archivelog ({}) option is mandatory'.format(opts.args['archivelogs']['name'], opts.args['plus_archivelog']['name'])
      msg += '\nwhen using the archlog_copies ({}) option.'.format(opts.args['archlog_copies']['name'])
      print_message(msg, 'error')
      exit(1)

    # Validate keep option...
    # -------------------------
    if opts.keep and (not opts.format and not opts.directory):
      msg  = 'The keep ({}) option may not be used when backing up to the FRA.'.format(opts.args['keep']['name'], opts.args['plus_archivelog']['name'])
      msg += '\nCheck the {} and {} option settings.'.format(opts.args['format']['name'],opts.args['directory']['name'])
      print_message(msg, 'error')
      exit(1)

    # Validate generate option...
    # -----------------------------
    if opts.generate and opts.debug:
       msg = 'The generate ({}) and debug ({}) options may not be used together.'.format(opts.args['generate']['name'], opts.args['debug']['name'])
       print_message(msg, 'error')
       exit(1)

    # ---------------------------------------------------------------
    # Disable any options that don't apply to this Rman type.
    # ---------------------------------------------------------------
    if opts.type != 'datafile':
      opts.datafiles = ''
      if trace:
        print('TRACE: {} reset due to {}'.format(opts.args['datafiles']['name'], opts.args['type']['name']))

    if opts.type != 'tablespace':
      opts.tablespaces = ''
      if trace:
        print('TRACE: {} reset due to {}'.format(opts.args['tablespaces']['name'], opts.args['type']['name']))

    if opts.type == 'arch' or opts.archivelogs:
      if opts.type == 'validate_restore':
        opts.files_per_set = ''
      if opts.type == 'validate_restore':
        opts.no_checksum = False

    if opts.type in ('resync','register','list_expired'):
      opts.channels = 0

    if opts.type in ('resync','register','list_expired','report_obsolete','report_unrecoverable','report_need_backup'):
      opts.archlog_copies            = ''
      opts.archivelogs               = False
      opts.compression_level         = ''
      opts.compression_optimization  = False
      opts.controlfile               = False
      opts.copy                      = False
      opts.cumulative                = False
      opts.delete_delay              = ''
      opts.delete_archivelogs        = False
      opts.directory                 = ''
      opts.distributed_channels      = False
      opts.max_duration              = ''
      opts.files_per_set             = ''
      opts.force                     = False
      opts.format                    = ''
      opts.keep                      = ''
      opts.level                     = ''
      opts.max_open_files            = ''
      opts.max_piece_size            = ''
      opts.max_set_size              = ''
      opts.no_checksum               = False
      opts.no_exclude                = False
      opts.plus_archivelog           = False
      opts.section_size              = ''
      opts.streaming_rate            = ''
      if trace:
        print('TRACE:')
        print('TRACE: {:<15s} reset due to {} {}'.format(opts.args['archivelogs']['name'],              opts.args['type']['name'], opts.args['type']['value']))
        print('TRACE: {:<15s} reset due to {} {}'.format(opts.args['archlog_copies']['name'],           opts.args['type']['name'], opts.args['type']['value']))
        print('TRACE: {:<15s} reset due to {} {}'.format(opts.args['compression_level']['name'],        opts.args['type']['name'], opts.args['type']['value']))
        print('TRACE: {:<15s} reset due to {} {}'.format(opts.args['compression_optimization']['name'], opts.args['type']['name'], opts.args['type']['value']))
        print('TRACE: {:<15s} reset due to {} {}'.format(opts.args['controlfile']['name'],              opts.args['type']['name'], opts.args['type']['value']))
        print('TRACE: {:<15s} reset due to {} {}'.format(opts.args['copy']['name'],                     opts.args['type']['name'], opts.args['type']['value']))
        print('TRACE: {:<15s} reset due to {} {}'.format(opts.args['cumulative']['name'],               opts.args['type']['name'], opts.args['type']['value']))
        print('TRACE: {:<15s} reset due to {} {}'.format(opts.args['delete_archivelogs']['name'],       opts.args['type']['name'], opts.args['type']['value']))
        print('TRACE: {:<15s} reset due to {} {}'.format(opts.args['delete_delay']['name'],             opts.args['type']['name'], opts.args['type']['value']))
        print('TRACE: {:<15s} reset due to {} {}'.format(opts.args['directory']['name'],                opts.args['type']['name'], opts.args['type']['value']))
        print('TRACE: {:<15s} reset due to {} {}'.format(opts.args['distributed_channels']['name'],     opts.args['type']['name'], opts.args['type']['value']))
        print('TRACE: {:<15s} reset due to {} {}'.format(opts.args['files_per_set']['name'],            opts.args['type']['name'], opts.args['type']['value']))
        print('TRACE: {:<15s} reset due to {} {}'.format(opts.args['force']['name'],                    opts.args['type']['name'], opts.args['type']['value']))
        print('TRACE: {:<15s} reset due to {} {}'.format(opts.args['format']['name'],                   opts.args['type']['name'], opts.args['type']['value']))
        print('TRACE: {:<15s} reset due to {} {}'.format(opts.args['keep']['name'],                     opts.args['type']['name'], opts.args['type']['value']))
        print('TRACE: {:<15s} reset due to {} {}'.format(opts.args['level']['name'],                    opts.args['type']['name'], opts.args['type']['value']))
        print('TRACE: {:<15s} reset due to {} {}'.format(opts.args['max_duration']['name'],             opts.args['type']['name'], opts.args['type']['value']))
        print('TRACE: {:<15s} reset due to {} {}'.format(opts.args['max_open_files']['name'],           opts.args['type']['name'], opts.args['type']['value']))
        print('TRACE: {:<15s} reset due to {} {}'.format(opts.args['max_piece_size']['name'],           opts.args['type']['name'], opts.args['type']['value']))
        print('TRACE: {:<15s} reset due to {} {}'.format(opts.args['max_set_size']['name'],             opts.args['type']['name'], opts.args['type']['value']))
        print('TRACE: {:<15s} reset due to {} {}'.format(opts.args['no_checksum']['name'],              opts.args['type']['name'], opts.args['type']['value']))
        print('TRACE: {:<15s} reset due to {} {}'.format(opts.args['no_exclude']['name'],               opts.args['type']['name'], opts.args['type']['value']))
        print('TRACE: {:<15s} reset due to {} {}'.format(opts.args['optimization']['name'],             opts.args['type']['name'], opts.args['type']['value']))
        print('TRACE: {:<15s} reset due to {} {}'.format(opts.args['plus_archivelog']['name'],          opts.args['type']['name'], opts.args['type']['value']))
        print('TRACE: {:<15s} reset due to {} {}'.format(opts.args['section_size']['name'],             opts.args['type']['name'], opts.args['type']['value']))
        print('TRACE: {:<15s} reset due to {} {}'.format(opts.args['streaming_rate']['name'],           opts.args['type']['name'], opts.args['type']['value']))

    if opts.type in ('crosscheck'):
      opts.archlog_copies      = ''
      opts.archlogs            = False
      opts.format              = ''
      opts.compress_level      = ''
      opts.compress_option     = False
      opts.controlfile         = False
      opts.copy                = False
      opts.cumulative          = False
      opts.delete_delay        = ''
      opts.directory           = ''
      opts.delete_archivelogs  = False
      opts.duration            = ''
      opts.files_per_set       = ''
      opts.force               = False
      opts.keep                = ''
      opts.level               = ''
      opts.max_open_files      = ''
      opts.max_piece_size      = ''
      opts.max_set_size        = ''
      opts.no_checksum         = False
      opts.no_exclude          = False
      opts.plus_archivelog     = False
      opts.section_size        = ''
      opts.sbt_library         = ''
      opts.streaming_rate      = ''
      if trace:
        print('TRACE:')
        print('TRACE: {:<15s} reset due to {}'.format(opts.args['archlog_copies']['name'],     opts.args['type']['name'], opts.args['type']['value']))
        print('TRACE: {:<15s} reset due to {}'.format(opts.args['archlogs']['name'],           opts.args['type']['name'], opts.args['type']['value']))
        print('TRACE: {:<15s} reset due to {}'.format(opts.args['compress_level']['name'],     opts.args['type']['name'], opts.args['type']['value']))
        print('TRACE: {:<15s} reset due to {}'.format(opts.args['compress_option']['name'],    opts.args['type']['name'], opts.args['type']['value']))
        print('TRACE: {:<15s} reset due to {}'.format(opts.args['controlfile']['name'],        opts.args['type']['name'], opts.args['type']['value']))
        print('TRACE: {:<15s} reset due to {}'.format(opts.args['copy']['name'],               opts.args['type']['name'], opts.args['type']['value']))
        print('TRACE: {:<15s} reset due to {}'.format(opts.args['cumulative']['name'],         opts.args['type']['name'], opts.args['type']['value']))
        print('TRACE: {:<15s} reset due to {}'.format(opts.args['delete_delay']['name'],       opts.args['type']['name'], opts.args['type']['value']))
        print('TRACE: {:<15s} reset due to {}'.format(opts.args['delete_archivelogs']['name'], opts.args['type']['name'], opts.args['type']['value']))
        print('TRACE: {:<15s} reset due to {}'.format(opts.args['duration']['name'],           opts.args['type']['name'], opts.args['type']['value']))
        print('TRACE: {:<15s} reset due to {}'.format(opts.args['files_per_set']['name'],      opts.args['type']['name'], opts.args['type']['value']))
        print('TRACE: {:<15s} reset due to {}'.format(opts.args['force']['name'],              opts.args['type']['name'], opts.args['type']['value']))
        print('TRACE: {:<15s} reset due to {}'.format(opts.args['keep']['name'],               opts.args['type']['name'], opts.args['type']['value']))
        print('TRACE: {:<15s} reset due to {}'.format(opts.args['level']['name'],              opts.args['type']['name'], opts.args['type']['value']))
        print('TRACE: {:<15s} reset due to {}'.format(opts.args['max_open_files']['name'],     opts.args['type']['name'], opts.args['type']['value']))
        print('TRACE: {:<15s} reset due to {}'.format(opts.args['max_piece_size']['name'],     opts.args['type']['name'], opts.args['type']['value']))

  if trace:
    print('TRACE:')
    print('TRACE: End validate_options()')

  return
# --------------------------------------------------------------------------------------------------
# End validate_options()
# --------------------------------------------------------------------------------------------------

# --------------------------------------------------------------------------------------------------
# Name: wipe_logs()
# Desc: Delete all log files except the current log.
# Args: <none>
# Retn: rc = return code, logstat['removed'] = files identified for removal
# --------------------------------------------------------------------------------------------------
def wipe_logs():
  if trace:
    print('TRACE:')
    print('TRACE: Begin wipe_logs()')

  rc = 0

  # Purge old logfiles
  # ------------------------
  if opts.wipe_logs:
    pattern = '{}.\d\d\d\d-\d\d-\d\d.\d\d:\d\d:\d\d.log'.format(cmd)
    try:
      logfiles = listdir(log_dir)
    except:
      print_message('Unable to list files in the log directory. Skipping log wipe.', 'caution')
      rc += 1
    else:
      # remove current log file from the list
      if basename(logfile) in logfiles:
        logfiles.remove(basename(logfile))

      logstat = {'candidates' : [], 'failed' : [], 'removed' : []}
      for f in sorted(logfiles):
        if match(pattern, f):
          fqn = '{}/{}'.format(log_dir, f)
          logstat['candidates'].append(fqn)
          try:
            unlink(fqn)
            logstat['removed'].append(fqn)
          except:
            logstat['failed'].append(fqn)

      if logstat['failed']:
        print_message('Unable to remove the following log files:\n {}'.format('\n '.join(logstat['failed'])), 'note')
        rc += 1

  if trace:
    print('TRACE:')
    print('TRACE: End wipe_logs()')

  return rc, logstat['removed'], logstat['failed']
# --------------------------------------------------------------------------------------------------
# End wipe_logs()
# --------------------------------------------------------------------------------------------------

# --------------------------------------
# ---- Main ----------------------------
# --------------------------------------
if __name__ == '__main__':
  cmd         = basename(argv[0]).split('.')[0]
  cmd_long    = 'Database Backup Utility for Oracle'
  vsn         = '1.05'
  vsn_date    = 'Tue Apr 5 09:36:50 CDT 2022'
  dev_state   = 'Production'
  banner      = cmd_long + ' ' + vsn + ' '  + dev_state + ' Release. ' + vsn_date
  sql_header  = '/***** ' + cmd_long.upper() + ' *****/'
  oratab      = '/etc/oratab'
  passwd_file = '.passwd'
  pid         = getpid()
  errlkp      = False
  colsep      = "'~'"
  oratab_loc  = ['/etc/oratab','/var/opt/oracle/oratab']
  components  = ['sqlplus','rdbms', 'oracore']

  if (not python_version >= minvers) and (not python_version <= maxvers):
    print_message('{} only tested with versions {} - {}'.format(python_version, minvers, maxvers), 'caution')

  # sort out directory paths
  #---------------------------
  absolute_path = abspath(argv[0])
  bin_dir       = pathsplit(absolute_path)[0]
  home_dir      = pathsplit(bin_dir)[0]
  etc_dir       = pathjoin(home_dir, 'etc')
  log_dir       = pathjoin(home_dir, 'log')

  # default etc and log directories may be overridden with
  # environment variables: DBU_ETC and DBU_LOG
  # -------------------------------------------------------------
  try:
    etc_dir = environ[cmd.upper() + '_ETC']
  except:
    pass
  try:
    log_dir = environ[cmd.upper() + '_LOG']
  except:
    pass

  # Verify directories
  # ------------------------
  for d in (etc_dir, log_dir):
    if not isdir(d):
      print_message( 'Directory not found: {}'.format(d), 'error')
      exit(1)

  # Set filenames
  # --------------------------
  config_file = pathjoin(etc_dir, cmd + '.cfg')  # Set the configuration file name.
  passwd_file = pathjoin(etc_dir, passwd_file)   # Set prefered password file.

  # Set the log file name
  # ----------------------
  logfile = pathjoin(log_dir, ('{}.{}.log'.format(cmd, datetime.now().strftime('%Y-%m-%d.%H:%M:%S'))))

  # Start logging - attach stdout & stderr to logfile
  # ----------------------------------------------------
  try:
    f = open(logfile, 'wb')
    f.close()
  except:
    print('\nCannot open log file for write: {}'.format(logfile))
    exit(1)
  sys.stdout = Logger(logfile)

  # Parse, load, merge options from configuration file, parameter file, and command line.
  # -------------------------------------------------------------------------------------
  args, trace = parse_arguments()
  opts = Options(args)

  if opts.generate:
    outfile = read_input("Enter output file name")
    try:
      f = open(outfile, 'w')
      f.close()
    except:
      print_message('Cannot open file for write: {}'.format(outfile), 'error')
      exit(1)

  print('')
  print('====================================================================================================')
  print('{:<80}{:>20}'.format(cmd_long, datetime.now().strftime('%m/%d/%Y %H:%M')))
  print('====================================================================================================')

  if trace:
    print('TRACE:')
    print('TRACE: Directories:')
    print('TRACE: Etc: {}'.format(etc_dir))
    print('TRACE: Log: {}'.format(log_dir))

  # Formulate connect strings
  # --------------------------
  opts.tgt_connstr        = ''
  opts.cat_connstr        = ''
  opts.masked_tgt_connstr = ''
  opts.masked_cat_connstr = ''

  if not opts.script:
    # Check for incompatibilities between selected options.
    # ------------------------------------------------------
    validate_options()

    # Get the target database password.
    # -----------------------------------------------------
    opts.tgt_password = get_password(opts.service_name, opts.user, opts.decrypt, passwd_file)
    if not opts.tgt_password:
      print_message('Password lookup failure for target database.\n Service Name: {}\n Username    : {}'.format(opts.service_name, opts.user))
      exit(1)

    # Get the catalog password and set the connect string.
    # ------------------------------------------------------
    if not opts.no_catalog:
      if opts.catalog and opts.catalog_user:
        opts.cat_password = get_password(opts.catalog, opts.catalog_user, opts.decrypt, passwd_file)
        if not opts.cat_password:
          print_message('Password lookup failure for catalog database.\n Service Name: {}\n Catalog User: {}'.format(opts.catalog, opts.catalog_user), 'error')
          exit(1)

    if not opts.no_catalog and (opts.catalog_user and opts.cat_password and opts.catalog):
      opts.cat_connstr         = '{}/{}@{}'.format(opts.catalog_user, opts.cat_password, opts.service_name)
      opts.masked_cat_connstr  = '{}/<********>@{}'.format(opts.catalog_user, opts.service_name)

    if opts.user and opts.tgt_password and opts.service_name:
      opts.tgt_connstr           = '{}/{}@{}'.format(opts.user, opts.tgt_password, opts.service_name)
      opts.masked_tgt_connstr    = '{}/<********>@{}'.format(opts.user, opts.service_name)

    if trace:
      print('TRACE:')
      print('TRACE: opts.tgt_connstr          : {}'.format(opts.tgt_connstr))
      print('TRACE: opts.masked_tgt_connstr   : {}'.format(opts.masked_tgt_connstr))
      print('TRACE:')
      print('TRACE: opts.cat_connstr          : {}'.format(opts.cat_connstr))
      print('TRACE: opts.masked_cat_connstr   : {}'.format(opts.masked_cat_connstr))

    # initialize object (used for querying the database)
    # ----------------------------------------------------
    dbh = Sqlplus(opts.tgt_connstr, sql='')
    if dbh.facilities:
      errlkp = True          # enable error message lookup

    # Check State of Database
    # -------------------------
    rc, opts.db_state = dbh.get_db_state(opts.tgt_connstr)
    if rc or opts.db_state in ('UNKNOWN','OFFLINE'):
      print_message('Cannot determine database state.', 'error')
      exit(1)
    elif opts.db_state not in ('MOUNTED','OPEN'):
      print_message('Database must be mounted/open. Database is {}. Terminating backup.'.format(opts.db_state))
      exit(1)
    elif opts.db_state == 'MOUNTED' and opts.user != 'SYS':
      print_message('User SYS must be used if the database is not open. Database state is {}. Terminating backup.'.format(opts.db_state))
      exit(1)

    # Get the database version from v$instance.
    # -------------------------------------------
    rc, opts.db_vsn = dbh.get_db_version(opts.tgt_connstr)

    rc, db_info = dbh.get_db_info(opts.tgt_connstr)
    if not rc:
      opts.db_name             = db_info['DB_NAME']
      opts.db_unique_name      = db_info['DB_UNIQUE_NAME']
      opts.dbid                = db_info['DBID']
      opts.db_open_mode        = db_info['OPEN_MODE']
      opts.prim_db_unique_name = db_info['PRIMARY_DB_UNIQUE_NAME']
      opts.db_role             = db_info['DATABASE_ROLE']
      opts.db_so_stat          = db_info['SWITCHOVER_STATUS']
      opts.db_reco_dest        = db_info['RECOVERY_DEST']
      opts.db_reco_size        = db_info['RECOVERY_SIZE']
      opts.cluster_db          = db_info['CLUSTER_DATABASE']
      opts.db_hostname         = db_info['DB_HOSTNAME']
      try:
        opts.cluster_db = tf(opts.cluster_db)
      except:
        print_message('Unexpected results in CLUSTER_DATABASE: {}'.format(opts.cluster_db))
        exit(1)

      if trace:
        print('TRACE:')
        print('TRACE: db_name             : {}'.format(opts.db_name))
        print('TRACE: db_unique_name      : {}'.format(opts.db_unique_name))
        print('TRACE: dbid                : {}'.format(opts.dbid))
        print('TRACE: db_open_mode        : {}'.format(opts.db_open_mode))
        print('TRACE: prim_db_unique_name : {}'.format(opts.prim_db_unique_name))
        print('TRACE: db_role             : {}'.format(opts.db_role))
        print('TRACE: db_so_stat          : {}'.format(opts.db_so_stat))
        print('TRACE: db_reco_dest        : {}'.format(opts.db_reco_dest))
        print('TRACE: db_reco_size        : {}'.format(opts.db_reco_size))
        print('TRACE: cluster_db          : {}'.format(opts.cluster_db))
        print('TRACE: db_hostname         : {}'.format(opts.db_hostname))

    # Get the number of active services we can use for the backup.
    # --------------------------------------------------------------
    rc, opts.inst_count = dbh.get_inst_count(opts.tgt_connstr, opts.service_name)
    if opts.inst_count == 0:
      print_message('No active instances found for service name: {}. Terminating backup.'.format(opts.service_name))
      exit(1)

    # Handling all the directory, format, sbt_library stuff here...
    # --------------------------------------------------------------
    if opts.format:
      if opts.directory:
        if opts.db_unique_name:
           opts.directory = opts.directory.replace('[DBNAME]', opts.db_unique_name)
           opts.format = "{}".format(opts.format.replace('[DBNAME]', opts.db_unique_name))
        else:
           opts.directory = opts.directory.replace('[DBNAME]', environ['ORACLE_SID'])
           opts.format = "{}".format(opts.format.replace('[DBNAME]', environ['ORACLE_SID']))

    # # Allocate Channel(s)
    # ALLOCATE CHANNEL SBT1 DEVICE TYPE SBT
    #  FORMAT '%U%D' parms='SBT_LIBRARY=oracle.disksbt,ENV=(BACKUP_DIR=/archive/rjohnson//RANDY19M)';

      # -----------------------------------------------
      # This only gets executed when *not* running an
      # external Rman script (-script option)
      # -----------------------------------------------
      if opts.distributed_channels:
        # determine the total number of channels
        if opts.inst_count > 1:
          opts.channels = opts.channels * opts.inst_count

        # Set the channel connect string.
        if not opts.user:
          msg  = '{} ({}) option is required when using the {} option.'.format(opts.args['user']['name'],opts.args['user']['name'],opts.args['distributed_channels']['name'])
          msg += '\n\nExample:\n  {} {} {} sys ...'.format(cmd,opts.args['distributed_channels']['name'],opts.args['user']['name'])
          print_message(msg, 'error')
          exit(1)
        else:
          if trace:
           print('TRACE: tgt_connstr              : {}'.format(opts.tgt_connstr))
           print('TRACE: opts.masked_tgt_connstr  : {}'.format(opts.masked_tgt_connstr))

  print('Program Info')
  print(' Command, version                   : {}, v{}'.format(cmd, vsn))
  print(' Log File                           : {}'.format(basename(logfile)))
  print(' Host                               : {}'.format(opts.hostname))
  if opts.oracle_sid:
    print(' Oracle SID                         : {}'.format(opts.oracle_sid))
  print(' Process ID                         : {}'.format(pid))

  if not opts.script:
    print('')
    print('{} Options:'.format(cmd.upper()))
    print(' Description                        : {}'.format(opts.description))
    if opts.archivelogs:
      print(' Backup Archlogs                    : {}'.format(yn(opts.archivelogs)))
    if opts.archlog_copies:
      print(' Backup Archlogs n times            : {}'.format(opts.archlog_copies))
    if opts.controlfile:
      print(' Backup Controlfile                 : {}'.format(yn(opts.controlfile)))
    if opts.device:
      print(' Backup Device                      : {}'.format(opts.device))
    if opts.directory:
      print(' Backup Directory                   : {}'.format(opts.directory))
    if opts.type in ('database', 'datafile', 'tablespace', 'arch') and (not opts.format) and (not opts.directory):
      print(' Backup Format                      : <Fast Recovery Area>')
    elif opts.format:
      print(' Backup Format                      : {}'.format(opts.format))
    if opts.optimization:
      print(' Backup Optimization                : {}'.format(yn(opts.optimization)))
    if opts.type:
      print(' Backup Type                        : {}'.format(opts.type))
    if opts.copy:
      print(' Backup as Copy                     : {}'.format(yn(opts.copy)))
    if opts.masked_tgt_connstr:
      print(' Connect String (target)            : {}'.format(opts.masked_tgt_connstr))
    if opts.masked_cat_connstr:
      print(' Connect String (catalog)           : {}'.format(opts.masked_cat_connstr))
    if opts.channels:
      print(' Channels per Instance              : {}'.format(opts.channels))
    if not opts.compression_level:
      if not opts.script:
        print(' Compression                        : off')
    else:
      print(' Compression                        : {}'.format(opts.compression_level))
      if opts.compression_optimization:
        print(' Compression Optimized for Load     : {}'.format(yn(opts.compression_optimization)))
    if opts.configure:
      print(' Configure RMAN                     : {}'.format(yn(opts.configure)))
    if opts.decrypt:
      print(' Decrypt Passwords                  : {}'.format(opts.decrypt))
    if opts.debug:
      print(' Debug RMAN                         : {}'.format(opts.debug))
    if opts.datafiles:
      if len(', '.join(opts.datafiles)) + (len(opts.datafiles) * 2) <= 64:
        print(' Database File List                 : {}'.format(', '.join(opts.datafiles)))
      else:
        print(' Database File List                 : {}'.format(',\n                                      '.join(opts.datafiles)))
    if opts.delete_delay:
      print(' Delay Delete Archlogs n days       : {}'.format(opts.delete_delay))
    if opts.delete_archivelogs:
      print(' Delete Archlogs                    : {}'.format(yn(opts.delete_archivelogs)))
    if opts.delete_obsolete:
      print(' Delete Obsolete                    : {}'.format(yn(opts.delete_obsolete)))
    if opts.distributed_channels:
      print(' Distributed Channels               : {}'.format(yn(opts.distributed_channels)))
    if opts.distribution_list:
      print(' Distribution List                  : {}'.format(',\n                                      '.join(opts.distribution_list)))
    if opts.script:
      print(' Enternal Rman Script               : {}'.format(opts.script))
    if opts.files_per_set:
      print(' Files Per Set                      : {}'.format(opts.files_per_set))
    if opts.force:
      print(' opts.force                         : {}'.format(opts.force))
    if opts.generate:
      print(' Generate Only                      : {}'.format(yn(opts.generate)))
    if opts.level:
      print(' Incremental Level                  : {}'.format(opts.level))
      if opts.level == 1:
        if opts.cumulative:
          print(' Incremental Type                 : {}'.format(opts.cumulative))
        else:
          print(' Incremental Type                 : {}'.format('incremental'))
    if opts.keep:
      print(' Keep Days                          : {}, keep logs'.format(opts.keep))
    if opts.max_duration:
      print(' Max Duration                       : {}'.format(opts.max_duration))
    if opts.max_open_files:
      print(' Max Open Files                     : {}'.format(opts.max_open_files))
    if opts.max_piece_size:
      print(' Max Piece Size                     : {}'.format(opts.max_piece_size))
    if opts.max_set_size:
      print(' Max Set Size                       : {}'.format(opts.max_set_size))
    if opts.no_checksum:
      print(' No Checksum                        : {}'.format(opts.no_checksum))
    if opts.no_exclude:
      print(' No Exclude                         : {}'.format(opts.no_exclude))
    if opts.notify == 'always':
      print(' Notify                             : Always')
    elif opts.notify == 'failure':
      print(' Notify                             : Failures only')
    elif opts.notify == 'off':
      print(' Notify                             : Off')
    if opts.parfile:
      print(' Parameter file                     : {}'.format(opts.parfile))
    if opts.plus_archivelog:
      print(' Plus Archlogs                      : {}'.format(yn(opts.plus_archivelog)))
    if opts.report_schema:
      print(' Report Schema                      : {}'.format(opts.report_schema))
    if opts.retention:
      print(' Retention                          : {}'.format(opts.retention))
    if opts.sbt_library:
      print(' SBT Library                        : {}'.format(opts.sbt_library))
    if opts.section_size:
      print(' Section Size                       : {}'.format(opts.section_size))
    if opts.show:
      print(' Show Only                          : {}'.format(yn(opts.show)))
    if opts.skip:
      print(' Skip                               : {}'.format(',\n                                       '.join(opts.skip)))
    if opts.streaming_rate:
      print(' Streaming Rate                     : {}'.format(opts.streaming_rate))
    if opts.user:
      print(' Database User                      : {}'.format(opts.user))
    if opts.service_name:
      print(' Target Service Name                : {}'.format(opts.service_name))
    if opts.tablespaces:
      if len(', '.join(opts.tablespaces)) + (len(opts.tablespaces) * 2) <= 64:
        print(' Tablespace List                    : {}'.format(', '.join(opts.tablespaces)))
      else:
        print(' Tablespace List                    : {}'.format(',\n                                      '.join(opts.tablespaces)))
    print(' Wipe Logs                          : {}'.format(yn(opts.wipe_logs)))

    print('')
    print('Runtime Values')
    if opts.db_hostname:
      print(' Hostname                           : {}'.format(opts.db_hostname))
    if 'ORACLE_SID' in environ:
      print(' ORACLE_SID                         : {}'.format(environ['ORACLE_SID']))
    if 'ORACLE_HOME' in environ:
      print(' ORACLE_HOME                        : {}'.format(environ['ORACLE_HOME']))
    if 'TNS_ADMIN' in environ:
      print(' TNS_ADMIN                          : {}'.format(environ['TNS_ADMIN']))
    if 'LD_LIBRARY_PATH' in environ:
      print(' LD_LIBRARY_PATH                    : {}'.format(', '.join(environ['LD_LIBRARY_PATH'].split(':'))))
    if 'ORA_NLS10' in environ:
      print(' ORA_NLS10                          : {}'.format(environ['ORA_NLS10']))
    print(' Instance State                     : {}'.format(opts.db_state))
    print(' Database Name                      : {}'.format(opts.db_name))
    print(' Database ID                        : {}'.format(opts.dbid))
    print(' Database Unique Name               : {}'.format(opts.db_unique_name))
    print(' Database Version                   : {}'.format(opts.db_vsn))
    print(' Cluster Database                   : {}'.format(opts.cluster_db))
    print(' Active Instances                   : {}'.format(opts.inst_count))
    if opts.service_name:
      print(' Active Service Instances           : {}'.format(opts.inst_count))
    print(' Backup Channels                    : {}'.format(opts.channels))
    print(' Database Role                      : {}'.format(opts.db_role))
    print(' Database Mode                      : {}'.format(opts.db_open_mode))
    print(' Switchover Status                  : {}'.format(opts.db_so_stat))
    if opts.prim_db_unique_name:
      print(' Primary Database Unique Name       : {}'.format(opts.prim_db_unique_name))
    print(' Fast Recovery Area Dest            : {}'.format(opts.db_reco_dest))
    if opts.db_reco_size:
      print(' Fast Recovery Area Size            : {}'.format(reduce_size(opts.db_reco_size)))
    else:
      print(' Fast Recovery Area Size            : ')

  if opts.debug:
    print_message('Rman Error checking disabled due to debug mode.', 'note')

  removed_logs = ''
  failed_logs  = ''
  if opts.wipe_logs:
    rc, removed_logs, failed_logs = wipe_logs()
  if rc:
    print_message('Unable to remove old log files.', 'warning')
  else:
    if removed_logs:
      print('\nLog files purged:')
      print(' {}'.format('\n '.join(removed_logs)))

    if failed_logs:
      print('\nLog files failed to purge:          : {}'.format('\n                                      '.join(failed_logs)))

  if not (opts.show or opts.generate or opts.script):
    if opts.db_state in ('UNKNOWN', 'OFFLINE', 'STARTED'): 
      print_message('Database must be mounted or open for RMAN to execute a backup.', 'error')
      exit(1)

  if True not in (opts.show, opts.generate) and not opts.script:
    # Create the backup directory if necessary.
    # -------------------------------------------
    if ((opts.device == 'disk' and opts.format and opts.directory) or 'oracle.disksbt' in opts.sbt_library) and not isdir(opts.directory):
      if opts.type in ('database', 'datafile', 'tablespace', 'arch'):
        if True not in (opts.generate, opts.show):
          print_message('Creating new backup directory: {}'.format(opts.directory), 'note')
          try:
            makedirs(opts.directory)
          except:
            print_message('Cannot create backup directory: {}'.format(opts.directory), 'error')
            exit(1)

  # initialize the Rman object...
  rmh = Rman(rcv='')

  # generate the rman commands...
  # --------------------------------
  if opts.script:
    rmh.rcv = ''
    try:
      with open(opts.script, 'r') as f:
        rmh.rcv = f.read()
    except:
      print_message('Cannot open file for read: {}'.format(opts.script), 'error')
      exit(1)
  elif opts.type == 'crosscheck':
    rmh.gen_crosscheck()
  elif opts.type == 'register':
    rmh.gen_register_database()
  elif opts.type == 'delete_expired':
    rmh.gen_delete_expired()
  elif opts.type == 'delete_obsolete':
    rmh.gen_delete_obsolete()
  elif opts.type == 'list_expired':
    rmh.gen_list_expired()
  elif opts.type == 'report_schema':
    rmh.gen_report_schema()
  elif opts.type == 'report_need_backup':
    rmh.gen_report_need_backup()
  elif opts.type == 'report_unrecoverable':
    rmh.gen_report_unrecoverable()
  elif opts.type == 'report_obsolete':
    rmh.gen_report_obsolete()
  elif opts.type == 'resync':
    rmh.gen_resync()
  elif opts.type == 'validate_backup':
    rmh.gen_validate_backup()
  elif opts.type == 'validate_restore':
    rmh.gen_validate_restore()
  elif opts.type == 'arch':
    rmh.gen_archivelogs()
    rmh.gen_delete_obsolete()
  elif opts.type in ('database','datafile','tablespace'):
    rmh.gen_backup_database()
    if opts.archivelogs:
      rmh.gen_archivelogs()
    if opts.delete_obsolete:
      rmh.gen_delete_obsolete()
  elif opts.type == 'fra':
    rmh.gen_backup_fra()
  else:
    print_message('Invalid backup type.', 'error')
    exit(1)

  # ...and finally, execute the rman script...
  # -------------------------------------------
  if True not in (opts.generate, opts.show):
    rc, err = rmh.set_env()
    if rc:
      print_message('Error configuring the RMAN execution environment.', 'error')
      exit(rc)

    rc, stdout = rmh.execute_rcv()
    if rc:
      if errlkp:
        rmh.print_error()
      print_message('Rman failed.')
      exit(rc)
  else:
    if opts.show:
      rmh.print_rcv()
    if opts.generate:
      print('\nSaving backup script to: \n {}'.format(outfile))
      if outfile:
        try:
          with open(outfile, 'w') as f:
            f.write(rmh.rcv)
        except:
          print_message('Cannot open file for write: {}'.format(outfile), 'error')
          exit(1)
  print('====================================================================================================')
  print('{:<80}{:>20}'.format('Processing complete!',datetime.now().strftime('%m/%d/%Y %H:%M')))
  print('====================================================================================================')
